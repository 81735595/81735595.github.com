<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep Walking</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://brooch.me/"/>
  <updated>2016-12-23T13:59:43.000Z</updated>
  <id>http://brooch.me/</id>
  
  <author>
    <name>投身烈火</name>
    <email>81735595@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>响应式react：构建高效易用的react应用</title>
    <link href="http://brooch.me/2016/12/23/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/"/>
    <id>http://brooch.me/2016/12/23/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/</id>
    <published>2016-12-23T07:53:53.000Z</published>
    <updated>2016-12-23T13:59:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章翻译自mobx作者 Michel Weststrate 的一篇博客，虽然我也想做到信达雅，奈何英语水平有限……所以我写的内容自动屏蔽了一些前因后果没营养的话，只翻译我觉得重点的内容。我的原则是，捞干的说，不BB~<br>想了解细节的话可移步<a href="https://www.mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/" target="_blank" rel="external">原文</a></p>
</blockquote>
<p>使用react开发应用有啥好处，我想是个前端都能数出个十条八条来。但是如果你的项目需要在浏览器中绘制成千上万的对象，而且这些对象之前还有大量的耦合关系，那维护这些对象也够喝一壶的……mobx作者在发明mobx的时候就面临了这样一个项目，一个对象的值可能被其他对象引用，任何变化都可能引起大量的ui更新和重绘。在一些特殊场景，比如拖拽操作，这些动作还必须在40毫秒响应……</p>
<p>于是，mobx被开发出来了。简单来说，他使用了函数响应式编程的概念 Observables 来解决上述的问题，其实 mobx 并不是第一个使用这一概念的前端库，ember、knockout还有vue其实都使用了这一概念，我个人感觉，mobx就好像把vue和knockout的数据绑定那部分抽出来然后揉到一起一样……真的能发现很多有相似的地方……使用 Observables 的好处就在于，你可以很容易实现自动更新关联数据和sideways data loading，从而解放生产力，提升应用的性能。后面测试数据一章可以看到具体的对比结果。</p>
<a id="more"></a>
<p>下面我们以一个简单的购物应用为例：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-1.png?1" alt="shoping"></p>
<p>里面包含商品列表，购物车，结算等部分。完整的例子可以再<a href="https://jsfiddle.net/mweststrate/46vL0phw/embedded/result/" target="_blank" rel="external">jsfiddle</a>上看到（需要翻墙）。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>首先，我们先看下数据模型。商品列表（Articles）里的每个商品，有名称（name）和价格（price）属性，购物车（Cart）有已加入购物车列表（Entries）和总价（Total）属性。已加入购物车列表中的每个商品除了名字和价格属性以外，还有数量属性（amount）、根据数量和单价计算出的总价。数据之间的关系如下图所示。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-2.png?1" alt="data model"></p>
<p>从上图中我们可以看出，如果对一个数据进行修改，那么就会带动其他的数据修改，同时还得修改ui。<br>大概列一下数据联动的逻辑：</p>
<ul>
<li>如果商品列表里的商品价格发生改变，购物车里的商品价格也需要更新。</li>
<li>……购物车的总价也得更新。</li>
<li>如果购物车中商品数量变化，总价也得跟着更新。</li>
<li>如果商品列表里的商品被重命名了，商品列表的界面得更新。</li>
<li>……购物车里对应的商品也得更新。</li>
<li>如果添加新文章合计购物车……</li>
</ul>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-3.jpg?1" alt="(╯‵□′)╯︵┻━┻"></p>
<p>作为一个程序员，就是这么闹心……你不得不写大量的代码来处理各种可能的状态，处理速度还得快，让用户老爷等着急了你担待得起吗……</p>
<p>那么，让我们来看看怎么用mobx来日翻这些问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params">name, price</span>) </span>&#123;</div><div class="line">    mobx.extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">name</span>: name,</div><div class="line">        <span class="attr">price</span>: price</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ShoppingCartEntry</span>(<span class="params">article</span>) </span>&#123;</div><div class="line">    mobx.extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">article</span>: article,</div><div class="line">        <span class="attr">amount</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">price</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.article ? <span class="keyword">this</span>.article.price * <span class="keyword">this</span>.amount : <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ShoppingCart</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    mobx.extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">entries</span>: [],</div><div class="line">        <span class="attr">total</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.entries.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sum, entry</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> sum + entry.price;</div><div class="line">            &#125;, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用工具函数包装之后，通过构造函数创建的对象都是可观测的，就是说当对象的某一个属性改变，跟他跟他相关联的属性都会自动更新。这样状态变化就不用我们手动维护了，比如添加商品到购物车时总价的变化、物品的价格发生变化时其他关联项的变化等等。</p>
<h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>模型建好了，该搭界面了。下面的列了一段购物车组件的代码，包含了显示购物车里的商品列表和总价。其他组件请自行脑补，都差不离的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CartView = React.createClass(&#123;</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">renderEntry</span>(<span class="params">entry</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> (&lt;CartEntryView entry=&#123;entry&#125; cart=&#123;this.props.cart&#125; key=&#123;entry.id&#125; /&gt;);</div><div class="line">        &#125;</div><div class="line">        return (&lt;div&gt;</div><div class="line">            &lt;ul id="cart"&gt;&#123;this.props.cart.entries.map(renderEntry)&#125;&lt;/ul&gt;</div><div class="line">            &lt;div&gt;&lt;b&gt;Total: &lt;span id="total"&gt;&#123;this.props.cart.total&#125;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;</div><div class="line">        &lt;/div&gt;)</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var CartEntryView = React.createClass(&#123;</div><div class="line">    render: function() &#123;</div><div class="line">        return (&lt;li&gt;</div><div class="line">            &lt;button onClick=&#123;this.removeArticle&#125;&gt;&amp;laquo;&lt;/button&gt;</div><div class="line">            &lt;span&gt;&#123;this.props.entry.article.name&#125;&lt;/span&gt;</div><div class="line">            &lt;span&gt;&#123;this.props.entry.amount&#125;&lt;/span&gt;</div><div class="line">        &lt;/li&gt;);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    removeArticle: function() &#123;</div><div class="line">        if (--this.props.entry.amount &lt; 1)</div><div class="line">            this.props.cart.entries.splice(this.props.cart.entries.indexOf(this.props.entry), 1);      </div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>组件写完了，但是没跟模型关联还跑不起来，需要用mobx-react库里的 <code>mobxReact.observer</code> 方法把组件都包装装一下，这就算关联上了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CartEntryView = mobxReact.observer(React.createClass(&#123;</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> (&lt;li&gt;</div><div class="line">            // etc...</div></pre></td></tr></table></figure>
<p>然后，就没有然后……是的，这就算齐活了。让我们看下<a href="https://jsfiddle.net/mweststrate/46vL0phw/" target="_blank" rel="external">jsfiddle</a>上的演示。</p>
<p>这里 <code>observer</code> 函数为我们做了两件事。首先，它将组件的 <code>render</code> 函数变成一个可观察到的函数。然后，把组件注册到观察者函数，所以每次 <code>render</code> 需要更新了他都会自动更新。<code>mobxReact.observer</code>（如果你使用ES6的话是 <code>@observer</code>）确保每当数据改变，只更新UI的相关部分，就是刚才上面提到的sideways data loading。你可以自己点点试试，注意看下方的日志面板，看看UI更新的数据，你会发现，每次操作，组件的重绘数量都是最低的。</p>
<p>另外，由于每个组件都只跟踪自己的依赖，通常不需要重新渲染子组件。比如，如果购物车的总价重新渲染了，在不必要的情况下就不会重新渲染购物车里的商品列表。</p>
<h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>东西好不好,主要看疗效。<a href="https://jsfiddle.net/mweststrate/wr2hcdwL/" target="_blank" rel="external">这里</a>你可以找到一个一毛一样的应用，但没有使用mobx，而是简单的使用每次替换数据的方法构建的。只有几个商品，不会感觉到有任何区别，但一旦商品数量上升，就会提现出真正意义上的性能差异。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-4.png?1" alt="create"><br><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-5.png?1" alt="update"></p>
<p>创建大量的数据和组件的时候，基本没啥差别。但是在修改数据时，强弱立分高下力判。如果在有10000个元素的列表中更新其中10个元素的数据，速度大约快了十倍。2.5秒下降到250毫秒……那么这种差别是从哪里来的呢？让我们来瞅瞅不适用mobx时React的渲染报告：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-6.png?1" alt="without mobx render reports"></p>
<p>可以看到，ArticleViews 和 CartEntryViews一共渲染了20000次。2433毫秒的渲染时间中，2145毫秒的渲染时间是被浪费的（Wasted time）。Wasted time的意思是：花费在执行渲染函数上的时间，实际上并没有更新任何一个DOM元素。这有力地说明了，无脑更新是一件很浪费cup资源的，组件越多浪费的时间就越多。</p>
<p>相较之下，这是使用mobx的报告：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-7.png?1" alt="with mobx render reports"></p>
<p>重绘的只有31个组件，完全没有一点浪费。就是说每个重新渲染的组件都是确实需要修改的。这正是我们想要实现的效果！</p>
<p>然而，这样你就满足了吗？我们还可以再进一步优化！</p>
<p>从报告中我们还可以看出，267毫秒的总体渲染时间里，大部分剩余的渲染时间消耗在CartView的渲染上（243毫秒）。那是在更新购物车的总价属性。值得注意的是，要重新渲染CartView，也就意味着要检查购物车中一万个商品是否有修改，是否要更新CartEntryView。而这就浪费了大部分时间。我们可以把总价再单独做一个控件，CartTotalView。通过这个简单的处理，如果只是总价的变化，就可以跳过CartView的重新渲染。这使得渲染时间进一步下降到约60毫秒（见上图中的灰色那一条），这比没有使用Mobx的React应用大约快了40倍!</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好的，通过上面的例子我们看到了使用mobx和不使用mobx在性能上的区别。这里还需要强调的一点是，使用了mobx还有一个优势，就是不会影响代码的可维护性，对于程序员来说，这点很重要，就算有万般好处，如果代码写出来像屎一样难看，也不会有人想用对吧？在jsfiddle里面可以看到两个例子的完整程序。两段代码基本没啥太大的区别……┑(￣Д ￣)┍</p>
<p>那么，我们可以用其他技术达到相同的效果吗？也许吧。例如，使用ImmutableJS也能做到sideways data loading。然而，就像我刚才说的，有可能你会收获一坨是一样的代码……毕竟，恕我直言，相对于不可变对象，可变类使用起来会更方便一些。此外，不可变的数据结构不能帮助你保持计算属性。如果使用不可变数据，改变商品的名字ArticleView会重新渲染的很快，但是CartEntryView中引用的相同商品实例就会失效。</p>
<p>另一种优化React应用的方案是为每一个可能发生的操作创建事件，然后在管理这些事件，在恰当的时机恰当的地点（组件）触发（注销）它们。但这将导致编写大量的样板式代码，维护起来相当困难。我不知道人啊，反正我是懒得弄这些……（哥你是不是不会断句……这段看的好纠结啊……）</p>
<p>顺便说一下，我强烈建议使用action来抽象对模型的更新，这样能有效的做到表现和行为分离。</p>
<p>最后，在大型项目中使用mbox配合React是非常好用的。有时我看到数据变化时，界面上某个角落也跟着更新了，我自己都惊呆了……而且还没有任何性能问题，你说气人不……(￣▽￣)”……心动不如行动，让我们把繁重的维护工作都丢给React和Mobx，敬请享受更轻松有趣的coding吧~！</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="https://github.com/mobxjs/mobx" target="_blank" rel="external">MobX library</a></li>
<li><a href="https://facebook.github.io/react/docs/advanced-performance.html" target="_blank" rel="external">React performance guide</a></li>
<li><a href="https://jsfiddle.net/mweststrate/46vL0phw/" target="_blank" rel="external">Shopping cart demo, React with Observables</a></li>
<li><a href="https://jsfiddle.net/mweststrate/wr2hcdwL" target="_blank" rel="external">Shopping cart demo, React without Observables</a></li>
<li><a href="https://jsfiddle.net/mweststrate/vxn7qgdw/" target="_blank" rel="external">Shopping cart demo, JQuery with Observables</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章翻译自mobx作者 Michel Weststrate 的一篇博客，虽然我也想做到信达雅，奈何英语水平有限……所以我写的内容自动屏蔽了一些前因后果没营养的话，只翻译我觉得重点的内容。我的原则是，捞干的说，不BB~&lt;br&gt;想了解细节的话可移步&lt;a href=&quot;https://www.mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用react开发应用有啥好处，我想是个前端都能数出个十条八条来。但是如果你的项目需要在浏览器中绘制成千上万的对象，而且这些对象之前还有大量的耦合关系，那维护这些对象也够喝一壶的……mobx作者在发明mobx的时候就面临了这样一个项目，一个对象的值可能被其他对象引用，任何变化都可能引起大量的ui更新和重绘。在一些特殊场景，比如拖拽操作，这些动作还必须在40毫秒响应……&lt;/p&gt;
&lt;p&gt;于是，mobx被开发出来了。简单来说，他使用了函数响应式编程的概念 Observables 来解决上述的问题，其实 mobx 并不是第一个使用这一概念的前端库，ember、knockout还有vue其实都使用了这一概念，我个人感觉，mobx就好像把vue和knockout的数据绑定那部分抽出来然后揉到一起一样……真的能发现很多有相似的地方……使用 Observables 的好处就在于，你可以很容易实现自动更新关联数据和sideways data loading，从而解放生产力，提升应用的性能。后面测试数据一章可以看到具体的对比结果。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
      <category term="中文渣翻" scheme="http://brooch.me/tags/%E4%B8%AD%E6%96%87%E6%B8%A3%E7%BF%BB/"/>
    
  </entry>
  
  <entry>
    <title>MobX入坑指南(4) -- Utility functions</title>
    <link href="http://brooch.me/2016/12/16/MobX-simple-entry-4/"/>
    <id>http://brooch.me/2016/12/16/MobX-simple-entry-4/</id>
    <published>2016-12-16T05:11:29.000Z</published>
    <updated>2016-12-20T14:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前几篇大概介绍了mobx最常用的几个方法，这次准备把剩余的公共方法都介绍了。</p>
<h2 id="autorunAsync"><a href="#autorunAsync" class="headerlink" title="autorunAsync"></a>autorunAsync</h2><p><code>autorunAsync(debugName?: string, action: () =&gt; void, minimumDelay?: number, scope?): disposer</code></p>
<p><code>autorunAsync</code> 的功能与 <code>autorun</code> 相似，功能都是在观测对象发生变化时自动运行回调函数 <code>action</code>。不同点在于 <code>autorun</code> 是在观测对象发生变化时立即执行的，而 <code>autorunAsync</code>是异步的，可以通过 <code>minimumDelay</code> 参数来指定延迟的时间。<br><a id="more"></a><br>如果被观测对象的在延迟过程中发生多次变化，<code>action</code> 也只会在延迟结束时触发一次，所以它和后面要介绍到的 <code>transaction</code> 方法效果类似。在某些场景下这个方法很有用，比如他可以被用来防止频繁向服务端发起请求。</p>
<p>如果传了 <code>scope</code> 参数，那么 <code>scope</code> 将作为 <code>action</code> 运行时的this。</p>
<p>如果传了第一个参数 <code>debugName</code>，那么在调试工具中将使用 <code>debugName</code> 作为调试信息。</p>
<p>和 <code>autorun</code> 一样，<code>autorunAsync</code> 也会返回一个销毁函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">autorunAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 我们假设 searchBar.keyword 已经被观测, 是搜索输入框的值。当它发生变化时我们要把它发送到服务端请求搜索结果。</span></div><div class="line">	<span class="comment">// 如果这里使用autorun，那么每次变化都会向调用sendKeywordToServer。</span></div><div class="line">    <span class="comment">// 使用autorunAsync延迟300ms发送，当发送时，searchBar.keyword会是这300ms内变化的最终值。</span></div><div class="line">    <span class="comment">// 这样就可以有效的防止频繁请求造成服务抖动。</span></div><div class="line">    sendKeywordToServer(searchBar.keyword);</div><div class="line">&#125;, <span class="number">300</span>);</div></pre></td></tr></table></figure>
<h2 id="Atom类-和-Reaction类"><a href="#Atom类-和-Reaction类" class="headerlink" title="Atom类 和 Reaction类"></a>Atom类 和 Reaction类</h2><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><p>有些时候，你可能想要有更多的数据结构或其他的东西(比如streams)，也可以用于响应计算。可以使用 <code>Atom</code> 类简单快速的实现这一功能。<code>Atom</code> 实例可以通知mobx观测对象发生了变化，而mobx会在启用和停用观测对象的时候通知 <code>Atom</code> 实例。</p>
<p>下面的例子展示了 <code>Atom</code> 的全部功能，这个例子展示了如何创建一个时钟，这个时钟只有在被观测时才会运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;Atom, autorun&#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> </span>&#123;</div><div class="line">    atom;</div><div class="line">    intervalHandler = <span class="literal">null</span>;</div><div class="line">    currentDateTime;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="comment">// 创建一个Atom实例</span></div><div class="line">        <span class="keyword">this</span>.atom = <span class="keyword">new</span> Atom(</div><div class="line">            <span class="comment">// 第一个参数: Atom实例的名字, 调试用的</span></div><div class="line">            <span class="string">"Clock"</span>,</div><div class="line">            <span class="comment">// 第二个参数（可选）: 从不被监听到被监听时的回调函数.</span></div><div class="line">            () =&gt; <span class="keyword">this</span>.startTicking(),</div><div class="line">            <span class="comment">// 第三个参数（可选）: 从被监听到不被监听时的回调函数</span></div><div class="line">            <span class="comment">// 注意，atom实例会多次在这两种状态见转换</span></div><div class="line">            () =&gt; <span class="keyword">this</span>.stopTicking()</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getTime() &#123;</div><div class="line">        <span class="comment">// 如果Atom实例被响应函数调用，则reportObserved返回true。</span></div><div class="line">		<span class="comment">// 同时，reportObserved会通知mobx这个实例在响应回调中被使用了，它还会触发实例的第二个参数（startTicking）</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.atom.reportObserved()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.currentDateTime;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 当没有响应函数调用Atom实例的时候，就不会触发startTicking。</span></div><div class="line">            <span class="comment">// 根据不同的情况，这里也可以做不同的处理，比如抛出一个错误，返回一个默认值等等。</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tick() &#123;</div><div class="line">        <span class="keyword">this</span>.currentDateTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">		<span class="comment">// 通知mobx当前值发生了变化</span></div><div class="line">        <span class="keyword">this</span>.atom.reportChanged();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    startTicking() &#123;</div><div class="line">        <span class="keyword">this</span>.tick(); <span class="comment">// 初始化时钟</span></div><div class="line">        <span class="keyword">this</span>.intervalHandler = setInterval(</div><div class="line">            <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.tick(),</div><div class="line">            <span class="number">1000</span></div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    stopTicking() &#123;</div><div class="line">        clearInterval(<span class="keyword">this</span>.intervalHandler);</div><div class="line">        <span class="keyword">this</span>.intervalHandler = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> Clock();</div><div class="line"></div><div class="line"><span class="keyword">const</span> disposer = autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(clock.getTime()));</div><div class="line"></div><div class="line"><span class="comment">// ... 每秒打印时间</span></div><div class="line"></div><div class="line">disposer();</div><div class="line"></div><div class="line"><span class="comment">// 停止打印。如果没有响应函数调用当前clock实例，那么时钟将停止。会触发stopTicking函数。</span></div></pre></td></tr></table></figure>
<h3 id="Reaction"><a href="#Reaction" class="headerlink" title="Reaction"></a>Reaction</h3><p>使用 <code>Reaction</code> 可以创建一个自定义的监听器。<code>Reaction</code> 接受一个函数作为参数，他会分析这个函数所依赖的被观测对象，然后追踪他们，当他们发生变化时发出事件。</p>
<p>下面的例子展示了 <code>autorun</code> 是如何用 <code>Reaction</code> 实现的，其实这个例子我没看太懂，貌似必须调用 <code>Reaction</code> 的track方法才能追踪并发出信号，但是例子中是在 <code>Reaction</code> 接收的函数中调用，然后runReaction的时候开始，具体的得等我翻了源码之后才能知道了……</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">autorun</span>(<span class="params">view: Lambda, scope?: any</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (scope)</div><div class="line">        view = view.bind(scope);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> reaction = <span class="keyword">new</span> Reaction(view.name || <span class="string">"Autorun"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.track(view);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// 开始或者排入队列</span></div><div class="line">    <span class="keyword">if</span> (isComputingDerivation() || globalState.inTransaction &gt; <span class="number">0</span>)</div><div class="line">        globalState.pendingReactions.push(reaction);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        reaction.runReaction();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> reaction.getDisposer();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="createTransformer"><a href="#createTransformer" class="headerlink" title="createTransformer"></a>createTransformer</h2><p><code>createTransformer(transformation: (value: A) =&gt; B, onCleanup?: (result: B, value?: A) =&gt; void): (value: A) =&gt; B</code></p>
<p><code>createTransformer</code> 可以将一个转换函数（可以将一个值转换为另一个值得函数，比如数组的map方法接收的函数）包装成一个可缓存的响应函数。换句话说, 如果参数<code>transformation</code>接收到一个值A，然后把A转化为了B，那么以后再接收到A，它就会把缓存的B返回。如果A发生了变化，那么<code>transformation</code>会重新计算更新B。如果没有响应函数引用这个转换函数了，那么他将自动清除自己的缓存。</p>
<p>使用 <code>createTransformer</code> 可以方便的对一个完整的数据结构进行转换（原文：it is very easy to transform a complete data graph into another data graph，我个人理解是，作者想表达这种转换方式对图这种数据结构会特别有效……）。转换函数还可以进行嵌套，这样你就可以用很多小的转换函数碎片组成一个树状结构，描述更复杂的模型。最终组成的数据模型不会过期，他会一直与组成他的转换函数碎片保持同步。这个特性能让mobx很容易实现一些强大的功能，比如sideways data loading（react的一个概念，将数据直接推送给某些具体的组件，而非从父级层层传递，数据加载后基本上无需从底层刷新app，而是刷新若干组件中某个具体的部分）、map-reduce（仿佛说的是谷歌三宝之一的MapReduce架构……map-reduce与js相关的资料我没有查到，具体MapReduce的介绍可以看<a href="http://blog.csdn.net/opennaive/article/details/7514146" target="_blank" rel="external">这里</a>）、追踪不可变对象变更历史，等等。</p>
<p><code>onCleanup</code> 参数会在转换函数不再被使用时被调用，可以用来销毁资源。</p>
<p>转换函数需要用响应函数包装才能起作用，比如放在 <code>@observer</code> 或者 <code>autorun</code> 里。和其他的计算属性一样，如果不再有观察者调用，转换函数也将退好为惰性的，不会自动执行，以保证程序的性能。</p>
<p>上面说的各种概念可能会比较难理解，下面列出了两个例子来解释之前的概念:</p>
<h3 id="追踪数据变化，分享数据结构"><a href="#追踪数据变化，分享数据结构" class="headerlink" title="追踪数据变化，分享数据结构"></a>追踪数据变化，分享数据结构</h3><p>这个例子是从<a href="https://github.com/mobxjs/mobx-reactive2015-demo" target="_blank" rel="external">这里</a>来得（我能从中看出追踪数据状态来，但是分享数据结构没看出来……）:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">    store用来保存boxes和arrows</div><div class="line">*/</div><div class="line"><span class="keyword">const</span> store = observable(&#123;</div><div class="line">    <span class="attr">boxes</span>: [],</div><div class="line">    <span class="attr">arrows</span>: [],</div><div class="line">    <span class="attr">selection</span>: <span class="literal">null</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">    states列表用来保存序列化之后的store历史状态</div><div class="line">*/</div><div class="line"><span class="keyword">const</span> states = [];</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    states.push(serializeState(store));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">const</span> serializeState = createTransformer(<span class="function"><span class="params">store</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">boxes</span>: store.boxes.map(serializeBox),</div><div class="line">    <span class="attr">arrows</span>: store.arrows.map(serializeArrow),</div><div class="line">    <span class="attr">selection</span>: store.selection ? store.selection.id : <span class="literal">null</span></div><div class="line">&#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> serializeBox = createTransformer(<span class="function"><span class="params">box</span> =&gt;</span> (&#123;...box&#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> serializeArrow = createTransformer(<span class="function"><span class="params">arrow</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">id</span>: arrow.id,</div><div class="line">    <span class="attr">to</span>: arrow.to.id,</div><div class="line">    <span class="attr">from</span>: arrow.from.id</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>在这个例子中，states中的每个state的序列化，由三个不同的转化函数完成。autorun触发store的序列化，进而序列化所有的boxes和arrows。</p>
<p>让我们用一个假设的例子来看看执行的过程。假设我们往store.boxes中添加一个box，我们叫他box#3。</p>
<ol>
<li>首先box#3会被 <code>map</code> 方法传入 <code>serializeBox</code> 函数，<code>serializeBox</code> 函数执行将其序列化并将结果添加进自己的缓存列表。</li>
<li>当另一个box别添加进store.boxes，将导致 <code>serializeState</code> 函数重新计算结果，从而产生一个全新的boxes列表。在这个过程中，对于已存在的值，serializeBox都将从缓存列表返回旧值，这样转换函数就不需要再次运行了。</li>
<li>然后，如果有人更改box#3属性，这将导致 <code>serializeBox</code> 重新计算box#3的值。转换函数将产生一个新的box#3的Json对象，所有订阅了这个转换函数的观察者都将再次运行。这个例子中 <code>serializeState</code> 会自动执行。<code>serializeState</code>将产生新值，映射所有的box的。除了box#3，其他所有box的值都将会从缓存列表返回。</li>
<li>最后，如果box#3从 <code>store.boxes</code> 中移除，<code>serializeState</code> 也将重新计算。<code>serializeBox</code> 不再监听box#3，监听它的响应函数也将退化为非响应模式。<code>serializeBox</code> 的缓存列表中也将移除box#3的缓存。</li>
</ol>
<p>上面的例子中，我们使用不可变的状态跟踪有效的取得了状态变化列表,共享了数据结构。所有box和arrow都会被转化为简单状态树。每次计算的都会给<code>states</code> 中添加一条新的数据。不同的数据之间将共享box和arrow。</p>
<h3 id="将一个数据结构转换为一个可响应的数据结构"><a href="#将一个数据结构转换为一个可响应的数据结构" class="headerlink" title="将一个数据结构转换为一个可响应的数据结构"></a>将一个数据结构转换为一个可响应的数据结构</h3><blockquote>
<p>这段儿我都看懵逼了……纯凭感觉理解的……下面贴上原文对比着看吧</p>
</blockquote>
<p>Instead of returning plain values from a transformation function, it is also possible to return observable objects. This can be used to transform an observable data graph into a another observable data graph, which can be used to transform… you get the idea.</p>
<p>转换函数除了可以返回一般数据类型，还可以返回观测对象。所以也可以使用转换函数完成可观测对象间的转换。</p>
<p>Here is a small example that encodes a reactive file explorer that will update its representation upon each change. Data graphs that are built this way will in general react a lot faster and will consist of much more straight-forward code, compared to derived data graph that are updated using your own code. See the performance tests for some examples.</p>
<p>下面是个自动响应的文件管理器的例子。使用这种方式构建的数据结构，形式上更加简单直接，数据更新时响应速度也比一般的方式快的多。可以看一看这些例子的<a href="https://github.com/mobxjs/mobx/blob/master/test/perf/transform-perf.js#L10" target="_blank" rel="external">性能测试</a>。</p>
<p>Unlike the previous example, the transformFolder will only run once as long as a folder remains visible; the DisplayFolder objects track the associated Folder objects themselves.</p>
<p>不像之前的例子，如果文件夹一直可见，那么 <code>transformFolder</code> 只会运行一次；<code>DisplayFolder</code> 对象会追踪 <code>Folder</code> 对象的变化。</p>
<p>In the following example all mutations to the state graph will be processed automatically. Some examples:</p>
<p>下面的例子中，所有对 <code>state</code> 的改变都会自动处理。比如做如下操作：</p>
<ol>
<li><p>Changing the name of a folder will update it’s own path property and the path property of all its descendants.</p>
<p>改变文件夹的名字将更新它和它的子文件夹的文件路径，</p>
</li>
<li><p>Collapsing a folder will remove all descendant DisplayFolders from the tree.</p>
<p>折叠一个文件夹将会移除所有子文件夹的DisplayFolder实例</p>
</li>
<li><p>Expanding a folder will restore them again.</p>
<p>展开文件夹时，子文件夹再都恢复回来</p>
</li>
<li><p>Setting a search filter will remove all nodes that do not match the filter, unless they have a descendant that matches the filter.</p>
<p>如果设置了搜索过滤条件，将会只保留符合条件的子文件夹，其他的都会移除掉。<br>……</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;extendObservable, asFlat, observable, createTransformer, autorun&#125; <span class="keyword">from</span> mobx;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Folder</span>(<span class="params">parent, name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">    extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">name</span>: name,</div><div class="line">        <span class="attr">children</span>: asFlat([]),</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DisplayFolder</span>(<span class="params">folder, state</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.state = state;</div><div class="line">    <span class="keyword">this</span>.folder = folder;</div><div class="line">    extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">collapsed</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">name</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.folder.name;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">isVisible</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> !<span class="keyword">this</span>.state.filter || <span class="keyword">this</span>.name.indexOf(<span class="keyword">this</span>.state.filter) !== <span class="number">-1</span> || <span class="keyword">this</span>.children.some(<span class="function"><span class="params">child</span> =&gt;</span> child.isVisible);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">children</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.collapsed)</div><div class="line">                <span class="keyword">return</span> [];</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.folder.children.map(transformFolder).filter(<span class="function"><span class="keyword">function</span>(<span class="params">child</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> child.isVisible;</div><div class="line">            &#125;)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">path</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.folder.parent === <span class="literal">null</span> ? <span class="keyword">this</span>.name : transformFolder(<span class="keyword">this</span>.folder.parent).path + <span class="string">"/"</span> + <span class="keyword">this</span>.name;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> state = observable(&#123;</div><div class="line">    <span class="attr">root</span>: <span class="keyword">new</span> Folder(<span class="literal">null</span>, <span class="string">"root"</span>),</div><div class="line">    <span class="attr">filter</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">displayRoot</span>: <span class="literal">null</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> transformFolder = createTransformer(<span class="function"><span class="keyword">function</span> (<span class="params">folder</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DisplayFolder(folder, state);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    state.displayRoot = transformFolder(state.root);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h2><p><code>expr(worker: () =&gt; void)</code></p>
<p><code>expr</code> 可以在计算属性的函数中创建一个临时的计算属性，其实就是<code>computed(func).get()</code>。作者在文档中说设计这个api的意图是为了提升计算属性的性能，比如下面的例子，如果使用 <code>expr</code> 替代直接用比较运算，可以利用计算属性的缓存，减少运算次数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> TodoView = observer(<span class="function">(<span class="params">&#123;todo, editorState&#125;</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> isSelected = mobx.expr(<span class="function"><span class="params">()</span> =&gt;</span> editorState.selection === todo);</div><div class="line">    <span class="keyword">return</span> &lt;div className=&#123;isSelected ? "todo todo-selected" : "todo"&#125;&gt;&#123;todo.title&#125;&lt;/div&gt;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="extendObservable"><a href="#extendObservable" class="headerlink" title="extendObservable"></a>extendObservable</h2><p><code>extendObservable(target: object, ...properties: object)</code></p>
<p>在之前的几篇文章中，我们已经大概见过 <code>extendObservable</code> 应用的实例了。 <code>extendObservable</code>  和 <code>Object.assign</code> 类似，接受多个参数，将 <code>properties</code> 上所有的键值对，都合并到 <code>target</code> 上，同时把它们都转换成可观测的属性。</p>
<p>如果属性值是一个没有参数的函数，那 <code>extendObservable</code> 将用 <code>computed</code> 把它转化为一个计算属性。</p>
<p>所以，<code>observable(object)</code> 其实是 <code>extendObservable(object, object)</code>的别名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">firstName, lastName</span>) </span>&#123;</div><div class="line">    <span class="comment">// 在当前实例为观测对象</span></div><div class="line">    extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">firstName</span>: firstName,</div><div class="line">        <span class="attr">lastName</span>: lastName</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> matthew = <span class="keyword">new</span> Person(<span class="string">"Zheng"</span>, <span class="string">"Xingcheng"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 向观测对象上添加属性</span></div><div class="line">extendObservable(matthew, &#123;</div><div class="line">    <span class="attr">age</span>: <span class="number">30</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="isObservable"><a href="#isObservable" class="headerlink" title="isObservable"></a>isObservable</h2><p><code>isObservable(testValue:object, propertyName?: string)</code></p>
<p><code>isObservable</code> 是用来判断一个变量是不是用observable观测对象的，如果是就会返回true，如果想看变量的某个属性是否可观测，直接传入属性的引用是不行的，需要传第二个参数 <code>propertyName</code> 指定要判断哪个属性，如果属性可观测，就返回true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = observable(&#123;</div><div class="line">    <span class="attr">firstName</span>: <span class="string">"Zheng"</span>,</div><div class="line">    <span class="attr">lastName</span>: <span class="string">"Xingcheng"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">person.age = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(isObservable(person)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isObservable(person, <span class="string">"firstName"</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isObservable(person.firstName)); <span class="comment">// false (just a string)</span></div><div class="line"><span class="built_in">console</span>.log(isObservable(person, <span class="string">"age"</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>为了细化各种类型的判断，mobx还提供了map，array，object三种类型的判断，比起 <code>isObservable</code> ，他们的判断标准更严格，如果类型不符合就会返回false。</p>
<h3 id="isObservableMap"><a href="#isObservableMap" class="headerlink" title="isObservableMap"></a>isObservableMap</h3><p><code>isObservableMap(testValue:object)</code></p>
<p>如果<code>testValue</code>是用 <code>mobx.map</code> 创建的对象，则返回true。</p>
<h3 id="isObservableArray"><a href="#isObservableArray" class="headerlink" title="isObservableArray"></a>isObservableArray</h3><p><code>isObservableArray(testValue:object)</code></p>
<p>如果<code>testValue</code>是用 <code>mobx.observable(array)</code> 创建的对象，则返回true。</p>
<h3 id="isObservableObject"><a href="#isObservableObject" class="headerlink" title="isObservableObject"></a>isObservableObject</h3><p><code>isObservableObject(testValue:object)</code></p>
<p>如果<code>testValue</code>是用 <code>mobx.observable(object)</code> 创建的对象，则返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> testValue = observable(&#123;</div><div class="line">	<span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">    <span class="attr">obj</span>: &#123;</div><div class="line">    	<span class="attr">x</span>: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">map</span>: map([[<span class="string">'y'</span>,<span class="number">2</span>]])</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(isObservableMap(testValue.map)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isObservableArray(testValue.arr)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isObservableObject(testValue.obj)); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="modifiers"><a href="#modifiers" class="headerlink" title="modifiers"></a>modifiers</h2><h2 id="intercept-amp-observe"><a href="#intercept-amp-observe" class="headerlink" title="intercept &amp; observe"></a>intercept &amp; observe</h2><h2 id="reaction"><a href="#reaction" class="headerlink" title="reaction"></a>reaction</h2><h2 id="spy"><a href="#spy" class="headerlink" title="spy"></a>spy</h2><p><code>spy(listener)</code></p>
<p><code>spy</code> 可以注册一个全局的监听函数，监听所有的mobx发出的事件，通常是用来做log或者做调试的。</p>
<p>比如以下例子，会打印所有的action：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">spy(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (event.type === <span class="string">'action'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.name&#125;</span> with args: <span class="subst">$&#123;event.<span class="built_in">arguments</span>&#125;</span>`</span>)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>不同的操作，event也会不一样，下面的表格是每种事件对应的参数：</p>
<table>
<thead>
<tr>
<th>event</th>
<th>event带的属性</th>
<th>是否可以嵌套发生</th>
</tr>
</thead>
<tbody>
<tr>
<td>action</td>
<td>name, target (scope), arguments, fn (source function of the action)</td>
<td>yes</td>
</tr>
<tr>
<td>transaction</td>
<td>name, target (scope)</td>
<td>yes</td>
</tr>
<tr>
<td>scheduled-reaction</td>
<td>object (Reaction instance)</td>
<td>no</td>
</tr>
<tr>
<td>reaction</td>
<td>object (Reaction instance), fn (source of the reaction)</td>
<td>yes</td>
</tr>
<tr>
<td>compute</td>
<td>object (ComputedValue instance), target (scope), fn (source)</td>
<td>no</td>
</tr>
<tr>
<td>error</td>
<td>message</td>
<td>no</td>
</tr>
<tr>
<td>update (array)</td>
<td>object (the array), index, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>update (map)</td>
<td>object (observable map instance), name, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>update (object)</td>
<td>object (instance), name, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>splice (array)</td>
<td>object (the array), index, added, removed, addedCount, removedCount</td>
<td>yes</td>
</tr>
<tr>
<td>add (map)</td>
<td>object, name, newValue</td>
<td>yes</td>
</tr>
<tr>
<td>add (object)</td>
<td>object, name, newValue</td>
<td>yes</td>
</tr>
<tr>
<td>delete (map)</td>
<td>object, name, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>create (boxed observable)</td>
<td>object (ObservableValue instance), newValue</td>
<td>yes</td>
</tr>
</tbody>
</table>
<h2 id="toJS"><a href="#toJS" class="headerlink" title="toJS"></a>toJS</h2><p><code>toJS(value: any, supportCycles?=true: boolean)</code></p>
<p>toJS可以将一个observableObject下的转化为javascript原生的对象。他会递归转换array，object，map和基础类型的值，但是不会转换计算属性和其他不可枚举的值。默认情况下，toJS会缓存下每次运行的值，貌似作者设计这个api就是为了输出log用的，可以设置 <code>supportCycles</code> 参数为false来提高toJS的性能。</p>
<p>对于更复杂的序列化反序列化场景，mobx的作者推荐使用他开发的<a href="https://github.com/mobxjs/serializr" target="_blank" rel="external">serializr</a>库。</p>
<h2 id="transaction"><a href="#transaction" class="headerlink" title="transaction"></a>transaction</h2><p><code>transaction(worker: () =&gt; void)</code></p>
<p>在之前的 <code>autorunAsync</code> 有提到过，除了 <code>autorunAsync</code> ，还可以使用 <code>transaction</code> 来做批量处理。</p>
<p><code>transaction</code> 用来批处理一系列的更新，而不会通知观测对象，当所有更新结束，才会发出通知。<code>transaction</code> 接收一个没有参数的worker函数作为参数，在这个函数执行完成之前，不会通知观察者。<code>transaction</code> 的返回值就是worker函数的返回值。另外 <code>transaction</code> 是同步的，可以被嵌套，只有最外层的 <code>transaction</code> 执行完，才会触发响应。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;observable, transaction, autorun&#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> numbers = observable([]);</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(numbers.length, <span class="string">"numbers!"</span>));</div><div class="line"><span class="comment">// Prints: '0 numbers!'</span></div><div class="line"></div><div class="line">transaction(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    transaction(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        numbers.push(<span class="number">1</span>);</div><div class="line">        numbers.push(<span class="number">2</span>);</div><div class="line">    &#125;);</div><div class="line">    numbers.push(<span class="number">3</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// Prints: '3 numbers!'</span></div></pre></td></tr></table></figure>
<h2 id="untracked"><a href="#untracked" class="headerlink" title="untracked"></a>untracked</h2><p><code>untracked(fn: () =&gt; void)</code></p>
<p>使用 <code>untracked</code> 可以创建一个不被观测的代码块，通常 <code>untracked</code> 需要放在 <code>(@)action</code> 里面才有意义，比如以下的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> person = observable(&#123;</div><div class="line">    <span class="attr">firstName</span>: <span class="string">"Michel"</span>,</div><div class="line">    <span class="attr">lastName</span>: <span class="string">"Weststrate"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(</div><div class="line">        person.lastName,</div><div class="line">        <span class="string">","</span>,</div><div class="line">        <span class="comment">// person.firstName放在了untracked的回调里面，所以不会跟这个autorun的监听函数绑定到一起</span></div><div class="line">		<span class="comment">// 在修改person.firstName时就不会触发这个监听函数</span></div><div class="line">        untracked(<span class="function"><span class="params">()</span> =&gt;</span> person.firstName)</div><div class="line">    );</div><div class="line">&#125;);</div><div class="line"><span class="comment">// prints: Weststrate, Michel</span></div><div class="line"></div><div class="line">person.firstName = <span class="string">"G.K."</span>;</div><div class="line"><span class="comment">// doesn't print!</span></div><div class="line"></div><div class="line">person.lastName = <span class="string">"Chesterton"</span>;</div><div class="line"><span class="comment">// prints: Chesterton, G.K.</span></div></pre></td></tr></table></figure>
<h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p><code>when(debugName?, predicate: () =&gt; boolean, effect: () =&gt; void, scope?)</code></p>
<p><code>when</code> 会感测并运行参数predicate，predicate有点类似一个计算属性，当predicate为true的时候，则自动运行effect，然后销毁自己。所以 <code>when</code> 是一个只运行一次的 <code>autorun</code>。</p>
<p>下面这个例子展示了用 <code>when</code> 来实现自动销毁组件的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        when(</div><div class="line">            <span class="comment">// 当断言为真...</span></div><div class="line">            () =&gt; !<span class="keyword">this</span>.isVisible,</div><div class="line">            <span class="comment">// ... 则运行一次然后销毁</span></div><div class="line">            () =&gt; <span class="keyword">this</span>.dispose()</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @computed get isVisible() &#123;</div><div class="line">        <span class="comment">// 返回组件是否可见</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dispose() &#123;</div><div class="line">        <span class="comment">// 销毁组件</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇整理了下mobx的公共方法和作用。就此，基础api算是都介绍完了。之后会再着重写些使用方法和介绍mobx原理的内容。</p>
<p>话说最近懒癌又开始发作了……_(:3 」∠)_……看着朋友们跟打了鸡血一样写那么多blog好着急的说……希望以后能迎头赶上吧……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前几篇大概介绍了mobx最常用的几个方法，这次准备把剩余的公共方法都介绍了。&lt;/p&gt;
&lt;h2 id=&quot;autorunAsync&quot;&gt;&lt;a href=&quot;#autorunAsync&quot; class=&quot;headerlink&quot; title=&quot;autorunAsync&quot;&gt;&lt;/a&gt;autorunAsync&lt;/h2&gt;&lt;p&gt;&lt;code&gt;autorunAsync(debugName?: string, action: () =&amp;gt; void, minimumDelay?: number, scope?): disposer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;autorunAsync&lt;/code&gt; 的功能与 &lt;code&gt;autorun&lt;/code&gt; 相似，功能都是在观测对象发生变化时自动运行回调函数 &lt;code&gt;action&lt;/code&gt;。不同点在于 &lt;code&gt;autorun&lt;/code&gt; 是在观测对象发生变化时立即执行的，而 &lt;code&gt;autorunAsync&lt;/code&gt;是异步的，可以通过 &lt;code&gt;minimumDelay&lt;/code&gt; 参数来指定延迟的时间。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
      <category term="中文渣翻" scheme="http://brooch.me/tags/%E4%B8%AD%E6%96%87%E6%B8%A3%E7%BF%BB/"/>
    
  </entry>
  
  <entry>
    <title>MobX入坑指南(3) -- Observable Types</title>
    <link href="http://brooch.me/2016/12/09/MobX-simple-entry-3/"/>
    <id>http://brooch.me/2016/12/09/MobX-simple-entry-3/</id>
    <published>2016-12-09T05:29:04.000Z</published>
    <updated>2016-12-09T13:13:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周阅读了一部分mobx的源码，和作者写的几篇介绍文章，发现这个库有些特性还挺有趣的。以下的内容大部分翻译自<a href="http://mobxjs.github.io/mobx/" target="_blank" rel="external">mobx文档</a>中 <code>Observable Types</code> 一节，奈何小生英文水平有限，没有划词软件帮忙就看不懂句子……所以翻的很渣，基本上都是掺杂了一些我的理解在里边，连蒙带猜拼出来的，有啥写的不对的，也请多指教了~(￣▽￣)~*</p>
<p>在mobx中，如果你想监听某个变量的变化，需要先使用 <code>observable</code> 函数将其转化为生成Observable对象才行。这个章节主要讲的是 <code>observable</code> 函数生成的不同Observable对象</p>
<a id="more"></a>
<h2 id="Observable-Objects"><a href="#Observable-Objects" class="headerlink" title="Observable Objects"></a>Observable Objects</h2><p>当 <code>observable</code> 函数接受的参数是个普通的javascript object（普通javascript对象是指不是通过构造函数生成的对象，mobx的判断方式是，通过getPrototypeOf获取原型，检查是不是Object.prototype或者null）时，这个对象中的所有属性都将被传入 <code>observable</code> 函数进行转换，如果属性值是object或者array，则会递归的转化内部的元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;observable, autorun, action&#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = observable(&#123;</div><div class="line">    <span class="comment">// 常量会自动使用observable转化:</span></div><div class="line">    name: <span class="string">"John"</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">42</span>,</div><div class="line">    <span class="attr">showAge</span>: <span class="literal">false</span>,</div><div class="line">    <span class="comment">// 有get描述符的属性会自动使用computed转化:</span></div><div class="line">    get labelText() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.showAge ? <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> (age: <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>)`</span> : <span class="keyword">this</span>.name;</div><div class="line">    &#125;,</div><div class="line">	<span class="comment">// 如果直接写</span></div><div class="line">	<span class="comment">// labelText: function () &#123;</span></div><div class="line">    <span class="comment">//    return this.showAge ? `$&#123;this.name&#125; (age: $&#123;this.age&#125;)` : this.name;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">	<span class="comment">// 在自动转化时会报一个warning，mobx认为渲染函数需要用computed显式调动一下</span></div><div class="line">	<span class="comment">// labelText: computed(function () &#123;</span></div><div class="line">	<span class="comment">//    return this.showAge ? `$&#123;this.name&#125; (age: $&#123;this.age&#125;)` : this.name;</span></div><div class="line">	<span class="comment">// &#125;)</span></div><div class="line">    <span class="comment">// 同理，action也需要显式调动一下:</span></div><div class="line">    setAge: action(<span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(person.labelText));</div><div class="line"></div><div class="line">person.name = <span class="string">"Dave"</span>;</div><div class="line"><span class="comment">// 'Dave'</span></div><div class="line"></div><div class="line">person.setAge(<span class="number">21</span>);</div><div class="line"><span class="built_in">console</span>.log(person.age);</div><div class="line"><span class="comment">// 21</span></div></pre></td></tr></table></figure>
<p>需要注意的点：</p>
<ul>
<li><p>当对象传入 <code>observable</code> 函数时，只有当时对象上已经存在的属性才能被监听，后添加的属性是不能的，如果想要往已经生成的Observable对象上添加属性，需要使用<a href="http://mobxjs.github.io/mobx/refguide/extend-observable.html" target="_blank" rel="external"><code>extendObservable</code></a>函数进行类似merge的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//接上面的例子</span></div><div class="line">extendObservable(person, &#123;</div><div class="line">    <span class="attr">sex</span>: <span class="string">'male'</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(person.sex);</div><div class="line"><span class="comment">// 'male'</span></div></pre></td></tr></table></figure>
</li>
<li><p>只有普通对象能够被转化为Observable对象。使用构造函数创建的对象，需要在构造函数初始化时使用<a href="http://mobxjs.github.io/mobx/refguide/extend-observable.html" target="_blank" rel="external"><code>extendObservable</code></a>函数合并属性。使用类创建的对象，需要使用 <a href="http://mobxjs.github.io/mobx/refguide/observable-decorator.html" target="_blank" rel="external"><code>@observable</code></a>装饰器包装类的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">firstName, lastName</span>) </span>&#123;</div><div class="line">	<span class="comment">// 在一个新的对象里写要监听的属性，然后merge和当前实例merge</span></div><div class="line">	extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">		<span class="attr">firstName</span>: firstName,</div><div class="line">		<span class="attr">lastName</span>: lastName</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> zxc = <span class="keyword">new</span> Person(<span class="string">"Zheng"</span>, <span class="string">"Xingcheng"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 或者</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    @observable firstName:string = <span class="string">""</span>;</div><div class="line">    @observable lastName:string = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(firstName, lastName) &#123;</div><div class="line">		<span class="keyword">this</span>.firstName = firstName;</div><div class="line">		<span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> zxc = <span class="keyword">new</span> Person(<span class="string">"Zheng"</span>, <span class="string">"Xingcheng"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>带有get描述符的属性会自动被<a href="http://mobxjs.github.io/mobx/refguide/computed-decorator" target="_blank" rel="external"><code>@computed</code></a>转化，第一个例子中已经展示了。</p>
</li>
<li>如果对象的属性值是一个构造函数生成的对象（我真是不想把它叫成”非普通对象”……），那这个属性也不会被 <code>observable</code> 函数自动转化。</li>
<li>基本上使用<code>observable</code> 函数自动转化已经能解决绝大部分的使用场景了（原文写的是”95% of the cases”……）。如果想要了解更详细的设定每个属性的方法，请看 <a href="http://mobxjs.github.io/mobx/refguide/modifiers.html" target="_blank" rel="external"><code>modifiers</code></a> 一章（本来这一章的内容也想发到这里的，但是实在是没时间写了只能拉倒……等下次吧）。</li>
</ul>
<h2 id="Observable-Arrays"><a href="#Observable-Arrays" class="headerlink" title="Observable Arrays"></a>Observable Arrays</h2><p>和 object 类似，array 也可以使用 <code>observable</code>函数转化为ObservableArray对象。当然，也是递归转化每个元素的，所以数组的所有元素也会被转化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;observable, autorun&#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> todos = observable([</div><div class="line">    &#123; <span class="attr">title</span>: <span class="string">"吃午饭"</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</div><div class="line">    &#123; <span class="attr">title</span>: <span class="string">"喝咖啡"</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</div><div class="line">]);</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"代办:"</span>, todos</div><div class="line">        .filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed)</div><div class="line">        .map(<span class="function"><span class="params">todo</span> =&gt;</span> todo.title)</div><div class="line">        .join(<span class="string">", "</span>)</div><div class="line">    );</div><div class="line">&#125;);</div><div class="line"><span class="comment">// '代办: 喝咖啡'</span></div><div class="line"></div><div class="line">todos[<span class="number">0</span>].completed = <span class="literal">false</span>;</div><div class="line"><span class="comment">// '代办: 吃午饭, 喝咖啡'</span></div><div class="line"></div><div class="line">todos[<span class="number">2</span>] = &#123; <span class="attr">title</span>: <span class="string">"睡午觉"</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;;</div><div class="line"><span class="comment">// '代办: 吃午饭, 喝咖啡, 睡午觉'</span></div><div class="line"></div><div class="line">todos.shift();</div><div class="line"><span class="comment">// '代办: 喝咖啡, 睡午觉'</span></div></pre></td></tr></table></figure>
<p>由于ES5中原生数组的限制（<code>array.observe</code>到ES7中才有，而且数组不能扩展），<code>observable</code>函数基于原始数组克隆了一个新的数组，这个新数组支持所有原生数组的方法和功能，同时还有监听值变化的能力。</p>
<p>不过，当使用Array.isArray检查包装后数组时返回的是false。所以在跟其他库联合使用时，如果想把ObservableArray对象当做数组传递给其他库，最好使用浅拷贝生成新数组，或者使用 <code>array.slice</code> 方法生成新数组，就是说 <code>Array.isArray(observable([]).slice())</code> 返回的是true。</p>
<p>由于不喜欢原生的 <code>array.sort</code> 和 <code>array.reverse</code> 方法，ObservableArray对象的 <code>sort</code> 和 <code>reverse</code> 方法是并不会改变自身的，而是返回一个新的ObservableArray对象。</p>
<p>除了原生数组支持的方法，ObservableArray对象还可以使用以下的方法：</p>
<ul>
<li><code>intercept(interceptor)</code><br>这个方法可以在所有数组的操作被应用之前，将操作拦截。具体的请看<a href="http://mobxjs.github.io/mobx/refguide/observe.html" target="_blank" rel="external">observe &amp; intercept</a></li>
<li><code>observe(listener, fireImmediately? = false)</code><br>这个方法可以监听数组的变化，回调函数会接收数组新增或者修改的元素，符合<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/observe" target="_blank" rel="external">ES7的规范</a>。这个方法返回一个注销函数用来停止监听。</li>
<li><code>clear()</code><br>清空数组。</li>
<li><code>replace(newItems)</code><br>替换数组里的所有元素。</li>
<li><code>find(predicate: (item, index, array) =&gt; boolean, thisArg?, fromIndex?)</code><br>使用方法与ES7的 <code>array.find</code> 一致，但是增加了formIndex参数。</li>
<li><code>remove(value)</code><br>移除数组中第一个值等于value的元素，如果移除成功会返回true。</li>
<li><code>peek()</code><br>与 <code>slice</code> 类似，会返回一个包含所有元素的数组。它与 <code>slice</code> 的区别在于 <code>peek</code> 不会进行保护性拷贝，所以性能更好。</li>
</ul>
<h2 id="Observable-Maps"><a href="#Observable-Maps" class="headerlink" title="Observable Maps"></a>Observable Maps</h2><p><code>observable(asMap(values?, modifier?))</code> 和 <code>map(values?, modifier?))</code> 方法可以创建一个ObservableMap对象。如果你不想响应特定属性的变化，还要添加删除属性，那么使用ObservableMap对象很合适。不同于ES6的Map对象，ObservableMap对象是能用字符串当做key。</p>
<p>根据ES6 Map的规范，可以使用以下方法:</p>
<ul>
<li><code>has(key)</code><br>返回map中是否存在这个key，这个方法是可被监听的</li>
<li><code>set(key, value)</code><br>设置key对应的value，如果key之前不错在，那么这个key会被添加上</li>
<li><code>delete(key)</code><br>删除key和key对应的value</li>
<li><code>get(key)</code><br>获取key对应的value，如果没找到会返回undefined</li>
<li><code>keys()</code><br>获取map的所有key，顺序为key的插入顺序</li>
<li><code>values()</code><br>获取map的所有key对应的value，顺序为key的插入顺序</li>
<li><code>entries()</code><br>返回一个数组，数组中每个元素为一个数组，数组中的元素为map中的key/value对，形式如[key, value]，顺序为key的插入顺序</li>
<li><code>forEach(callback:(value, key, map) =&gt; void, thisArg?)</code><br>对map中的每个key/value对调用回调</li>
<li><code>clear()</code><br>清除map中的所有key/value对</li>
<li><code>size()</code><br>返回map中所有key/value对的数量</li>
</ul>
<p>ObservableMap对象还提供了以下方法可以使用:</p>
<ul>
<li><code>toJS()</code><br>返回一个map的浅拷贝的对象，如果想获得深拷贝的对象，需要使用 <code>mobx.toJS(map)</code></li>
<li><code>intercept(interceptor)</code><br>注册一个拦截器，拦截器会在map被修改之前被触发。具体的请看<a href="http://mobxjs.github.io/mobx/refguide/observe.html" target="_blank" rel="external">observe &amp; intercept</a></li>
<li><code>observe(listener, fireImmediately?)</code><br>注册一个监听，map被修改时会被触发。与Object.observe类似。具体的请看<a href="http://mobxjs.github.io/mobx/refguide/observe.html" target="_blank" rel="external">observe &amp; intercept</a></li>
<li><code>merge(object | map)</code><br>将对象上所有的属性拷贝到当前map中</li>
</ul>
<h2 id="Primitive-常量）"><a href="#Primitive-常量）" class="headerlink" title="Primitive (常量）"></a>Primitive (常量）</h2><p>在javascript中，常量是不可变的，所以也没办法观测。所以如果想要监听一个常量属性的变化，需要使用 <code>observable</code> 函数包装一下。</p>
<p><code>observable</code> 函数包装后会返回一个ObservablePrimitive对象。这个对象使用get和set方法来获取和改变变量的值。可以使用 <code>.observe</code> 方法来监听值的变化。不过通常使用 <code>mobx.autorun</code> 是更好的选择。</p>
<p>以下是ObservablePrimitive支持的方法：</p>
<ul>
<li><code>get()</code><br>返回当前值</li>
<li><code>set(value)</code><br>替换当前存储的值，并通知所有的监听器</li>
<li><code>intercept(interceptor)</code><br>注册拦截器，当值发生变化前触发。具体的请看<a href="http://mobxjs.github.io/mobx/refguide/observe.html" target="_blank" rel="external">observe &amp; intercept</a></li>
<li><code>observe(callback: (newValue, previousValue) =&gt; void, fireImmediately = false)</code><br>注册监听器，当值发生变化时触发，返回一个注销函数。具体的请看<a href="http://mobxjs.github.io/mobx/refguide/observe.html" target="_blank" rel="external">observe &amp; intercept</a></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;observable&#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> cityName = observable(<span class="string">"Vienna"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(cityName.get());</div><div class="line"><span class="comment">// 'Vienna'</span></div><div class="line"></div><div class="line">cityName.observe(<span class="function"><span class="keyword">function</span>(<span class="params">newCity, oldCity</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(oldCity, <span class="string">"-&gt;"</span>, newCity);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">cityName.set(<span class="string">"Amsterdam"</span>);</div><div class="line"><span class="comment">// 'Vienna -&gt; Amsterdam'</span></div></pre></td></tr></table></figure>
<h2 id="References-引用类型）"><a href="#References-引用类型）" class="headerlink" title="References (引用类型）"></a>References (引用类型）</h2><p>之前在ObservableObject中提到，observable在转换时会自动用computed包装函数，这个自动转换其实是由限制条件的。mobx只会转换渲染用的函数，既函数不能接受参数，如果接受参数，则认为这个是一个复合函数，就不会自动转化。同样的，如果对象中有属性是通过构造函数或者类创建的对象，也不会自动转化。他们都继续保持着转化之前的引用。</p>
<p>有时我们也会有这一类的需求，要求对象中某个属性不被自动转化。可以使用 <code>asReference</code> 来达到这一目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = observable(&#123;</div><div class="line">    <span class="attr">x</span> : <span class="number">3</span>,</div><div class="line">    <span class="attr">doubler</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x*<span class="number">2</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">someFunc</span>: asReference(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</div><div class="line">    &#125;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(test.doubler);</div><div class="line"><span class="comment">// 6</span></div><div class="line"><span class="built_in">console</span>.log(test.someFunc);</div><div class="line"><span class="comment">// function() &#123;</span></div><div class="line"><span class="comment">//     return this.x;</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体感觉上，mobx的api和knockout的api很像，但是在实现原理上，更像rx。mobx实现监听变化调用回调的过程是同步的，通过这种方式就能会自动的分析各个变量间的调用关系，从而减少重复订阅的情况。同时计算最新的值时还是用了memoizing技术，这样就算调用频繁，性能上也能得到保证。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="http://mobxjs.github.io/mobx/refguide/object.html" target="_blank" rel="external">Observable Objects</a></li>
<li><a href="http://mobxjs.github.io/mobx/refguide/array.html" target="_blank" rel="external">Observable Arrays</a></li>
<li><a href="http://mobxjs.github.io/mobx/refguide/map.html" target="_blank" rel="external">Observable Maps</a></li>
<li><a href="http://mobxjs.github.io/mobx/refguide/boxed.html" target="_blank" rel="external">Primitive values and references</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周阅读了一部分mobx的源码，和作者写的几篇介绍文章，发现这个库有些特性还挺有趣的。以下的内容大部分翻译自&lt;a href=&quot;http://mobxjs.github.io/mobx/&quot;&gt;mobx文档&lt;/a&gt;中 &lt;code&gt;Observable Types&lt;/code&gt; 一节，奈何小生英文水平有限，没有划词软件帮忙就看不懂句子……所以翻的很渣，基本上都是掺杂了一些我的理解在里边，连蒙带猜拼出来的，有啥写的不对的，也请多指教了~(￣▽￣)~*&lt;/p&gt;
&lt;p&gt;在mobx中，如果你想监听某个变量的变化，需要先使用 &lt;code&gt;observable&lt;/code&gt; 函数将其转化为生成Observable对象才行。这个章节主要讲的是 &lt;code&gt;observable&lt;/code&gt; 函数生成的不同Observable对象&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
      <category term="中文渣翻" scheme="http://brooch.me/tags/%E4%B8%AD%E6%96%87%E6%B8%A3%E7%BF%BB/"/>
    
  </entry>
  
  <entry>
    <title>MobX入坑指南(2) -- action</title>
    <link href="http://brooch.me/2016/11/29/MobX-simple-entry-2/"/>
    <id>http://brooch.me/2016/11/29/MobX-simple-entry-2/</id>
    <published>2016-11-29T12:40:50.000Z</published>
    <updated>2016-12-09T05:43:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2016/11/29/MobX-simple-entry-1/">上一篇</a>简单介绍了下mobx常用的几个api(observable、computed、autorun)，以及mobx-react的api(observer)。这次说说action。</p>
<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>用法：</p>
<ul>
<li>action(fn)</li>
<li>action(name, fn)</li>
<li>@action classMethod</li>
<li>@action(name) classMethod</li>
<li>@action boundClassMethod = (args) =&gt; { body }</li>
<li>@action(name) boundClassMethod = (args) =&gt; { body }</li>
</ul>
<p>之前的例子里使用了回调的方式来触发响应，mobx其实也支持使用flux的方式来出发响应，并且在2.2版本提供了action的功能。</p>
<p>action是一个工厂函数，可以接受name和fn两个参数，name是String，主要描述action的作用，fn是Function，是这个action的具体逻辑。action执行后返回一个函数，调用这个函数就会执行action，其实就是调用fn参数。</p>
<p>个人感觉在mobx中，action的作用更多的是用来注释当前的操作……使用的时候在name参数上写操作是干啥的，能够快速的了解action的意图。当然如果安装了devtools，action还能输出调试信息。</p>
<p>需要注意的是，如果使用<a href="https://github.com/mobxjs/mobx/blob/gh-pages/docs/refguide/api.md#usestrict" target="_blank" rel="external">useStrict</a>api开启了严格模式，就必须通过action才能修改状态(state)，直接修改值会报错。</p>
<p>举个🌰</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;observable, useStrict, action, computed, autorun&#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</div><div class="line"></div><div class="line">useStrict(<span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = observable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line"><span class="keyword">let</span> sum = computed(<span class="function"><span class="params">()</span> =&gt;</span> numbers.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>));</div><div class="line"></div><div class="line"><span class="keyword">let</span> disposer1 = autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`sum:<span class="subst">$&#123;sum.get()&#125;</span>`</span>));</div><div class="line"><span class="comment">// sum:6</span></div><div class="line"><span class="keyword">let</span> disposer2 = autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`length:<span class="subst">$&#123;numbers.length&#125;</span>`</span>));</div><div class="line"><span class="comment">// length:3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> pushNumber = action(<span class="string">'push number'</span>,()=&gt;&#123;</div><div class="line">	numbers.push(<span class="number">4</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">pushNumber(<span class="number">4</span>)</div><div class="line"><span class="comment">// sum:10</span></div><div class="line"><span class="comment">// length:4</span></div><div class="line"></div><div class="line">numbers.push(<span class="number">5</span>)</div><div class="line"><span class="comment">// Uncaught Error: [mobx] Invariant failed: It is not allowed to create</span></div><div class="line"><span class="comment">// or change state outside an `action` when MobX is in strict mode. Wrap</span></div><div class="line"><span class="comment">// the current method in `action` if this state change is intended.</span></div></pre></td></tr></table></figure>
<p>另外，action在执行时是可以接受参数的，而且action在执行后还会返回fn参数的返回值，这一点文档里没有明显的说明，害的我翻源码才翻出来的……┑(￣Д ￣)┍……话说mobx是用typescript写的呢。虽然ts最近很火，而且功能也确实挺实用的，但是我对java一样死板的语法却怎么都都爱不起来……所以更看好<a href="https://www.zhihu.com/question/31415286/answer/58022648" target="_blank" rel="external">WebAssembly</a>一些……</p>
<p>扯远了扯远了……那么我们再把上面那个例子修改一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;observable, useStrict, action, computed, autorun&#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</div><div class="line"></div><div class="line">useStrict(<span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = observable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line"><span class="keyword">let</span> sum = computed(<span class="function"><span class="params">()</span> =&gt;</span> numbers.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>));</div><div class="line"><span class="comment">// sum:6</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> disposer = autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`sum:<span class="subst">$&#123;sum.get()&#125;</span>`</span>));</div><div class="line"></div><div class="line"><span class="keyword">var</span> pushNumber = action(<span class="string">'push number'</span>,(number)=&gt;numbers.push(number))</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">`length:<span class="subst">$&#123;pushNumber(<span class="number">6</span>)&#125;</span>`</span>)</div><div class="line"><span class="comment">// sum:12</span></div><div class="line"><span class="comment">// length:4</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">`length:<span class="subst">$&#123;pushNumber(<span class="number">7</span>)&#125;</span>`</span>)</div><div class="line"><span class="comment">// sum:19</span></div><div class="line"><span class="comment">// length:5</span></div></pre></td></tr></table></figure>
<p>从上面的例子可以看到，传入pushNumber的参数最后被传入了action的fn中，然后pushNumber返回了push的返回值。</p>
<p>官方文档中的一个例子也能看到调用action返回函数时传递参数的应用场景：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@action createRandomContact() &#123;</div><div class="line">	<span class="keyword">this</span>.pendingRequestCount++;</div><div class="line">	superagent</div><div class="line">		.get(<span class="string">'https://randomuser.me/api/'</span>)</div><div class="line">		.set(<span class="string">'Accept'</span>, <span class="string">'application/json'</span>)</div><div class="line">		.end(action(<span class="string">"createRandomContact-callback"</span>, (error, results) =&gt; &#123;</div><div class="line">			<span class="keyword">if</span> (error)</div><div class="line">				<span class="built_in">console</span>.error(error);</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(results.text).results[<span class="number">0</span>];</div><div class="line">				<span class="keyword">const</span> contact = <span class="keyword">new</span> Contact(<span class="keyword">this</span>, data.dob, data.name, data.login.username, data.picture)</div><div class="line">				contact.addTag(<span class="string">'random-user'</span>);</div><div class="line">				<span class="keyword">this</span>.contacts.push(contact);</div><div class="line">				<span class="keyword">this</span>.pendingRequestCount--;</div><div class="line">			&#125;</div><div class="line">		&#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个🌰中可以看到，action的返回值作为superagent.end的回调，接收error和results两个参数，最后传入fn进行处理。这个例子也引出了另一个问题，action中如何处理一步操作。</p>
<h2 id="async-action-和-runInAction"><a href="#async-action-和-runInAction" class="headerlink" title="async action 和 runInAction"></a>async action 和 runInAction</h2><p>action只能影响正在运行的函数，而无法影响当前函数调用的异步操作。也就是说如果fn中有setTimeout，promise.then，async函数，并且这些函数的回调里对state进行了修改，那么这些回调也应该用action包装一下（在非严格模式下，action和直接修改state值都能生效，所以并不会出现异常，如果是严格模式下就会报错）。</p>
<p>还有，如果要使用<code>async</code>函数作为action，不能直接用action包装<code>async</code>函数，这里需要使用一个tricky，将一个<code>async</code>匿名函数赋值给一个变量或者属性再做包装。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@action updateDocument = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> fetchDataFromUrl();</div><div class="line">    <span class="comment">/* required in strict mode to be allowed to update state: */</span></div><div class="line">    runInAction(<span class="string">"update state after fetching data"</span>, () =&gt; &#123;</div><div class="line">        <span class="keyword">this</span>.data.replace(data);</div><div class="line">        <span class="keyword">this</span>.isSaving = <span class="literal">true</span>;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子还用到了<code>runInAction</code>，它其实就是action(name,fn)()的语法糖，调用后action会立即执行，它的用法是：<code>runInAction(name?, fn, scope?)</code>，scope是fn调用时的this指向。注：2.3.0版本以后才能使用。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="http://mobxjs.github.io/mobx/refguide/action.html" target="_blank" rel="external">MobX Documentation – action</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2016/11/29/MobX-simple-entry-1/&quot;&gt;上一篇&lt;/a&gt;简单介绍了下mobx常用的几个api(observable、computed、autorun)，以及mobx-react的api(observer)。这次说说action。&lt;/p&gt;
&lt;h2 id=&quot;action&quot;&gt;&lt;a href=&quot;#action&quot; class=&quot;headerlink&quot; title=&quot;action&quot;&gt;&lt;/a&gt;action&lt;/h2&gt;&lt;p&gt;用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;action(fn)&lt;/li&gt;
&lt;li&gt;action(name, fn)&lt;/li&gt;
&lt;li&gt;@action classMethod&lt;/li&gt;
&lt;li&gt;@action(name) classMethod&lt;/li&gt;
&lt;li&gt;@action boundClassMethod = (args) =&amp;gt; { body }&lt;/li&gt;
&lt;li&gt;@action(name) boundClassMethod = (args) =&amp;gt; { body }&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前的例子里使用了回调的方式来触发响应，mobx其实也支持使用flux的方式来出发响应，并且在2.2版本提供了action的功能。&lt;/p&gt;
&lt;p&gt;action是一个工厂函数，可以接受name和fn两个参数，name是String，主要描述action的作用，fn是Function，是这个action的具体逻辑。action执行后返回一个函数，调用这个函数就会执行action，其实就是调用fn参数。&lt;/p&gt;
&lt;p&gt;个人感觉在mobx中，action的作用更多的是用来注释当前的操作……使用的时候在name参数上写操作是干啥的，能够快速的了解action的意图。当然如果安装了devtools，action还能输出调试信息。&lt;/p&gt;
&lt;p&gt;需要注意的是，如果使用&lt;a href=&quot;https://github.com/mobxjs/mobx/blob/gh-pages/docs/refguide/api.md#usestrict&quot;&gt;useStrict&lt;/a&gt;api开启了严格模式，就必须通过action才能修改状态(state)，直接修改值会报错。&lt;/p&gt;
&lt;p&gt;举个🌰&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React全家桶又填新成员 MobX入坑指南(1)</title>
    <link href="http://brooch.me/2016/11/23/MobX-simple-entry-1/"/>
    <id>http://brooch.me/2016/11/23/MobX-simple-entry-1/</id>
    <published>2016-11-23T14:34:10.000Z</published>
    <updated>2016-12-09T05:43:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>话说，吐槽被react全家桶坑的文章已经算是各大论坛上的月经贴了吧……行内样式、jsx里html和js混排、依赖太多、学习曲线陡峭……当然其中不乏抱怨redux反人类的……</p>
<p>当然，这篇文章并不是来黑react不好的，毕竟以后涨工资还得靠它呢哈哈哈(￣▽￣)……</p>
<p>今天咱们要说的是众多槽点之一，”反人类的redux”和其替代方案。<br><a id="more"></a></p>
<h2 id="redux有什么不好？"><a href="#redux有什么不好？" class="headerlink" title="redux有什么不好？"></a>redux有什么不好？</h2><p>首先，redux绝对是个优秀的库。它体小精悍，api简单优雅，扩展能力强，足以衍生出丰富的工具集和生态系统。在它出现之前，各种flux实现貌似都不能让人如意，以至于有人宁可用 backbone 甚至是 angular 和 react搭配，也不用flux……后来redux出现，解决了flux操作繁琐的问题，开始受到人们的关注，再后来作者也加入了 facebook从事react的开发，redux也顺理成章的成为了react官方推荐状态管理库。</p>
<p>但是，在真正去开发的时候，我发现状态的维护还是有些繁琐，如果你在设计阶段没有考虑周全，开发时就要不停的在action,container,reducer之前修改，穿梭，让人眼花缭乱……嗯，也没准儿是我项目不够大……</p>
<p>另外，由于redux大量使用函数式编程的思想，门槛有点高呢。当时为了理解redux里面的概念，我大概读了一周的文档……</p>
<p>按你胃（Anywhere），如果你更熟悉面向对象，羡慕mvvm框架的简单，那你真的应该体验一下mobx</p>
<h2 id="mobx是啥？"><a href="#mobx是啥？" class="headerlink" title="mobx是啥？"></a>mobx是啥？</h2><p>mobx是个新的状态管理库，响应式的，我是看了<a href="http://weibo.com/1400854834/EdqkGrQh6" target="_blank" rel="external">阮一峰的微博</a>知道的，后来查了资料发现，redux的作者在twitter推荐了这个库，还是作为redex的替代品……</p>
<p>那么废话少说，让我们现在看看mobx怎么用吧</p>
<h2 id="api简单介绍"><a href="#api简单介绍" class="headerlink" title="api简单介绍"></a>api简单介绍</h2><p>和redux一样，mobx是一个独立的库，不依赖于react也能自己用，它只有三个概念：观测状态，计算值和反应。这三个概念分别对应三个mobx的api：observable，computed和autorun。</p>
<p>咱们先来个最简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; observable, computed, autorun &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = observable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line"><span class="keyword">let</span> sum = computed(<span class="function"><span class="params">()</span> =&gt;</span> numbers.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>));</div><div class="line"></div><div class="line"><span class="keyword">let</span> disposer1 = autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`sum:<span class="subst">$&#123;sum.get()&#125;</span>`</span>));</div><div class="line"><span class="keyword">let</span> disposer2 = autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`length:<span class="subst">$&#123;numbers.length&#125;</span>`</span>));</div><div class="line"><span class="comment">// sum:6</span></div><div class="line"><span class="comment">// length:3</span></div><div class="line"></div><div class="line">numbers.push(<span class="number">4</span>);</div><div class="line"><span class="comment">// sum:10</span></div><div class="line"><span class="comment">// length:4</span></div><div class="line"></div><div class="line">disposer2();</div><div class="line">numbers.push(<span class="number">5</span>);</div><div class="line"><span class="comment">// sum:15</span></div></pre></td></tr></table></figure>
<p>这个例子中，observable用来绑定数据；computed用来绑定计算方法；autorun用来注册数据变化时响应的方法，返回的函数用来取消响应。</p>
<p>下面我们试着来写一个TodoList</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; observable, computed, autorun &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</div><div class="line">    id = <span class="built_in">Math</span>.random();</div><div class="line">    @observable content;</div><div class="line">    @observable finished = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">constructor</span>(content) &#123;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> </span>&#123;</div><div class="line">    @observable todos = [];</div><div class="line">    @computed get todoListString() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.finished).map(<span class="function">(<span class="params">todo, i</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>. <span class="subst">$&#123;todo.content&#125;</span>`</span>).join(<span class="string">'\n'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> TodoList();</div><div class="line"></div><div class="line">store.todos.push(</div><div class="line">    <span class="keyword">new</span> Todo(<span class="string">"task1"</span>),</div><div class="line">    <span class="keyword">new</span> Todo(<span class="string">"task2"</span>),</div><div class="line">    <span class="keyword">new</span> Todo(<span class="string">"task3"</span>)</div><div class="line">);</div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.todoListString))</div><div class="line"></div><div class="line">store.todos[<span class="number">2</span>].finished = <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<p>从上面的例子可以看到，针对类的属性，可以使用修饰器@observable、@computed来进行绑定，修饰器是ES7的一个提案，目前Babel已经支持。详细的介绍可以看<a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="external">ECMAScript 6 入门中修饰器一章</a></p>
<p>如果不想用修饰器，也可以使用extendObservable函数，跟修饰器的功能是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; extendObservable, autorun &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</div><div class="line">    id = <span class="built_in">Math</span>.random();</div><div class="line">    <span class="keyword">constructor</span>(content) &#123;</div><div class="line">		extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">			<span class="attr">content</span>: content,</div><div class="line">			<span class="attr">finished</span>: <span class="literal">false</span></div><div class="line">		&#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>() &#123;</div><div class="line">		extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">			<span class="attr">todos</span>: [],</div><div class="line">			<span class="attr">todoListString</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		        <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.finished).map(<span class="function">(<span class="params">todo, i</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>. <span class="subst">$&#123;todo.content&#125;</span>`</span>).join(<span class="string">'\n'</span>);</div><div class="line">		    &#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> TodoList();</div><div class="line"></div><div class="line">store.todos.push(</div><div class="line">    <span class="keyword">new</span> Todo(<span class="string">"task1"</span>),</div><div class="line">    <span class="keyword">new</span> Todo(<span class="string">"task2"</span>),</div><div class="line">    <span class="keyword">new</span> Todo(<span class="string">"task3"</span>)</div><div class="line">);</div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.todoListString))</div><div class="line"></div><div class="line">store.todos[<span class="number">2</span>].finished = <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<h2 id="mobx-react"><a href="#mobx-react" class="headerlink" title="mobx-react"></a>mobx-react</h2><p>在跟react配合时，mobx提供了mobx-react包，使用@observer装饰器或者observer函数，可以自动将react组建的render方法包装到mobx.autorun里面。还是以前面的TodoList为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; observable, computed &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</div><div class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> mobxReact;</div><div class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> React;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</div><div class="line">    id = <span class="built_in">Math</span>.random();</div><div class="line">    @observable content;</div><div class="line">    @observable finished = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">constructor</span>(content) &#123;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">    &#125;</div><div class="line">    finish() &#123;</div><div class="line">      <span class="keyword">this</span>.finished = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> </span>&#123;</div><div class="line">    @observable todos = [];</div><div class="line">    @computed get unFinishedList() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.finished);</div><div class="line">	&#125;</div><div class="line">    @computed get finishedList() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.finished);</div><div class="line">    &#125;</div><div class="line">	addTodo(content) &#123;</div><div class="line">	  	<span class="keyword">if</span> (content)&#123;</div><div class="line">			<span class="keyword">this</span>.todos.push(<span class="keyword">new</span> Todo(content))</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@observer</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoListView</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">		<span class="keyword">const</span> &#123; todoList &#125; = <span class="keyword">this</span>.props;</div><div class="line">		<span class="keyword">let</span> onChange = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</div><div class="line">	    	<span class="keyword">this</span>.value = event.target.value</div><div class="line">	    &#125;</div><div class="line">		<span class="keyword">let</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123; todoList.addTodo(<span class="keyword">this</span>.value) &#125;</div><div class="line">        <span class="keyword">return</span> (&lt;div&gt;</div><div class="line">			&lt;h2&gt;添加任务&lt;/h2&gt;</div><div class="line">			&lt;input type="text" value=&#123; this.value &#125; onChange=&#123; onChange &#125;/&gt;</div><div class="line">			&lt;button type="button" onClick=&#123; onClick &#125;&gt;添加&lt;/button&gt;</div><div class="line">			&lt;h2&gt;未完成任务&lt;/h2&gt;</div><div class="line">            &lt;ol&gt;</div><div class="line">                &#123;todoList.unFinishedList.slice(0).map((todo,index) =&gt;</div><div class="line">                    &lt;TodoView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt;</div><div class="line">                )&#125;</div><div class="line">            &lt;/ol&gt;</div><div class="line">            Tasks left: &#123;todoList.unFinishedList.length&#125;</div><div class="line">			&lt;h2&gt;已完成任务&lt;/h2&gt;</div><div class="line">			&lt;ol&gt;</div><div class="line">                &#123;todoList.finishedList.map((todo) =&gt;</div><div class="line">                    &lt;FinishedView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt;</div><div class="line">                )&#125;</div><div class="line">            &lt;/ol&gt;</div><div class="line">        &lt;/div&gt;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const TodoView = observer((props) =&gt;</div><div class="line">&#123;</div><div class="line">		let &#123; todo &#125; = props;</div><div class="line">    return (&lt;li&gt;</div><div class="line">            &lt;input</div><div class="line">                type="checkbox"</div><div class="line">                checked=&#123;todo.finished&#125;</div><div class="line">                onClick=&#123;todo.finish.bind(todo)&#125;</div><div class="line">                /&gt;&#123;todo.content&#125;</div><div class="line">        &lt;/li&gt;)</div><div class="line">    &#125;</div><div class="line">);</div><div class="line"></div><div class="line">@observer</div><div class="line">class FinishedView extends Component&#123;</div><div class="line">	render() &#123;</div><div class="line">		let &#123; todo &#125; = this.props;</div><div class="line">	  return (&lt;li&gt;</div><div class="line">	        &lt;del&gt;&#123;todo.content&#125;&lt;/del&gt;</div><div class="line">	    &lt;/li&gt;)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const store = new TodoList();</div><div class="line"></div><div class="line">React.render(&lt;TodoListView todoList=&#123;store&#125; /&gt;, document.body);</div><div class="line"></div><div class="line">store.todos.push(</div><div class="line">    new Todo("Get Coffee"),</div><div class="line">    new Todo("Write simpler code")</div><div class="line">);</div></pre></td></tr></table></figure>
<p>在上面的例子里可以看到，使用mobx-react的不同点只是在编写组件类时observer包装了一下，其他的跟不使用mobx-react没什么区别。另外，如果在stroe里加入方法，就可以做到类似action一样的动作，使用上比redux要简单很多。当然这也引出一个问题，就是当子组件状态变化影响到父组件的状态，如何通知父组件。redux用类似dbus的设计解决了这个问题，mobx怎么解决，我还没有看到，后续看到了再做补充。</p>
<h2 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h2><p>怎么说呢，总感觉mobx的功能和vue好像……￣ω￣=……特别是computed……这种设计对于写惯了mvc的人来说会感觉非常亲切，stroe其实就是相当于平时常写的model嘛，概念很容易理解。难度上，个人感觉不高，除了一些绑定后的数据需要调用set、get方法，api也不多。</p>
<p>其实mobx还有很多的功能没有介绍到，而且在网上资料也很少，如果有时间的话，打算试着翻译mobx的文档。更多的例子，后续再做详细的补充，今天就先到这里吧，我实在是写不动了……_(:3 」∠)_</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="http://mobxjs.github.io/mobx/index.html" target="_blank" rel="external">MobX Documentation</a></li>
<li><a href="http://frontendinsights.com/short-introduction-to-mobx/" target="_blank" rel="external">A short introduction to MobX</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话说，吐槽被react全家桶坑的文章已经算是各大论坛上的月经贴了吧……行内样式、jsx里html和js混排、依赖太多、学习曲线陡峭……当然其中不乏抱怨redux反人类的……&lt;/p&gt;
&lt;p&gt;当然，这篇文章并不是来黑react不好的，毕竟以后涨工资还得靠它呢哈哈哈(￣▽￣)……&lt;/p&gt;
&lt;p&gt;今天咱们要说的是众多槽点之一，”反人类的redux”和其替代方案。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>浮点数计算为什么不精确</title>
    <link href="http://brooch.me/2016/11/17/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%B2%BE%E7%A1%AE/"/>
    <id>http://brooch.me/2016/11/17/浮点数计算为什么不精确/</id>
    <published>2016-11-17T02:22:47.000Z</published>
    <updated>2016-11-17T14:49:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>其实这篇博客早就写好了，只不过之前懒一直没有整理完善……哈哈哈…… _(:3 」∠)_</p>
</blockquote>
<p>前几几几几天，在微博上看到<a href="http://weibo.com/u/1778942741" target="_blank" rel="external">寇胖</a>转了一个关于浮点数计算的<a href="http://weibo.com/1996814695/DC0c6iAVD" target="_blank" rel="external">微博</a>，里面的内容不太准确。正好之前我调查过一些关于浮点数的资料，在这里好好掰吃掰吃，做个记录~(￣▽￣)~*</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>先说结论，嫌又臭又长的看到这里就可以了:</p>
<ul>
<li>浮点数计算不精确并不是bug，因为标准就是这样的。</li>
<li>原因简单来说是这样：2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。</li>
<li>解决方法：对于需要精确结果的场景，别直接使用浮点数进行计算。现阶段可以使用<a href="http://mikemcl.github.io/big.js/" target="_blank" rel="external">big.js</a>解决，等以后ecmascript实现decimal了，就可以使用decimal类型计算了。</li>
</ul>
<a id="more"></a>
<h2 id="小数算不准，真的是js的锅吗？"><a href="#小数算不准，真的是js的锅吗？" class="headerlink" title="小数算不准，真的是js的锅吗？"></a>小数算不准，真的是js的锅吗？</h2><p>说到这个问题，其实这是两个锅，js计算不准确不止会出现在小数的计算上，还会出现在大整数计算上，可以运行下面两行代码查看问题的具体表现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>; <span class="comment">// false</span></div><div class="line"><span class="number">9999999999999999</span> + <span class="number">2</span> == <span class="number">10000000000000001</span>; <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>当然，这个锅肯定不是javascript背。事实上，使用了IEEE 754 标准来存储浮点类型的任何编程语言（C/C++/C#/Java 等等）都存在精度丢失问题。</p>
<p>例如在 Java 中，要想算准浮点数，同样不能直接计算，需要使用 BigDecimal 类来进行相应的处理。</p>
<p>当然，javascript也并没有落后于其他语言。ECMAScript 规范中已有 <a href="http://wiki.ecmascript.org/doku.php?id=proposals:decimal" target="_blank" rel="external">decimal </a>类型的提案了，但目前尚未被正式采纳。</p>
<h2 id="为什么不算准？"><a href="#为什么不算准？" class="headerlink" title="为什么不算准？"></a>为什么不算准？</h2><p>要解释这个问题，就得从10进制与2进制的转换说起。</p>
<p>众所周知，计算机做运算是使用二级制的。所以其实咱们在程序中做10进制运算，都是要转换为2进制再进行计算的。10进制整数转换为2进制的方法可能大家都知道：</p>
<blockquote>
<p><strong>除以2，商继续除以2，得到0为止，将余数逆序排列</strong><br>例如：<br>22 / 2     11 余 0<br>11 / 2     5  余 1<br>5  / 2     2  余 1<br>2  / 2     1  余 0<br>1  / 2     0  余 1<br>所以22的的二进制是10110</p>
</blockquote>
<p>那10进制小数转换为2进制的方法呢？</p>
<blockquote>
<p><strong>乘以2，取整，小数部分继续乘以2，取整，得到小数部分0为止，将整数顺序排列</strong><br>0.8125 x 2     1.625 取 1<br>0.625  x 2     1.25  取 1<br>0.25   x 2     0.5   取 0<br>0.5    x 2     1.0   取 1<br>所以0.8125的二进制是0.1101</p>
</blockquote>
<p>那么问题就来了，比如你想计算10进制0.2的2进制：</p>
<blockquote>
<p>0.2 x 2     0.4<br>0.4 x 2     0.8<br>0.8 x 2     1.6<br>0.6 x 2     1.2<br>0.2 x 2     0.4<br>……</p>
</blockquote>
<p>发现了吗？它乘不尽，是无限循环的……</p>
<p>而 javascript 使用64位双精度浮点数存储数字，类似科学计数法，其中1位用来存储符号，11位用来存储指数值，52位用来存储尾数值（真正的数字），当计算的结果的二进制有效位数超过 52 位时，就会出现精度丢失的问题……</p>
<p>大整数计算的原因也是一样，有效位数超过 52位时，精度就会丢失</p>
<p>这就解释了下面这种情况：</p>
<blockquote>
<p>十进制 0.1 的二进制为 0.0 0011 0011 0011 … （循环 0011）<br>十进制 0.2 的二进制为 0.0011 0011 0011 … （循环 0011）</p>
<p>0.1 + 0.2 相加可表示为：<br>   e = -4; m = 1.10011001100…1100（52 位）<br> + e = -3; m = 1.10011001100…1100（52 位）<br>-——————————————–<br>   e = -3; m = 0.11001100110…0110<br> + e = -3; m = 1.10011001100…1100<br>-——————————————–<br>   e = -3; m = 10.01100110011…001<br>-——————————————–<br> = 0.01001100110011…001<br> = 0.30000000000000004（十进制）</p>
</blockquote>
<p>但是0.05和0.2用二进制都无法精确表达，0.05 + 0.2 却不会计算错误，0.2 + 0.7 会计算错误，1.2 +1.7 又不会，这又是为什么？</p>
<p>具体的原因我并没有找到相关的资料……</p>
<p>貌似这和 IEEE 754 的舍入模式有关系。</p>
<p>IEEE 754 采用的是最近舍入模式，和我们最熟悉的是四舍五入模式有些许不同，也是比较容易引起误解的地方之一。举例比较如下：</p>
<blockquote>
<p>最近舍入模式：Round(0.5) = 0; Round(1.5) = 2; Round(2.5) = 2;</p>
<p>四舍五入模式：Round(0.5) = 1; Round(1.5) = 2; Round(2.5) = 3;</p>
</blockquote>
<p>既当有两个最接近的可表示的值时首选“偶数”值。</p>
<p>具体的原因我会再调查调查，有了新的资料再补充到这里。</p>
<h2 id="如何解决这个问题？"><a href="#如何解决这个问题？" class="headerlink" title="如何解决这个问题？"></a>如何解决这个问题？</h2><p>当然，问题的解决方法其实也已经有前人跟咱们铺好路了，毕竟这个在问题在编程领域里其实是个挺常见的问题……</p>
<p>网上的解决办法五花八门，总的原则就是逐位运算。我推荐 github 上  <a href="https://github.com/MikeMcl" target="_blank" rel="external">MikeMcl</a> 开发的 <a href="http://mikemcl.github.io/big.js/" target="_blank" rel="external">big.js</a> 。这个库不尽支持基础运算，而且还支持各种函数运算和比较运算，相当全面呢。实现上，是将数字按照科学计数法解析成一个包含正负符号、指数、尾数的对象，再做运算。例子就不写了，它的文档很全，而且简单易懂。</p>
<p>有趣的是，这个作者除了 big.js 还开发了另两个计算库 bignumber.js 和 decimal.js，三个库的侧重点不一样，关于这三个的对比，有兴趣的话可以看作者自己写的wiki <a href="https://github.com/MikeMcl/big.js/wiki" target="_blank" rel="external">What is the difference between big.js, bignumber.js and decimal.js?</a></p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章:"></a>相关文章:</h2><ol>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513140&amp;idx=1&amp;sn=565517e977ac56904305a4a9f9d65012#rd" target="_blank" rel="external">浮点数为什么不精确？</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/maplejan/p/3893545.html" target="_blank" rel="external">JavaScript超大整数加法</a></p>
</li>
<li><p><a href="http://demon.tw/copy-paste/javascript-precision.html" target="_blank" rel="external">JavaScript 中小数和大整数的精度丢失</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/bossin/archive/2007/04/08/704567.html" target="_blank" rel="external">IEEE 754 浮点数的表示精度探讨</a></p>
</li>
<li><p><a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="external">IEEE 754</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实这篇博客早就写好了，只不过之前懒一直没有整理完善……哈哈哈…… _(:3 」∠)_&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前几几几几天，在微博上看到&lt;a href=&quot;http://weibo.com/u/1778942741&quot;&gt;寇胖&lt;/a&gt;转了一个关于浮点数计算的&lt;a href=&quot;http://weibo.com/1996814695/DC0c6iAVD&quot;&gt;微博&lt;/a&gt;，里面的内容不太准确。正好之前我调查过一些关于浮点数的资料，在这里好好掰吃掰吃，做个记录~(￣▽￣)~*&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h2&gt;&lt;p&gt;先说结论，嫌又臭又长的看到这里就可以了:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浮点数计算不精确并不是bug，因为标准就是这样的。&lt;/li&gt;
&lt;li&gt;原因简单来说是这样：2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。&lt;/li&gt;
&lt;li&gt;解决方法：对于需要精确结果的场景，别直接使用浮点数进行计算。现阶段可以使用&lt;a href=&quot;http://mikemcl.github.io/big.js/&quot;&gt;big.js&lt;/a&gt;解决，等以后ecmascript实现decimal了，就可以使用decimal类型计算了。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://brooch.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="floating point" scheme="http://brooch.me/tags/floating-point/"/>
    
      <category term="big decimal" scheme="http://brooch.me/tags/big-decimal/"/>
    
      <category term="IEEE 754" scheme="http://brooch.me/tags/IEEE-754/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="http://brooch.me/2016/11/16/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>http://brooch.me/2016/11/16/新的开始/</id>
    <published>2016-11-16T14:23:33.000Z</published>
    <updated>2016-11-16T16:36:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>哈，距离上次写博客刚好一年了呢，话说我还真是懒呢…… _(:3 」∠)_</p>
<p>这里不得不感叹下榜样的力量是无穷的。要不是<a href="http://testudy.cc/" target="_blank" rel="external">继伟</a>发起每周写博客的活动，估计我现在还在床上躺着呢……读好书，交高人，此言非虚呀~</p>
<p>总之，希望这是个新的开始，期待能遇见更好的自己~(｡･ω･｡)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈，距离上次写博客刚好一年了呢，话说我还真是懒呢…… _(:3 」∠)_&lt;/p&gt;
&lt;p&gt;这里不得不感叹下榜样的力量是无穷的。要不是&lt;a href=&quot;http://testudy.cc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;继伟&lt;/a&gt;发起每周写博
    
    </summary>
    
      <category term="感想" scheme="http://brooch.me/categories/%E6%84%9F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>Capitan之后JetBrains的产品都不能用了</title>
    <link href="http://brooch.me/2015/11/21/Capitan%E4%B9%8B%E5%90%8EJetBrains%E7%9A%84%E4%BA%A7%E5%93%81%E9%83%BD%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86/"/>
    <id>http://brooch.me/2015/11/21/Capitan之后JetBrains的产品都不能用了/</id>
    <published>2015-11-21T04:06:24.000Z</published>
    <updated>2016-11-16T16:35:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>更新了osx升级10.11 EL Capitan之后发现有好多坑啊……限制超多而且JetBrains的产品都不能用了……</p>
<p>查了一溜够貌似是之前安装的一些系统软件都被清除了，而且还需要接触rootless模式，总之先附上搜索到的资料链接吧</p>
<p><a href="http://blog.euphonictech.com/entry/2014/11/12/192856" target="_blank" rel="external">Intellij IDEAやAppCodeが起動しない場合に考えられること</a>（需翻墙）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;更新了osx升级10.11 EL Capitan之后发现有好多坑啊……限制超多而且JetBrains的产品都不能用了……&lt;/p&gt;
&lt;p&gt;查了一溜够貌似是之前安装的一些系统软件都被清除了，而且还需要接触rootless模式，总之先附上搜索到的资料链接吧&lt;/p&gt;
&lt;p&gt;&lt;a h
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="osx" scheme="http://brooch.me/tags/osx/"/>
    
  </entry>
  
  <entry>
    <title>邮件链接中加入参数可以给要发送的邮件添加标题和内容，第一次发现唉</title>
    <link href="http://brooch.me/2015/10/21/%E9%82%AE%E4%BB%B6%E9%93%BE%E6%8E%A5%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E7%BB%99%E8%A6%81%E5%8F%91%E9%80%81%E7%9A%84%E9%82%AE%E4%BB%B6%E6%B7%BB%E5%8A%A0%E6%A0%87%E9%A2%98%E5%92%8C%E5%86%85%E5%AE%B9%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%91%E7%8E%B0%E5%94%89/"/>
    <id>http://brooch.me/2015/10/21/邮件链接中加入参数可以给要发送的邮件添加标题和内容，第一次发现唉/</id>
    <published>2015-10-21T03:51:34.000Z</published>
    <updated>2016-11-16T16:36:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>a标签的href属性值可以是mailto协议的地址，这个比较常见，但是能加参数设置邮件内容我还是第一次见呢。</p>
<p>示例：</p>
<p>mailto:xxx@xxx.com?Subject=标题&amp;Body=正文</p>
<p>貌似按照get方式加上参数就行了，Subject代表标题，Body代表正文</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;a标签的href属性值可以是mailto协议的地址，这个比较常见，但是能加参数设置邮件内容我还是第一次见呢。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;mailto:xxx@xxx.com?Subject=标题&amp;amp;Body=正文&lt;/p&gt;
&lt;p&gt;貌似按照get方式加上参数就行
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="html" scheme="http://brooch.me/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>总结下hexo搭建的过程</title>
    <link href="http://brooch.me/2015/10/16/%E6%80%BB%E7%BB%93%E4%B8%8Bhexo%E6%90%AD%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://brooch.me/2015/10/16/总结下hexo搭建的过程/</id>
    <published>2015-10-16T14:23:22.000Z</published>
    <updated>2016-11-16T16:35:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2016-11-16 UPDATE:</strong> 距离写下这篇博客已经过了一年了，hexo在这一年里发展的挺快。现在hexo的文档已经齐全，整个工作流程也相当顺畅了。</p>
<p>安装过程中如果 node-gyp 报 error，可以尝试升级xcode，并安装xcode-select 升级 CLT。</p>
<p>下面附上几篇比较好的文章，建站过程中遇到问题可以查阅一下。</p>
<p><a href="http://wp.huangshiyang.com/hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" target="_blank" rel="external">Hexo常见问题解决方案</a><br>收集了很多使用hexo过程中的常见问题</p>
<a id="more"></a>
<p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客</a><br>文章的内容很全，不止写了如何使用hexo，如何使用github，如何找图床等问题也都有描述，如果是使用github pages搭建博客的话，看这篇就够用了</p>
<p><a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br>和上一篇文章一样，这篇文章的内容也很全面，除了博客的搭建过程，如何在购买域名和服务器也有描述，只不过图片貌似都已经失效了……有些遗憾呢……</p>
<p><a href="http://segmentfault.com/a/1190000003776905" target="_blank" rel="external">翻译自GitHub Pages的Help页面（仍在更新中）</a><br>github pages的help页面的翻译，对于英语苦手的人来说，应该会很有帮助吧</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;2016-11-16 UPDATE:&lt;/strong&gt; 距离写下这篇博客已经过了一年了，hexo在这一年里发展的挺快。现在hexo的文档已经齐全，整个工作流程也相当顺畅了。&lt;/p&gt;
&lt;p&gt;安装过程中如果 node-gyp 报 error，可以尝试升级xcode，并安装xcode-select 升级 CLT。&lt;/p&gt;
&lt;p&gt;下面附上几篇比较好的文章，建站过程中遇到问题可以查阅一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wp.huangshiyang.com/hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot;&gt;Hexo常见问题解决方案&lt;/a&gt;&lt;br&gt;收集了很多使用hexo过程中的常见问题&lt;/p&gt;
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://brooch.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>总结一下升级OS X El Capitan后brew遇到的问题</title>
    <link href="http://brooch.me/2015/10/15/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%8D%87%E7%BA%A7OS-X-El-Capitan%E5%90%8Ebrew%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://brooch.me/2015/10/15/总结一下升级OS-X-El-Capitan后brew遇到的问题/</id>
    <published>2015-10-15T14:45:31.000Z</published>
    <updated>2016-11-17T10:00:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>升级了osx之后，先是brew update的时候报错，后来用brew安装jenv的时候又提示说需要root权限</p>
<blockquote>
<p>Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo.<br>Error: Failure while executing: /usr/bin/otool -L /usr/bin/install_name_tool</p>
</blockquote>
<p>但是sudo brew install又报错</p>
<blockquote>
<p>Error: Cowardly refusing to <code>sudo brew install</code><br>You can use brew with sudo, but only if the brew executable is owned by root.<br>However, this is both not recommended and completely unsupported so do so at your own risk.</p>
</blockquote>
<p>搜了下貌似是新版osx的问题，需要进行权限设置，用chown命令设置一下就好了</p>
<p>以下是一些参考资料</p>
<p><a href="http://digitizor.com/2014/06/29/fix-cowardly-refusing-sudo-error-brew/" target="_blank" rel="external">How To Fix Cowardly Refusing to Sudo error in Brew – Mac OS X</a></p>
<p><a href="https://github.com/Homebrew/homebrew/issues/41665" target="_blank" rel="external">Failed <code>brew update</code> on El Capitan (OS X 10.11) Beta</a></p>
<p><a href="http://gotohayato.com/content/69" target="_blank" rel="external">Mac OS X El Capitan にアップデートした後に brew update が動かない場合の対処方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级了osx之后，先是brew update的时候报错，后来用brew安装jenv的时候又提示说需要root权限&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Agreeing to the Xcode/iOS license requires admin privileges,
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="osx" scheme="http://brooch.me/tags/osx/"/>
    
      <category term="brew" scheme="http://brooch.me/tags/brew/"/>
    
  </entry>
  
  <entry>
    <title>啊，我的第一次</title>
    <link href="http://brooch.me/2015/10/14/first-love/"/>
    <id>http://brooch.me/2015/10/14/first-love/</id>
    <published>2015-10-14T07:15:06.000Z</published>
    <updated>2016-11-16T16:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>人生第一篇blog，总觉得有点儿小激动呢……⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄</p>
<p>话说再过生日就30岁了呢，做程序员也是第8个年头，愈发觉得将自己的平时的一些想法、遇到的一些问题记录下来很重要，其实以前也很想，奈何我懒……</p>
<p>总之，之后会努力多写一些，也算是对自己的一种提升吧，嗯，希望我能一直坚持下去~</p>
<p>&lt;(￣▽￣)&gt; 哈哈哈……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生第一篇blog，总觉得有点儿小激动呢……⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄&lt;/p&gt;
&lt;p&gt;话说再过生日就30岁了呢，做程序员也是第8个年头，愈发觉得将自己的平时的一些想法、遇到的一些问题记录下来很重要，其实以前也很想，奈何我懒……&lt;/p&gt;
&lt;p&gt;总之，之后会努力多写一些，也
    
    </summary>
    
      <category term="感想" scheme="http://brooch.me/categories/%E6%84%9F%E6%83%B3/"/>
    
    
  </entry>
  
</feed>
