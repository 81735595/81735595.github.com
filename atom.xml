<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep Walking</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://brooch.me/"/>
  <updated>2017-09-18T01:47:43.000Z</updated>
  <id>http://brooch.me/</id>
  
  <author>
    <name>投身烈火</name>
    <email>81735595@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何利用状态变化控制异步流程</title>
    <link href="http://brooch.me/2017/09/15/how-to-use-status-change-to-control-async-process/"/>
    <id>http://brooch.me/2017/09/15/how-to-use-status-change-to-control-async-process/</id>
    <published>2017-09-15T14:27:44.000Z</published>
    <updated>2017-09-18T01:47:43.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="promise" scheme="http://brooch.me/tags/promise/"/>
    
      <category term="status" scheme="http://brooch.me/tags/status/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(9)</title>
    <link href="http://brooch.me/2017/09/08/vue-source-notes-9/"/>
    <id>http://brooch.me/2017/09/08/vue-source-notes-9/</id>
    <published>2017-09-08T10:03:50.000Z</published>
    <updated>2017-09-08T10:04:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次看了事件部分的代码，这次准备看 render 的代码</p>
<a id="more"></a>
<h1 id="Vue构造函数和vue实例-instance"><a href="#Vue构造函数和vue实例-instance" class="headerlink" title="Vue构造函数和vue实例 instance"></a>Vue构造函数和vue实例 instance</h1><h2 id="render-js"><a href="#render-js" class="headerlink" title="render.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/instance/render.js" target="_blank" rel="external">render.js</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @flow */</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  warn,</div><div class="line">  nextTick,</div><div class="line">  toNumber,</div><div class="line">  _toString,</div><div class="line">  looseEqual,</div><div class="line">  emptyObject,</div><div class="line">  handleError,</div><div class="line">  looseIndexOf</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> VNode, &#123;</div><div class="line">  cloneVNodes,</div><div class="line">  createTextVNode,</div><div class="line">  createEmptyVNode</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'../vdom/vnode'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; createElement &#125; <span class="keyword">from</span> <span class="string">'../vdom/create-element'</span></div><div class="line"><span class="keyword">import</span> &#123; renderList &#125; <span class="keyword">from</span> <span class="string">'./render-helpers/render-list'</span></div><div class="line"><span class="keyword">import</span> &#123; renderSlot &#125; <span class="keyword">from</span> <span class="string">'./render-helpers/render-slot'</span></div><div class="line"><span class="keyword">import</span> &#123; resolveFilter &#125; <span class="keyword">from</span> <span class="string">'./render-helpers/resolve-filter'</span></div><div class="line"><span class="keyword">import</span> &#123; checkKeyCodes &#125; <span class="keyword">from</span> <span class="string">'./render-helpers/check-keycodes'</span></div><div class="line"><span class="keyword">import</span> &#123; bindObjectProps &#125; <span class="keyword">from</span> <span class="string">'./render-helpers/bind-object-props'</span></div><div class="line"><span class="keyword">import</span> &#123; renderStatic, markOnce &#125; <span class="keyword">from</span> <span class="string">'./render-helpers/render-static'</span></div><div class="line"><span class="keyword">import</span> &#123; resolveSlots, resolveScopedSlots &#125; <span class="keyword">from</span> <span class="string">'./render-helpers/resolve-slots'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</div><div class="line">  <span class="comment">// $vnode对应的是虚拟组件的vnode</span></div><div class="line">  vm.$vnode = <span class="literal">null</span> <span class="comment">// the placeholder node in parent tree</span></div><div class="line">  <span class="comment">// _vnode对应的是真是dom节点的vnode</span></div><div class="line">  vm._vnode = <span class="literal">null</span> <span class="comment">// the root of the child tree</span></div><div class="line">  <span class="comment">// 用来存储渲染静态子树函数的列表</span></div><div class="line">  vm._staticTrees = <span class="literal">null</span></div><div class="line">  <span class="keyword">const</span> parentVnode = vm.$options._parentVnode</div><div class="line">  <span class="keyword">const</span> renderContext = parentVnode &amp;&amp; parentVnode.context</div><div class="line">  <span class="comment">// resolveSlots可以用来收集所有的slot标签，_renderChildren是子节点列表</span></div><div class="line">  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext)</div><div class="line">  <span class="comment">// 2.1新增特性，可以给slot指定执行的作用域</span></div><div class="line">  vm.$scopedSlots = emptyObject</div><div class="line">  <span class="comment">// _c和$createElement都是对createElement的封装，相当于bind</span></div><div class="line">  <span class="comment">// 不同的是_c是内部使用的，createElement对应了render函数里的createElement方法</span></div><div class="line">  <span class="comment">// 所以createElement使用的是标准模式，_c使用的是简略模式</span></div><div class="line">  <span class="comment">// bind the createElement fn to this instance</span></div><div class="line">  <span class="comment">// so that we get proper render context inside it.</span></div><div class="line">  <span class="comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span></div><div class="line">  <span class="comment">// internal version is used by render functions compiled from templates</span></div><div class="line">  vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</div><div class="line">  <span class="comment">// normalization is always applied for the public version, used in</span></div><div class="line">  <span class="comment">// user-written render functions.</span></div><div class="line">  vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</div><div class="line">  <span class="comment">// </span></div><div class="line">  Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn: Function</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> nextTick(fn, <span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 用来生成vnode的函数</span></div><div class="line">  Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">    <span class="keyword">const</span> &#123;</div><div class="line">      render,</div><div class="line">      <span class="comment">// 这个staticRenderFns是在解析模板时自动生成的</span></div><div class="line">      staticRenderFns,</div><div class="line">      _parentVnode</div><div class="line">    &#125; = vm.$options</div><div class="line"></div><div class="line">    <span class="comment">// 如果节点已经安装过，则直接把slot复制出来，应该也是为了效率提升吧</span></div><div class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</div><div class="line">      <span class="comment">// clone slot nodes on re-renders</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vm.$slots) &#123;</div><div class="line">        vm.$slots[key] = cloneVNodes(vm.$slots[key])</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 生成scopedSlots</span></div><div class="line">    vm.$scopedSlots = (_parentVnode &amp;&amp; _parentVnode.data.scopedSlots) || emptyObject</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (staticRenderFns &amp;&amp; !vm._staticTrees) &#123;</div><div class="line">      vm._staticTrees = []</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// set parent vnode. this allows render functions to have access</span></div><div class="line">    <span class="comment">// to the data on the placeholder node.</span></div><div class="line">    vm.$vnode = _parentVnode</div><div class="line">    <span class="comment">// render self</span></div><div class="line">    <span class="comment">// vnode对应了组件下的真实元素的vnode</span></div><div class="line">    <span class="keyword">let</span> vnode</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      vnode = render.call(vm._renderProxy, vm.$createElement)</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      handleError(e, vm, <span class="string">`render function`</span>)</div><div class="line">      <span class="comment">// return error render result,</span></div><div class="line">      <span class="comment">// or previous vnode to prevent render error causing blank component</span></div><div class="line">      <span class="comment">/* istanbul ignore else */</span></div><div class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">        <span class="comment">// renderError是渲染失败时的错误回调</span></div><div class="line">        vnode = vm.$options.renderError</div><div class="line">          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</div><div class="line">          : vm._vnode</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        vnode = vm._vnode</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果渲染出错就返回空节点</span></div><div class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></div><div class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;</div><div class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</div><div class="line">        warn(</div><div class="line">          <span class="string">'Multiple root nodes returned from render function. Render function '</span> +</div><div class="line">          <span class="string">'should return a single root node.'</span>,</div><div class="line">          vm</div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">      vnode = createEmptyVNode()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置当前vnode的parent</span></div><div class="line">    <span class="comment">// set parent</span></div><div class="line">    vnode.parent = _parentVnode</div><div class="line">    <span class="keyword">return</span> vnode</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 这些方法都是给vue ast解析出来的模板函数用的，对应的转换函数</span></div><div class="line">  <span class="comment">// internal render helpers.</span></div><div class="line">  <span class="comment">// these are exposed on the instance prototype to reduce generated render</span></div><div class="line">  <span class="comment">// code size.</span></div><div class="line">  Vue.prototype._o = markOnce</div><div class="line">  Vue.prototype._n = toNumber</div><div class="line">  Vue.prototype._s = _toString</div><div class="line">  Vue.prototype._l = renderList</div><div class="line">  Vue.prototype._t = renderSlot</div><div class="line">  Vue.prototype._q = looseEqual</div><div class="line">  Vue.prototype._i = looseIndexOf</div><div class="line">  Vue.prototype._m = renderStatic</div><div class="line">  Vue.prototype._f = resolveFilter</div><div class="line">  Vue.prototype._k = checkKeyCodes</div><div class="line">  Vue.prototype._b = bindObjectProps</div><div class="line">  Vue.prototype._v = createTextVNode</div><div class="line">  Vue.prototype._e = createEmptyVNode</div><div class="line">  Vue.prototype._u = resolveScopedSlots</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看完render大概就能理解之前看lifecycle不理解的地方了。vue里面vm和vnode并不是一一对应的。比如有个自定义的组件<my-component>，那么my-component对应一个vnode，然后<my-component>的render里面的第一个子节点（render要求模板必须有一个根节点）有对应一个自己的vnode，而vm描述的是当前组件的状态，所以会绑定在my-component模板里的第一个子节点上。其实也很好理解，生成my-component的vnode是在父组件的render中生成的，当时还没实例化vm呢，所以才只能在渲染子组件的时候再在vm上绑定parentVnode和当前节点的vnode……总之之前弄不清楚_vnode和$vnode的关系，现在算是搞明白了。</my-component></my-component></p>
<p>好的那么由于时间不足，本期的博客就写到这里了，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的力度了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次看了事件部分的代码，这次准备看 render 的代码&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>微信的一道面试题 -- LazyMan</title>
    <link href="http://brooch.me/2017/09/01/lazy-man/"/>
    <id>http://brooch.me/2017/09/01/lazy-man/</id>
    <published>2017-09-01T06:31:43.000Z</published>
    <updated>2017-09-01T14:03:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到标题就应该知道，没错，我又来水了~怎么样？来打我呀打我呀打我呀~噗噗噗噗~</p>
<a id="more"></a>
<p>话说前两天在知乎上看到篇文章<a href="https://zhuanlan.zhihu.com/p/28892523" target="_blank" rel="external">【周二放送】LazyMan 面试题详解</a>。</p>
<p>具体题目如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">实现一个LazyMan，可以按照以下方式调用:</div><div class="line">LazyMan(&quot;Hank&quot;)输出:</div><div class="line">Hi! This is Hank!</div><div class="line"></div><div class="line">LazyMan(&quot;Hank&quot;).sleep(10).eat(&quot;dinner&quot;)输出</div><div class="line">Hi! This is Hank!</div><div class="line">//等待10秒..</div><div class="line">Wake up after 10</div><div class="line">Eat dinner~</div><div class="line"></div><div class="line">LazyMan(&quot;Hank&quot;).eat(&quot;dinner&quot;).eat(&quot;supper&quot;)输出</div><div class="line">Hi This is Hank!</div><div class="line">Eat dinner~</div><div class="line">Eat supper~</div><div class="line"></div><div class="line">LazyMan(&quot;Hank&quot;).sleepFirst(5).eat(&quot;supper&quot;)输出</div><div class="line">//等待5秒</div><div class="line">Wake up after 5</div><div class="line">Hi This is Hank!</div><div class="line">Eat supper</div><div class="line"></div><div class="line">以此类推。</div></pre></td></tr></table></figure>
<p>其实里面是有视频详细解读的，但是我没看……</p>
<p>所以我就直接说我看到题目时的思考过程吧：</p>
<ol>
<li>LazyMan的调用不需要实例化，如果想只用一个函数定义LazyMan的话，其内部应该有个够生成实例类，LazyMan返回的就是这个类的实例，以便支持后续方法的调用。</li>
<li>后续的方法是链式调用的，所以每个方法都得现在原型链上，并且返回this。</li>
<li>需求里要求支持sleep操作，因为js里面没有类似的原生api，所以得使setTimeout来实现，也就是异步操作了。</li>
<li>说到异步队列，自然而然就想到了promise，但是由于sleepFirst需要在整个链之前加入暂停操作，用promise不太好实现，逻辑会有些绕。</li>
<li>比较稳妥的方案是自己实现个任务队列，和任务队列的自动执行机制。</li>
<li>还需要两个函数，负责将任务插入到队列的最前面和最后面。</li>
</ol>
<p>好的，分析完了基本上实现的框架就有了，下面是我写的答案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LazyMan</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="comment">// 这个是用来实现LazyMan功能的类</span></div><div class="line">  <span class="comment">// 直接放在这里完全是为了只用一个函数就实现LazyMan的功能</span></div><div class="line">  <span class="comment">// 要想省资源，还是应该放在外面独立定义的</span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">      <span class="comment">// 由于LazyMan执行后肯定会有一个输出</span></div><div class="line">      <span class="comment">// 所以初始化任务队列时就加入一个固定动作</span></div><div class="line">      <span class="keyword">this</span>._actionlist = [<span class="function">(<span class="params">next</span>) =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`Hi! This is <span class="subst">$&#123;name&#125;</span>!`</span>);</div><div class="line">        next();</div><div class="line">      &#125;];</div><div class="line">      <span class="comment">// 这里用Promise.resolve().then(fn)也可以</span></div><div class="line">      <span class="comment">// 但是兼容性没setTimeout好</span></div><div class="line">      setTimeout(<span class="keyword">this</span>._run.bind(<span class="keyword">this</span>), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    sleepFirst(time) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._first(<span class="keyword">this</span>._sleep(time));</div><div class="line">    &#125;</div><div class="line">    eat(food) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._next(<span class="function">(<span class="params">next</span>) =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`Eat <span class="subst">$&#123;food&#125;</span>~`</span>);</div><div class="line">        next();</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">    sleep(time) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._next(<span class="keyword">this</span>._sleep(time));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 生成暂停功能的函数工厂</span></div><div class="line">    <span class="comment">// 主要是为了降低代码重复率</span></div><div class="line">    _sleep(time)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">next</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          <span class="built_in">console</span>.log(<span class="string">`Wake up after <span class="subst">$&#123;time&#125;</span>`</span>);</div><div class="line">          next();</div><div class="line">        &#125;, time * <span class="number">1000</span>);</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// _next和_first用来向队列中加入任务</span></div><div class="line">    <span class="comment">// 也可以考虑用concat替换unshift和push</span></div><div class="line">    <span class="comment">// 因为ie6和ie7里unshift有bug……</span></div><div class="line">    _next(fn) &#123;</div><div class="line">      <span class="keyword">if</span> (fn &amp;&amp; <span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="keyword">this</span>._actionlist.push(fn);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    _first(fn) &#123;</div><div class="line">      <span class="keyword">if</span> (fn &amp;&amp; <span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="keyword">this</span>._actionlist.unshift(fn);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 执行队列的方法，里面递归调用，让队列能自动执行</span></div><div class="line">    <span class="comment">// 最早的时候是把_next和_run的功能写在一起的</span></div><div class="line">    <span class="comment">// 但是考虑到以后可能要扩展执行队列时传入上一个任务的结果的功能</span></div><div class="line">    <span class="comment">// 拆成独立函数更好实现</span></div><div class="line">    _run() &#123;</div><div class="line">      <span class="keyword">const</span> &#123; <span class="attr">_actionlist</span>: actionlist, _run &#125; = <span class="keyword">this</span>;</div><div class="line">      <span class="keyword">if</span> (actionlist.length) &#123;</div><div class="line">        actionlist.shift()(_run.bind(<span class="keyword">this</span>));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Lazy(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'start:'</span>);</div><div class="line">LazyMan(<span class="string">"Hank"</span>).eat(<span class="string">'cake'</span>).sleepFirst(<span class="number">3</span>).sleep(<span class="number">5</span>).eat(<span class="string">"dinner"</span>).sleep(<span class="number">3</span>).eat(<span class="string">'super'</span>);</div></pre></td></tr></table></figure>
<p>可以在jsbin上开到执行的效果，<a href="http://jsbin.com/lonunab/edit?js,console" target="_blank" rel="external">jsbin: lonunab</a></p>
<p>刚才说到用 Promise 也能实现，但是逻辑有些别扭，主要的坑有： </p>
<ol>
<li>使用 Promise 的话，要在LazyMan实例上留个属性，保存一个 promise 实例。但是在其他方法中想继续给这个 promise 实例添加后续的方法，不能直接调用then方法，而是要调用then方法之后，对内部保存实例的属性进行重新赋值。</li>
<li>要在向队列前面插入异步操作，单独为sleepFirst写个还行，要想要扩展更多的类似功能的函数就费劲了……</li>
</ol>
<p>以下是使用 Promise 实现的相同功能，可以对比参考一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LazyMan</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">      <span class="keyword">this</span>.sleepFirstTime = <span class="number">0</span>;</div><div class="line">      <span class="keyword">this</span>.promise = <span class="built_in">Promise</span>.resolve().then(</div><div class="line">        <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.sleepFirstTime &amp;&amp; <span class="keyword">this</span>._sleep(<span class="keyword">this</span>.sleepFirstTime)</div><div class="line">      ).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`Hi! This is <span class="subst">$&#123;name&#125;</span>!`</span>);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">    sleepFirst(time) &#123;</div><div class="line">      <span class="keyword">this</span>.sleepFirstTime = time;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    eat(food) &#123;</div><div class="line">      <span class="keyword">this</span>.promise = <span class="keyword">this</span>.promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`Eat <span class="subst">$&#123;food&#125;</span>~`</span>);</div><div class="line">      &#125;);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    sleep(time) &#123;</div><div class="line">      <span class="keyword">this</span>.promise = <span class="keyword">this</span>.promise.then(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span>._sleep(time));</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    _sleep(time)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">next</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          <span class="built_in">console</span>.log(<span class="string">`Wake up after <span class="subst">$&#123;time&#125;</span>`</span>);</div><div class="line">          next();</div><div class="line">        &#125;, time * <span class="number">1000</span>);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Lazy(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'start:'</span>);</div><div class="line">LazyMan(<span class="string">"Hank"</span>).eat(<span class="string">'cake'</span>).sleepFirst(<span class="number">3</span>).sleep(<span class="number">5</span>).eat(<span class="string">"dinner"</span>).sleep(<span class="number">3</span>).eat(<span class="string">'supper'</span>);</div></pre></td></tr></table></figure></p>
<p><a href="http://jsbin.com/tuyacoc/edit?js,console" target="_blank" rel="external">js bin: tuyacoc</a></p>
<p>其实整个程序还是有优化空间的，比如替换 promise 属性的逻辑可以再抽一个函数；还有在队列前插入任务的逻辑，用另一个新的 promise 实例来替代等等，因为晚上去团建了而且还喝了点儿酒，实在是懒得写了，有兴趣的同学可以试试，让用 Promise 实现的逻辑也简单优雅起来~</p>
<p>好的那么由于时间不足，本期的博客就写到这里了，为啥这次更新的内容这么少？因为光一个updateListeners我就看了一上午……(T_T)……如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的力度了~!</p>
<p>最后附上一张今天团建的照片，其实我跟人是很英俊的，拍成这样完全是因为他们丫黑我……(T_T)</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/memememememememe.jpeg" alt="memememememememe"></p>
<p>祝各位晚安&amp;周末愉快了~白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到标题就应该知道，没错，我又来水了~怎么样？来打我呀打我呀打我呀~噗噗噗噗~&lt;/p&gt;
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(8)</title>
    <link href="http://brooch.me/2017/08/25/vue-source-notes-8/"/>
    <id>http://brooch.me/2017/08/25/vue-source-notes-8/</id>
    <published>2017-08-25T10:47:14.000Z</published>
    <updated>2017-08-25T10:11:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次看了生命周期部分的代码，这次准备看 event 的代码</p>
<a id="more"></a>
<h1 id="Vue构造函数和vue实例-instance"><a href="#Vue构造函数和vue实例-instance" class="headerlink" title="Vue构造函数和vue实例 instance"></a>Vue构造函数和vue实例 instance</h1><h2 id="events-js"><a href="#events-js" class="headerlink" title="events.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/instance/events.js" target="_blank" rel="external">events.js</a></h2><p>之前说过，实例这部分的文件里，一般包括两部分，一部分用在实例init的过程，一部分用在定义Vue构造函数的mixin。events.js 也是，所以废话不多说，咱们开始。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @flow */</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"><span class="keyword">import</span> &#123; updateListeners &#125; <span class="keyword">from</span> <span class="string">'../vdom/helpers/index'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initEvents</span> (<span class="params">vm: Component</span>) </span>&#123;</div><div class="line">  <span class="comment">// 这个属性是用来记录当前实例注册过的事件的</span></div><div class="line">  vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">  <span class="comment">// hook event应该是系统事件</span></div><div class="line">  vm._hasHookEvent = <span class="literal">false</span></div><div class="line">  <span class="comment">// init parent attached events</span></div><div class="line">  <span class="comment">// _parentListeners其实是父组件模板中写的v-on</span></div><div class="line">  <span class="comment">// 所以下面这段就是将父组件模板中注册的事件放到当前组件实例的listeners里面</span></div><div class="line">  <span class="keyword">const</span> listeners = vm.$options._parentListeners</div><div class="line">  <span class="keyword">if</span> (listeners) &#123;</div><div class="line">    updateComponentListeners(vm, listeners)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 用来存当前vm实例的临时变量</span></div><div class="line"><span class="keyword">let</span> target: Component</div><div class="line"><span class="comment">// 添加删除事件的方法，专门给updateComponentListeners用的</span></div><div class="line"><span class="comment">// 特意定义在外面可能是为了省内存吧？要是我就直接写匿名方法了……</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">event, fn, once</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (once) &#123;</div><div class="line">    target.$once(event, fn)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    target.$on(event, fn)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">event, fn</span>) </span>&#123;</div><div class="line">  target.$off(event, fn)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这个方法感觉是个过渡方法，用来让add和remove能够调用到vm实例用的</span></div><div class="line"><span class="comment">// 真正绑定事件updateListeners，</span></div><div class="line"><span class="comment">// 顺便一提的是，listeners里面的方法都已经用bind包装过了，所以不存在指向对象不对的情况</span></div><div class="line"><span class="comment">// 具体包装的时机我找了半天死活没找到，现在可以确定的是，在render函数生成的时候，就已经包装好了</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateComponentListeners</span> (<span class="params"></span></span></div><div class="line">  vm: Component,</div><div class="line">  listeners: Object,</div><div class="line">  oldListeners: ?Object</div><div class="line">) &#123;</div><div class="line">  target = vm</div><div class="line">  updateListeners(listeners, oldListeners || &#123;&#125;, add, remove, vm)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 往构造函数原型链上挂载用来注册的方法</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">eventsMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> hookRE = <span class="regexp">/^hook:/</span></div><div class="line">  <span class="comment">// 常规的事件回调队列，每个事件对一个数组</span></div><div class="line">  Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event: string | Array&lt;string&gt;, fn: Function</span>): <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</div><div class="line">        <span class="keyword">this</span>.$on(event[i], fn)</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      (vm._events[event] || (vm._events[event] = [])).push(fn)</div><div class="line">      <span class="comment">// optimize hook:event cost by using a boolean flag marked at registration</span></div><div class="line">      <span class="comment">// instead of a hash lookup</span></div><div class="line">      <span class="comment">// 这里标记为true之后每次update的时候就会用emit发出hook的消息</span></div><div class="line">      <span class="keyword">if</span> (hookRE.test(event)) &#123;</div><div class="line">        vm._hasHookEvent = <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> vm</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 在on上包装了一层，执行一次就off了</span></div><div class="line">  Vue.prototype.$once = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">on</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      vm.$off(event, on)</div><div class="line">      fn.apply(vm, <span class="built_in">arguments</span>)</div><div class="line">    &#125;</div><div class="line">    on.fn = fn</div><div class="line">    vm.$on(event, on)</div><div class="line">    <span class="keyword">return</span> vm</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 删除事件对应回调用的</span></div><div class="line">  Vue.prototype.$off = <span class="function"><span class="keyword">function</span> (<span class="params">event?: string, fn?: Function</span>): <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">    <span class="comment">// all</span></div><div class="line">    <span class="comment">// 不传参数就全删了</span></div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</div><div class="line">      vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">      <span class="keyword">return</span> vm</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// specific event</span></div><div class="line">    <span class="comment">// 删除指定事件的回调队列</span></div><div class="line">    <span class="keyword">const</span> cbs = vm._events[event]</div><div class="line">    <span class="keyword">if</span> (!cbs) &#123;</div><div class="line">      <span class="keyword">return</span> vm</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</div><div class="line">      vm._events[event] = <span class="literal">null</span></div><div class="line">      <span class="keyword">return</span> vm</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// specific handler</span></div><div class="line">    <span class="comment">// 删除指定的回调</span></div><div class="line">    <span class="keyword">let</span> cb</div><div class="line">    <span class="keyword">let</span> i = cbs.length</div><div class="line">    <span class="keyword">while</span> (i--) &#123;</div><div class="line">      cb = cbs[i]</div><div class="line">      <span class="comment">// 之前说过回调队列中的函数(就是cb)都用bind包装过了</span></div><div class="line">      <span class="comment">// 目测cb.fn就是原始的函数，所以用来比较了</span></div><div class="line">      <span class="keyword">if</span> (cb === fn || cb.fn === fn) &#123;</div><div class="line">        cbs.splice(i, <span class="number">1</span>)</div><div class="line">        <span class="keyword">break</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> vm</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 触发对应事件的函数队列</span></div><div class="line">  Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">    <span class="keyword">let</span> cbs = vm._events[event]</div><div class="line">    <span class="keyword">if</span> (cbs) &#123;</div><div class="line">      cbs = cbs.length &gt; <span class="number">1</span> ? toArray(cbs) : cbs</div><div class="line">      <span class="comment">// 去掉参数列表的第一个，其他的都作为cb的参数，转成数组</span></div><div class="line">      <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = cbs.length; i &lt; l; i++) &#123;</div><div class="line">        cbs[i].apply(vm, args)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> vm</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好的那么由于时间不足，本期的博客就写到这里了，为啥这次更新的内容这么少？因为光一个updateListeners我就看了一上午……(T_T)……如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的力度了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次看了生命周期部分的代码，这次准备看 event 的代码&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(7)</title>
    <link href="http://brooch.me/2017/08/04/vue-source-notes-7/"/>
    <id>http://brooch.me/2017/08/04/vue-source-notes-7/</id>
    <published>2017-08-04T10:50:44.000Z</published>
    <updated>2017-08-04T14:07:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>书接上文，话说我自己都不记得上文是啥了……嗯，总之接着读吧。</p>
<a id="more"></a>
<h1 id="Vue构造函数和vue实例-instance"><a href="#Vue构造函数和vue实例-instance" class="headerlink" title="Vue构造函数和vue实例 instance"></a>Vue构造函数和vue实例 instance</h1><p>上次看到Vue构造函数和vue实例的模块，整个模块的入口 index.js ，还看了 init.js ，今天我才发现，原来除了入口 index.js ，模块中其他文件其实都是分为了 mixin 和 init 两部分，mixin的部分是为了给Vue构造函数原型链上挂方法的，init部分是给实例init的过程中调用，给实例附加属性的，其实都是给实例服务的，所以把两部分混合在一起因为这个吧……╮(￣▽￣)╭……后续再按文件阅读的时候，我会对这单独注明。</p>
<h2 id="lifecycle-js"><a href="#lifecycle-js" class="headerlink" title="lifecycle.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/instance/lifecycle.js" target="_blank" rel="external">lifecycle.js</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @flow */</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; perf &#125; <span class="keyword">from</span> <span class="string">'../util/perf'</span></div><div class="line"><span class="keyword">import</span> Watcher <span class="keyword">from</span> <span class="string">'../observer/watcher'</span></div><div class="line"><span class="keyword">import</span> &#123; createEmptyVNode &#125; <span class="keyword">from</span> <span class="string">'../vdom/vnode'</span></div><div class="line"><span class="keyword">import</span> &#123; observerState &#125; <span class="keyword">from</span> <span class="string">'../observer/index'</span></div><div class="line"><span class="keyword">import</span> &#123; updateComponentListeners &#125; <span class="keyword">from</span> <span class="string">'./events'</span></div><div class="line"><span class="keyword">import</span> &#123; resolveSlots &#125; <span class="keyword">from</span> <span class="string">'./render-helpers/resolve-slots'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  warn,</div><div class="line">  noop,</div><div class="line">  remove,</div><div class="line">  handleError,</div><div class="line">  emptyObject,</div><div class="line">  validateProp</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="comment">// 用来保存当前活动节点，其他模块中会用到</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> activeInstance: any = <span class="literal">null</span></div><div class="line"></div><div class="line"><span class="comment">// 实例init部分</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initLifecycle</span> (<span class="params">vm: Component</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> options = vm.$options</div><div class="line"></div><div class="line">  <span class="comment">// locate first non-abstract parent</span></div><div class="line">  <span class="comment">// 下面这段逻辑是为了找到距离当前组件最近的非抽象组件，话说也不知道我翻译的对不对</span></div><div class="line">  <span class="comment">// 啥叫抽象组件？在vue文档里找到的解释是，它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</span></div><div class="line">  <span class="comment">// 具体的实现方法是在options里面加一个属性abstract，但是这个属性，文档中没有记载</span></div><div class="line">  <span class="comment">// 比如keep-alive和transition，就是都是抽象组件。</span></div><div class="line">  <span class="comment">// 所以这段逻辑是用来将抽象组件从组件链中的去除用的</span></div><div class="line">  <span class="keyword">let</span> parent = options.parent</div><div class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</div><div class="line">    <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</div><div class="line">      parent = parent.$parent</div><div class="line">    &#125;</div><div class="line">    parent.$children.push(vm)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置父组件</span></div><div class="line">  <span class="comment">// https://cn.vuejs.org/v2/api/#vm-parent</span></div><div class="line">  vm.$parent = parent</div><div class="line">  <span class="comment">// 设置根组件</span></div><div class="line">  <span class="comment">// https://cn.vuejs.org/v2/api/#vm-root</span></div><div class="line">  vm.$root = parent ? parent.$root : vm</div><div class="line">  <span class="comment">// 设置子组件</span></div><div class="line">  <span class="comment">// https://cn.vuejs.org/v2/api/#vm-children</span></div><div class="line">  vm.$children = []</div><div class="line">  <span class="comment">// 设置引用</span></div><div class="line">  <span class="comment">// https://cn.vuejs.org/v2/api/#vm-refs</span></div><div class="line">  vm.$refs = &#123;&#125;</div><div class="line">  <span class="comment">// 下面都是内部属性</span></div><div class="line">  <span class="comment">// 这是貌似是当前组件的观察者，触发watch做的</span></div><div class="line">  vm._watcher = <span class="literal">null</span></div><div class="line">  <span class="comment">// 用来标记组件是否停用的貌似，用来配合keep-live组件用的</span></div><div class="line">  vm._inactive = <span class="literal">null</span></div><div class="line">  <span class="comment">// 字面上翻译是直接停用，用来配合keep-live组件用的</span></div><div class="line">  vm._directInactive = <span class="literal">false</span></div><div class="line">  <span class="comment">// 用来标记组件是否已渲染</span></div><div class="line">  vm._isMounted = <span class="literal">false</span></div><div class="line">  <span class="comment">// 用来标记组件是否已销毁</span></div><div class="line">  vm._isDestroyed = <span class="literal">false</span></div><div class="line">  <span class="comment">// 用来标记组件是否正在被销毁，为了防止组件被重复销毁</span></div><div class="line">  vm._isBeingDestroyed = <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 构造函数mixin部分</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lifecycleMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</div><div class="line">  <span class="comment">// 内部方法，文档中没写，实例的数据更新方法</span></div><div class="line">  <span class="comment">// hydrating这个属性我查了好久，字面上是水合作用的意思</span></div><div class="line">  <span class="comment">// 我就奇了怪了，读个代码咋还跟化学扯上关系了……</span></div><div class="line">  <span class="comment">// 读了半天感觉像是让dom和虚拟dom融合的，也不知道对不对……</span></div><div class="line">  Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">    <span class="comment">// 利用刚才的标记执行钩子函数</span></div><div class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</div><div class="line">      callHook(vm, <span class="string">'beforeUpdate'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> prevEl = vm.$el</div><div class="line">    <span class="keyword">const</span> prevVnode = vm._vnode</div><div class="line">    <span class="keyword">const</span> prevActiveInstance = activeInstance</div><div class="line">    <span class="comment">// 标记当前的活动节点</span></div><div class="line">    activeInstance = vm</div><div class="line">    vm._vnode = vnode</div><div class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></div><div class="line">    <span class="comment">// based on the rendering backend used.</span></div><div class="line">    <span class="comment">// 上面这段说 __patch__ 是后端渲染注入的入口？没懂啥意思</span></div><div class="line">    <span class="comment">// 总之__path__其实就是补丁算法</span></div><div class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</div><div class="line">      <span class="comment">// initial render</span></div><div class="line">      <span class="comment">// 如果没有prevVnode，那就初始化渲染，其实就是创建真实的dom节点</span></div><div class="line">      vm.$el = vm.__patch__(</div><div class="line">        vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>,</div><div class="line">        vm.$options._parentElm,</div><div class="line">        vm.$options._refElm</div><div class="line">      )</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// updates</span></div><div class="line">      <span class="comment">// 如果有prevVnode，就更新</span></div><div class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新完了，把活动节点还回去</span></div><div class="line">    activeInstance = prevActiveInstance</div><div class="line">    <span class="comment">// update __vue__ reference</span></div><div class="line">    <span class="comment">// 更新vue引用，原来还是会在dom上绑定数据呀</span></div><div class="line">    <span class="comment">// 不过这个数据貌似在实际中并没有用到呢</span></div><div class="line">    <span class="comment">// 对于调试还挺有意义，在dom节点上能找到对应的vue对象</span></div><div class="line">    <span class="keyword">if</span> (prevEl) &#123;</div><div class="line">      prevEl.__vue__ = <span class="literal">null</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (vm.$el) &#123;</div><div class="line">      vm.$el.__vue__ = vm</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></div><div class="line">    <span class="comment">// 如果parent是个高阶组件，直接更新他的$el属性</span></div><div class="line">    <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</div><div class="line">      vm.$parent.$el = vm.$el</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></div><div class="line">    <span class="comment">// updated in a parent's updated hook.</span></div><div class="line">    <span class="comment">// 上面这段貌似是说，这个函数里没有调用update的钩子函数，是因为有统一的调度程序</span></div><div class="line">    <span class="comment">// 这样能确保子组件都更新了，貌似吧</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 强制重新渲染方法</span></div><div class="line">  <span class="comment">// https://cn.vuejs.org/v2/api/#vm-forceUpdate</span></div><div class="line">  Vue.prototype.$forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">    <span class="comment">// 居然是直接用watcher来更新……</span></div><div class="line">    <span class="keyword">if</span> (vm._watcher) &#123;</div><div class="line">      vm._watcher.update()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 销毁方法</span></div><div class="line">  <span class="comment">// https://cn.vuejs.org/v2/api/#vm-destroy</span></div><div class="line">  Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">    <span class="comment">// 利用标记判断是否已经开始销毁</span></div><div class="line">    <span class="keyword">if</span> (vm._isBeingDestroyed) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 钩子调完了就算开始销毁了</span></div><div class="line">    callHook(vm, <span class="string">'beforeDestroy'</span>)</div><div class="line">    vm._isBeingDestroyed = <span class="literal">true</span></div><div class="line">    <span class="comment">// remove self from parent</span></div><div class="line">    <span class="comment">// 先把自己从组件链中删除</span></div><div class="line">    <span class="keyword">const</span> parent = vm.$parent</div><div class="line">    <span class="keyword">if</span> (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123;</div><div class="line">      remove(parent.$children, vm)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// teardown watchers</span></div><div class="line">    <span class="comment">// 然后把watcher停了</span></div><div class="line">    <span class="keyword">if</span> (vm._watcher) &#123;</div><div class="line">      vm._watcher.teardown()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 清除_watchers队列，貌似和_watcher还不是一回事儿，</span></div><div class="line">    <span class="comment">// _watcher是用来更新自己的，_watchers是用来记录计算属性的</span></div><div class="line">    <span class="keyword">let</span> i = vm._watchers.length</div><div class="line">    <span class="keyword">while</span> (i--) &#123;</div><div class="line">      vm._watchers[i].teardown()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// remove reference from data ob</span></div><div class="line">    <span class="comment">// frozen object may not have observer.</span></div><div class="line">    <span class="comment">// 删除绑定对象的引用</span></div><div class="line">    <span class="keyword">if</span> (vm._data.__ob__) &#123;</div><div class="line">      vm._data.__ob__.vmCount--</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// call the last hook...</span></div><div class="line">    <span class="comment">// 到这儿就算销毁完了</span></div><div class="line">    vm._isDestroyed = <span class="literal">true</span></div><div class="line">    callHook(vm, <span class="string">'destroyed'</span>)</div><div class="line">    <span class="comment">// turn off all instance listeners.</span></div><div class="line">    <span class="comment">// 最后注销所有的事件</span></div><div class="line">    vm.$off()</div><div class="line">    <span class="comment">// remove __vue__ reference</span></div><div class="line">    <span class="comment">// 把自己的引用删了</span></div><div class="line">    <span class="keyword">if</span> (vm.$el) &#123;</div><div class="line">      vm.$el.__vue__ = <span class="literal">null</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// invoke destroy hooks on current rendered tree</span></div><div class="line">    <span class="comment">// 最后把节点删了</span></div><div class="line">    vm.__patch__(vm._vnode, <span class="literal">null</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 暴露的外部方法，对应vue.$mount</span></div><div class="line"><span class="comment">// 之所以没放mixin里面试因为要提供给不同入口</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></div><div class="line">  vm: Component,</div><div class="line">  el: ?Element,</div><div class="line">  hydrating?: boolean</div><div class="line">): <span class="title">Component</span> &#123;</div><div class="line">  vm.$el = el</div><div class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</div><div class="line">    vm.$options.render = createEmptyVNode</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">      <span class="comment">/* istanbul ignore if */</span></div><div class="line">      <span class="keyword">if</span> (vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">'#'</span>) &#123;</div><div class="line">        warn(</div><div class="line">          <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</div><div class="line">          <span class="string">'option is not available. Either pre-compile the templates into '</span> +</div><div class="line">          <span class="string">'render functions, or use the compiler-included build.'</span>,</div><div class="line">          vm</div><div class="line">        )</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        warn(</div><div class="line">          <span class="string">'Failed to mount component: template or render function not defined.'</span>,</div><div class="line">          vm</div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</div><div class="line"></div><div class="line">  <span class="keyword">let</span> updateComponent</div><div class="line">  <span class="comment">/* istanbul ignore if */</span></div><div class="line">  <span class="comment">// 定义更新节点的函数，如果是测试环境会记录性能</span></div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; perf) &#123;</div><div class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">const</span> name = vm._name</div><div class="line">      <span class="keyword">const</span> startTag = <span class="string">`start <span class="subst">$&#123;name&#125;</span>`</span></div><div class="line">      <span class="keyword">const</span> endTag = <span class="string">`end <span class="subst">$&#123;name&#125;</span>`</span></div><div class="line">      perf.mark(startTag)</div><div class="line">      <span class="keyword">const</span> vnode = vm._render()</div><div class="line">      perf.mark(endTag)</div><div class="line">      perf.measure(<span class="string">`<span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</div><div class="line">      perf.mark(startTag)</div><div class="line">      vm._update(vnode, hydrating)</div><div class="line">      perf.mark(endTag)</div><div class="line">      perf.measure(<span class="string">`<span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      vm._update(vm._render(), hydrating)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 这里给watcher赋值，可以看出是用watcher来执行update方法更新组件的</span></div><div class="line">  vm._watcher = <span class="keyword">new</span> Watcher(vm, updateComponent, noop)</div><div class="line">  <span class="comment">// watcher的响应函数一上来就会运行一次，是为了记录初始值，</span></div><div class="line">  <span class="comment">// 然后立马就把这个水合的开关给关上了……估计是后续的更新都不用他了</span></div><div class="line">  hydrating = <span class="literal">false</span></div><div class="line"></div><div class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></div><div class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></div><div class="line">  <span class="comment">// 上面说这里手动调用mounted的钩子是为了创建子组件？</span></div><div class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</div><div class="line">    vm._isMounted = <span class="literal">true</span></div><div class="line">    callHook(vm, <span class="string">'mounted'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> vm</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 更新子组件的方法，组件init的时候用的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateChildComponent</span> (<span class="params"></span></span></div><div class="line">  vm: Component,</div><div class="line">  propsData: ?Object,</div><div class="line">  listeners: ?Object,</div><div class="line">  parentVnode: VNode,</div><div class="line">  renderChildren: ?Array&lt;VNode&gt;</div><div class="line">) &#123;</div><div class="line">  <span class="comment">// determine whether component has slot children</span></div><div class="line">  <span class="comment">// we need to do this before overwriting $options._renderChildren</span></div><div class="line">  <span class="comment">// 这段是判断有没有slot的</span></div><div class="line">  <span class="keyword">const</span> hasChildren = !!(</div><div class="line">    renderChildren ||               <span class="comment">// has new static slots</span></div><div class="line">    vm.$options._renderChildren ||  <span class="comment">// has old static slots</span></div><div class="line">    parentVnode.data.scopedSlots || <span class="comment">// has new scoped slots</span></div><div class="line">    vm.$scopedSlots !== emptyObject <span class="comment">// has old scoped slots</span></div><div class="line">  )</div><div class="line">  <span class="comment">// </span></div><div class="line">  vm.$options._parentVnode = parentVnode</div><div class="line">  vm.$vnode = parentVnode <span class="comment">// update vm's placeholder node without re-render</span></div><div class="line">  <span class="keyword">if</span> (vm._vnode) &#123; <span class="comment">// update child tree's parent</span></div><div class="line">    vm._vnode.parent = parentVnode</div><div class="line">  &#125;</div><div class="line">  vm.$options._renderChildren = renderChildren</div><div class="line"></div><div class="line">  <span class="comment">// update props</span></div><div class="line">  <span class="comment">// 更新属性的逻辑</span></div><div class="line">  <span class="keyword">if</span> (propsData &amp;&amp; vm.$options.props) &#123;</div><div class="line">    <span class="comment">// 更新属性过程中先关闭监听</span></div><div class="line">    observerState.shouldConvert = <span class="literal">false</span></div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">      observerState.isSettingProps = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> props = vm._props</div><div class="line">    <span class="keyword">const</span> propKeys = vm.$options._propKeys || []</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; propKeys.length; i++) &#123;</div><div class="line">      <span class="keyword">const</span> key = propKeys[i]</div><div class="line">      props[key] = validateProp(key, vm.$options.props, propsData, vm)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 属性更新之后再打开</span></div><div class="line">    observerState.shouldConvert = <span class="literal">true</span></div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">      observerState.isSettingProps = <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// keep a copy of raw propsData</span></div><div class="line">    <span class="comment">// 把传进来的原始属性保存一份</span></div><div class="line">    vm.$options.propsData = propsData</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// update listeners</span></div><div class="line">  <span class="comment">// 更新事件监听</span></div><div class="line">  <span class="keyword">if</span> (listeners) &#123;</div><div class="line">    <span class="keyword">const</span> oldListeners = vm.$options._parentListeners</div><div class="line">    vm.$options._parentListeners = listeners</div><div class="line">    <span class="comment">// 这个是event.js里的方法，看到再说</span></div><div class="line">    updateComponentListeners(vm, listeners, oldListeners)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// resolve slots + force update if has children</span></div><div class="line">  <span class="comment">// 更新slots，然后强制更新</span></div><div class="line">  <span class="keyword">if</span> (hasChildren) &#123;</div><div class="line">    vm.$slots = resolveSlots(renderChildren, parentVnode.context)</div><div class="line">    vm.$forceUpdate()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 判断组件链是否激活</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInInactiveTree</span> (<span class="params">vm</span>) </span>&#123;</div><div class="line">  <span class="keyword">while</span> (vm &amp;&amp; (vm = vm.$parent)) &#123;</div><div class="line">    <span class="keyword">if</span> (vm._inactive) <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 激活组件的方法，貌似是给keep-alive用的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">activateChildComponent</span> (<span class="params">vm: Component, direct?: boolean</span>) </span>&#123;</div><div class="line">  <span class="comment">// direct貌似是用来表示是否是直接调用的</span></div><div class="line">  <span class="keyword">if</span> (direct) &#123;</div><div class="line">    vm._directInactive = <span class="literal">false</span></div><div class="line">    <span class="keyword">if</span> (isInInactiveTree(vm)) &#123;</div><div class="line">      <span class="comment">// 如果是直接调用并且组件树被激活过，就返回了</span></div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm._directInactive) &#123;</div><div class="line">    <span class="comment">// 如果不是直接调用但是已经停用了，也返回</span></div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (vm._inactive || vm._inactive == <span class="literal">null</span>) &#123;</div><div class="line">    vm._inactive = <span class="literal">false</span></div><div class="line">    <span class="comment">// 递归激活组件</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vm.$children.length; i++) &#123;</div><div class="line">      activateChildComponent(vm.$children[i])</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 触发钩子</span></div><div class="line">    callHook(vm, <span class="string">'activated'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 停用组件，逻辑与激活的类似</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deactivateChildComponent</span> (<span class="params">vm: Component, direct?: boolean</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (direct) &#123;</div><div class="line">    vm._directInactive = <span class="literal">true</span></div><div class="line">    <span class="keyword">if</span> (isInInactiveTree(vm)) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (!vm._inactive) &#123;</div><div class="line">    vm._inactive = <span class="literal">true</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vm.$children.length; i++) &#123;</div><div class="line">      deactivateChildComponent(vm.$children[i])</div><div class="line">    &#125;</div><div class="line">    callHook(vm, <span class="string">'deactivated'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用钩子函数的工具函数</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">callHook</span> (<span class="params">vm: Component, hook: string</span>) </span>&#123;</div><div class="line">  <span class="comment">// 先把钩子函数列表取出来</span></div><div class="line">  <span class="keyword">const</span> handlers = vm.$options[hook]</div><div class="line">  <span class="keyword">if</span> (handlers) &#123;</div><div class="line">    <span class="comment">// 然后挨个执行</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = handlers.length; i &lt; j; i++) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        handlers[i].call(vm)</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        handleError(e, vm, <span class="string">`<span class="subst">$&#123;hook&#125;</span> hook`</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (vm._hasHookEvent) &#123;</div><div class="line">    <span class="comment">// 最后发一个事件出来</span></div><div class="line">    vm.$emit(<span class="string">'hook:'</span> + hook)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>呼，终于看完了，这章节信息量还挺大的，一些常用的生命周期以及函数都有出现呢，总体感觉组件创建，销毁，更新的那部分逻辑其实可以作为标准逻辑来借鉴。</p>
<p>好的那么由于时间不足，本期的博客就写到这里了，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的力度了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书接上文，话说我自己都不记得上文是啥了……嗯，总之接着读吧。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>如何终止promise</title>
    <link href="http://brooch.me/2017/07/21/how-to-break-promise/"/>
    <id>http://brooch.me/2017/07/21/how-to-break-promise/</id>
    <published>2017-07-21T15:29:20.000Z</published>
    <updated>2017-07-22T10:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近在工作中遇到一个问题，在 promise 的链式调用中，涉及到一个类似 break 的操作。就是在某一个 then 函数的调用中，某种情况下，要取消后续的所有操作。于是调查了下 promise 的 api，想找到实现类似操作的方法。但是在后续的调查中，我发现 ———— promise 根本就没办法终止后续的操作……</p>
<a id="more"></a>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>promise 的设计，本质上是一个状态机。从初始状态，到有了结果的 reject/resolve 状态，整个过程的变化的单向的。所以，promise 根本没有所谓的取消状态。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>抛开 promise 设计上是否有缺陷不谈，那么使用 promise 时是否可以实现终止操作呢？其实通过 promise 本身的机制，配合一定编码规范，是可以实现的。</p>
<p>我们都知道 promise 的 then 方法可以接受两个函数，一个用来处理 reject，一个用来处理 resolve，如果一个 then 方法里面发生异常，就会执行下一个有 reject 处理函数的 then 里面的 reject 处理 函数，catch 只是 then(null, rejectHandler) 的一种封装而已。</p>
<p>比如下面这个例子，其中由于 p2 的那个 then 方法中没有 reject 处理函数，所以被跳过了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    resolve(<span class="string">'start'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">start()</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'resolve，result of start: '</span>, data);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">1</span>); <span class="comment">// p1</span></div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'resolve，result of p1: '</span>, data);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">2</span>); <span class="comment">// p2</span></div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'result of p2: '</span>, data);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>); <span class="comment">// p3</span></div><div class="line">  &#125;, data =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'reject, result of p1: '</span>, data);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">3</span>); <span class="comment">// p3</span></div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="params">ex</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ex: '</span>, ex);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">4</span>); <span class="comment">// p4</span></div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'result of p4: '</span>, data);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<p>所以，如果我们只向 then 方法中传入 resolve 处理函数，在 promise 调用链的最后加上 catch，把所有的错误处理都放在 catch 里面，想要 break 的时候抛出一个固定的错误，就能达到终止操作的效果了。</p>
<p>不过这样也一方面不好，就是在无法在 then 中做异常处理，所以需要对 then 和 catch 进行下封装，另外如果每次都要写抛出错误不太方便，我简单封装了一下，代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapThenRejectHandler</span>(<span class="params">rejectHandler</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">Error</span> &amp;&amp; e.message === <span class="string">'break'</span> || <span class="keyword">typeof</span> rejectHandler === <span class="string">'undefined'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(e);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> rejectHandler(e);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapCatchRejectHandler</span>(<span class="params">rejectHandler</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> <span class="built_in">Error</span> &amp;&amp; e.message === <span class="string">'break'</span>) &amp;&amp; rejectHandler) &#123;</div><div class="line">      rejectHandler(e);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Promise</span>, <span class="string">'break'</span>, &#123;</div><div class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'break'</span>);</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> oldThen = <span class="built_in">Promise</span>.prototype.then;</div><div class="line"><span class="keyword">let</span> oldCatch = <span class="built_in">Promise</span>.prototype.catch;</div><div class="line"></div><div class="line"><span class="built_in">Promise</span>.prototype._then = <span class="function"><span class="keyword">function</span> (<span class="params">resolveHandler, rejectHandler</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> oldThen.bind(<span class="keyword">this</span>)(resolveHandler, wrapThenRejectHandler(rejectHandler));</div><div class="line">&#125;;</div><div class="line"><span class="built_in">Promise</span>.prototype._catch = <span class="function"><span class="keyword">function</span> (<span class="params">rejectHandler</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> oldCatch.bind(<span class="keyword">this</span>)(wrapCatchRejectHandler(rejectHandler));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="string">'start'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">start()</div><div class="line">  ._then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</div><div class="line">  &#125;)</div><div class="line">  ._then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</div><div class="line">    <span class="built_in">Promise</span>.break;</div><div class="line">  &#125;)</div><div class="line">  ._then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'3,error'</span>)</div><div class="line">  &#125;)</div><div class="line">  ._catch(<span class="function"><span class="keyword">function</span> (<span class="params">ex</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ex: '</span>, ex);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>封装的过程中发现个问题，如果新的方法沿用then或者catch的名字，会造成死循环的情况，不知道为毛……</p>
<h2 id="题外话……"><a href="#题外话……" class="headerlink" title="题外话……"></a>题外话……</h2><p>有人评论说无法取消是 promise 的一个缺点。我倒是觉得 promise 自设计之初就不适合用来处理有取消状态的场景。因为取消状态的加入会让问题变得异常复杂。</p>
<p>举例来说，有个用户在电商系统上下单购买了一件商品（初始状态），在商家发货之前（resolve状态），因为没钱取消了订单（取消状态），取消订单需要审核（取消状态的resolve状态），审核期间用户发工资了又不想取消订单了，于是又点了【取消退订】（取消状态的取消状态），而【取消退订】也是异步的，你还能取消【取消退订】……如果要用 promise 实现这个逻辑，估计最后会死的很惨吧……</p>
<p>好的由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;最近在工作中遇到一个问题，在 promise 的链式调用中，涉及到一个类似 break 的操作。就是在某一个 then 函数的调用中，某种情况下，要取消后续的所有操作。于是调查了下 promise 的 api，想找到实现类似操作的方法。但是在后续的调查中，我发现 ———— promise 根本就没办法终止后续的操作……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="promise" scheme="http://brooch.me/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>一种实现弹窗组件的方法</title>
    <link href="http://brooch.me/2017/07/07/how-to-make-vue-dialog-component/"/>
    <id>http://brooch.me/2017/07/07/how-to-make-vue-dialog-component/</id>
    <published>2017-07-07T14:44:39.000Z</published>
    <updated>2017-12-20T07:06:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到标题就应该知道，我又来水了……话说最近真是太忙，以至于读源码的事情被无限期搁置了（其实还不是你懒）……咳咳……言归正传，因为要做了个移动的项目，团队成员又大多是新手，所以选了vue作为基础框架。这周的工作中顺手封装了一些常用的组件，在这里记录下自己的想法，省的之后忘了，哈哈……</p>
<a id="more"></a>
<p>说到组件，最常用的应该就是弹窗组件了，而我们在使用vue或者react等框架渲染界面的时候，一般都需要事先将组件实例显示的写在render函数里面，而且需要配合一个标记组件是否显示的变量一起使用。</p>
<p>以vue为例，一般平时我们使用组件一般写成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;!-- ... --&gt;</div><div class="line">    &lt;dialog v-show="showDialog1"&gt;msg1&lt;/dialog&gt;</div><div class="line">    &lt;!-- ... --&gt;</div><div class="line">    &lt;dialog v-show="showDialog2"&gt;msg2&lt;/dialog&gt;</div><div class="line">    &lt;!-- ... --&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    data() &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">showDialog1</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">showDialog2</span>: <span class="literal">false</span>,</div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p>有些组件这样使用没问题，但是有些组件，比如dialog组件，这样使用起来虽然也说不上不方便，但是与我们平时使用组件的习惯，还是有一定差异的。一般我们都是这样调用组件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">let</span> dialog1 = <span class="keyword">new</span> Dialog(<span class="string">'msg1'</span>);</div><div class="line"><span class="keyword">let</span> dialog2 = <span class="keyword">new</span> Dialog(<span class="string">'msg2'</span>);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    methods: &#123;</div><div class="line">        fn1() &#123;</div><div class="line">            dialog1.show();</div><div class="line">        &#125;,</div><div class="line">        fn2() &#123;</div><div class="line">            dialog1.close();</div><div class="line">            dialog2.show();</div><div class="line">        &#125;,</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p>那么这样的调用方式是否能实现呢？答案是肯定的。以vue为例，需要用到Vue.extend方法创建子类来实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 首先简单定义一个组件选项</span></div><div class="line"><span class="keyword">let</span> dialogOptions = &#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">'&lt;div v-show="show"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;'</span>,</div><div class="line">    <span class="attr">props</span>: &#123;</div><div class="line">      <span class="attr">msg</span>: <span class="built_in">String</span>,</div><div class="line">    &#125;,</div><div class="line">    data() &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">show</span>: <span class="literal">false</span>,</div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 然后创建组件的构造函数</span></div><div class="line"><span class="keyword">const</span> DialogConstructor = Vue.extend(dialogOptions);</div><div class="line">DialogConstructor.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.show = <span class="literal">true</span>;</div><div class="line">&#125;;</div><div class="line">DialogConstructor.prototype.close = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.show = <span class="literal">false</span>;</div><div class="line">    <span class="built_in">document</span>.body.removeChild(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="keyword">this</span>.$destroy();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 最后组织自己的调用方法</span></div><div class="line"><span class="keyword">const</span> Dialog = <span class="function">(<span class="params">msg = <span class="string">''</span></span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> DialogConstructor(&#123;</div><div class="line">        <span class="attr">el</span>: <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</div><div class="line">    &#125;);</div><div class="line">    instance.msg = msg;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(instance.$el);</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总的来说原则就是独立于当前应用，构建另一套数据结构。对于react，也应该可以使用类似的方案来实现组件。虽然这与官方文档中推荐的，一个应用使用一套数据结构的实现方案有冲突，但是这样就能够使用我们熟悉的方式去开发应用了。具体如何使用还是看个人喜好吧~~</p>
<p>好的那么由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到标题就应该知道，我又来水了……话说最近真是太忙，以至于读源码的事情被无限期搁置了（其实还不是你懒）……咳咳……言归正传，因为要做了个移动的项目，团队成员又大多是新手，所以选了vue作为基础框架。这周的工作中顺手封装了一些常用的组件，在这里记录下自己的想法，省的之后忘了，哈哈……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
      <category term="弹窗组件" scheme="http://brooch.me/tags/%E5%BC%B9%E7%AA%97%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用webpack 2 tree-shaking机制时需要注意的细节</title>
    <link href="http://brooch.me/2017/06/30/webpack-tree-shaking/"/>
    <id>http://brooch.me/2017/06/30/webpack-tree-shaking/</id>
    <published>2017-06-30T14:49:44.000Z</published>
    <updated>2017-07-02T15:13:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前听朋友在群里说在使用webpack打包的时候，tree-shaking并没有起作用，询问是否需要做相应的配置才能启动机制。因为之前仔细阅读过webpack的文档，写tree-shaking的部分并没有提及需要做什么特殊的设置，所以问题应该不是出在webpack的设置上。</p>
<p>那么问题是出在哪儿呢？webpack的文档上有这样一段说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack 2 comes with a built-in support for ES2015 modules (alias harmony modules) as well as unused module export detection.</div></pre></td></tr></table></figure>
<p>大意是说，webpack 2 内部支持了es2015的模块机制。问题就出在这里，tree-shaking依赖于webpack的模块机制，而一般使用webpack时都会搭配babel使用，所以可能在webpack处理之前和babel就已经使用自己的模块机制处理完成了，所以才导致了tree-shaking没有成功。</p>
<p>当时他展示自己的babel配置是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">\\...</div><div class="line">    loader: <span class="string">'babel-loader'</span>,</div><div class="line">    <span class="attr">options</span>: &#123;</div><div class="line">        <span class="attr">presets</span>: [<span class="string">'es2015'</span>, <span class="string">'stage-0'</span>],</div><div class="line">    &#125;</div><div class="line">\\...</div></pre></td></tr></table></figure>
<p>测试之后发现，修改为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">\\...</div><div class="line">    loader: <span class="string">'babel-loader'</span>,</div><div class="line">    <span class="attr">options</span>: &#123;</div><div class="line">        <span class="attr">presets</span>: [</div><div class="line">            [<span class="string">"es2015"</span>, &#123; <span class="string">"modules"</span>: <span class="literal">false</span> &#125;],</div><div class="line">            <span class="string">"stage-2"</span></div><div class="line">        ],</div><div class="line">    &#125;</div><div class="line">\\...</div></pre></td></tr></table></figure></p>
<p>就可以了……</p>
<p>另外，如果想要保持与最新的标准同步，最好使用 babel-preset-env。</p>
<p>另外另外，在调查资料的过程中，还发了一个使用typescript时会遇到的问题，也在这里记录一下。</p>
<p>由于使用typescript时，需要先将先将代码转换到es5，所以也没法使用tree-shaking的机制。解决方法是使用babel为webpack提供的babili-webpack-plugin插件来处理压缩代码。</p>
<p>好的由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前听朋友在群里说在使用webpack打包的时候，tree-shaking并没有起作用，询问是否需要做相应的配置才能启动机制。因为之前仔细阅读过webpack的文档，写tree-shaking的部分并没有提及需要做什么特殊的设置，所以问题应该不是出在webpack的设置上。
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="http://brooch.me/tags/webpack/"/>
    
      <category term="tree-shaking" scheme="http://brooch.me/tags/tree-shaking/"/>
    
  </entry>
  
  <entry>
    <title>简单解决vim打开.vue文件没语法高亮的问题</title>
    <link href="http://brooch.me/2017/06/20/vim-vue-syntax-highlight/"/>
    <id>http://brooch.me/2017/06/20/vim-vue-syntax-highlight/</id>
    <published>2017-06-20T09:23:50.000Z</published>
    <updated>2017-06-20T10:28:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>看vue源码的时候随手写了些测试的代码，发现.vue文件在vim里没高亮，查了下发现vue作者说如果想简单处理直接使用html的高亮就行。so，直接在.vimrc文件里面加一句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">au BufRead,BufNewFile *.vue set filetype=html</div></pre></td></tr></table></figure>
<p>就ok了。</p>
<p>如果觉得html高亮还不够完美，也可以自定义高亮设置。</p>
<p>首先把之前.vimrc文件里的设置改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">au BufRead,BufNewFile *.vue set filetype=vue</div></pre></td></tr></table></figure>
<p>然后在 ~/.vim/syntax（没有自己新建一个）目录下新建文件vue.vim。让vue.vim继承html的高亮，在加上自定义的高亮就行了。</p>
<p>具体写法类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot; version那里要换成自己的vim版本</div><div class="line">runtime! /usr/share/vim/vim&lt;version&gt;/syntax/syntax/html.vim</div><div class="line"></div><div class="line">let b:current_syntax = &quot;vue&quot;</div><div class="line"></div><div class="line">&quot; custom...</div></pre></td></tr></table></figure>
<p>剩下的我就不嫌丑了，毕竟我vim还没玩儿到那么高阶……有兴趣的可以对比<a href="https://github.com/vuejs/vue-syntax-highlight/blob/master/vue.tmLanguage" target="_blank" rel="external">vue.tmLanguage</a>和sublime自带的html.tmLanguage，看看哪儿不一样，再补充到刚才的vue.vim文件里。就这样了~ ╮(￣▽￣)╭</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看vue源码的时候随手写了些测试的代码，发现.vue文件在vim里没高亮，查了下发现vue作者说如果想简单处理直接使用html的高亮就行。so，直接在.vimrc文件里面加一句：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
      <category term="vim" scheme="http://brooch.me/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(6)</title>
    <link href="http://brooch.me/2017/06/20/vue-source-notes-6/"/>
    <id>http://brooch.me/2017/06/20/vue-source-notes-6/</id>
    <published>2017-06-20T05:54:29.000Z</published>
    <updated>2017-08-04T10:52:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，距离上次读vue的源码已经过了一个月了，再次捡起来已经完全不认得了……啊……俗话说，一天不练手脚慢,两天不练丢一半,三天不练门外汉,四天不练瞪眼看，俗话诚不欺我……总之写到哪儿算哪儿吧，希望能跟之前写的接上……╮(￣▽￣)╭</p>
<a id="more"></a>
<h1 id="Vue构造函数和vue实例-instance"><a href="#Vue构造函数和vue实例-instance" class="headerlink" title="Vue构造函数和vue实例 instance"></a>Vue构造函数和vue实例 instance</h1><p>上次把global api和config都看了一遍，这次准备开始看instance这部分，这部分主要定义的是Vue构造函数和vue实例的各种方法。之前在global api中加工的Vue构造函数就出自这个模块。</p>
<h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/instance/index.js" target="_blank" rel="external">index.js</a></h2><p>这个文件是整个模块的入口，主要负责将各个子模块的功能挂载到Vue构造函数上。挂载的方法与global api一样，通过Mixin函数将方法和属性附到Vue.prototype上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></div><div class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">'./state'</span></div><div class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">'./render'</span></div><div class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">'./events'</span></div><div class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></div><div class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</div><div class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</div><div class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// _init就是Vue的起点</span></div><div class="line">  <span class="keyword">this</span>._init(options)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 挂载_init方法</span></div><div class="line">initMixin(Vue)</div><div class="line"><span class="comment">// 挂载$set、$delete方法和$data、$prop属性</span></div><div class="line">stateMixin(Vue)</div><div class="line"><span class="comment">// 挂载$on、$once、$off、$emit方法</span></div><div class="line">eventsMixin(Vue)</div><div class="line"><span class="comment">// 挂载_update、$forceUpdate、$destroy方法</span></div><div class="line">lifecycleMixin(Vue)</div><div class="line"><span class="comment">// 挂载$nextTick、_render方法</span></div><div class="line">renderMixin(Vue)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure>
<p>可以看到_init是构造vue对象的起点，下面我们顺着mixin的挂载顺序，逐个分析文件。</p>
<h2 id="init-js"><a href="#init-js" class="headerlink" title="init.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/instance/init.js" target="_blank" rel="external">init.js</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @flow */</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; perf &#125; <span class="keyword">from</span> <span class="string">'../util/perf'</span></div><div class="line"><span class="keyword">import</span> &#123; initProxy &#125; <span class="keyword">from</span> <span class="string">'./proxy'</span></div><div class="line"><span class="keyword">import</span> &#123; initState &#125; <span class="keyword">from</span> <span class="string">'./state'</span></div><div class="line"><span class="keyword">import</span> &#123; initRender &#125; <span class="keyword">from</span> <span class="string">'./render'</span></div><div class="line"><span class="keyword">import</span> &#123; initEvents &#125; <span class="keyword">from</span> <span class="string">'./events'</span></div><div class="line"><span class="keyword">import</span> &#123; initInjections &#125; <span class="keyword">from</span> <span class="string">'./inject'</span></div><div class="line"><span class="keyword">import</span> &#123; initLifecycle, callHook &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></div><div class="line"><span class="keyword">import</span> &#123; extend, mergeOptions, formatComponentName &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> uid = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</div><div class="line">  <span class="comment">// vue对象的初始化方法</span></div><div class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</div><div class="line">    <span class="comment">/* istanbul ignore if 覆盖率工具istanbul的注释语法，下面的if语句不会计入覆盖率*/</span></div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; perf) &#123;</div><div class="line">      perf.mark(<span class="string">'init'</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">    <span class="comment">// uid是用来作为vue对象的唯一标示用的</span></div><div class="line">    vm._uid = uid++</div><div class="line">    <span class="comment">// 避免vue对象被观测的标记</span></div><div class="line">    vm._isVue = <span class="literal">true</span></div><div class="line">    <span class="comment">// 合并options</span></div><div class="line">    <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</div><div class="line">      <span class="comment">// 如果是组件就走这个逻辑，initInternalComponent函数合并options的速度要比mergeOptions更快</span></div><div class="line">      initInternalComponent(vm, options)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 实例化vue类的时候会调到这里，就是直接 new Vue 或者用 Vue.extend 扩展的子类</span></div><div class="line">      <span class="comment">// 用之前也说过mergeOptions主要用于扩展和继承</span></div><div class="line">      <span class="comment">// 这里用来整理当前的options</span></div><div class="line">      vm.$options = mergeOptions(</div><div class="line">        <span class="comment">// 这里获取类的options</span></div><div class="line">        resolveConstructorOptions(vm.constructor),</div><div class="line">        options || &#123;&#125;,</div><div class="line">        vm</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* istanbul ignore else */</span></div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">      initProxy(vm)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      vm._renderProxy = vm</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 把vm暴露出来</span></div><div class="line">    vm._self = vm</div><div class="line">    <span class="comment">// 启动在index里面挂载的各个模块</span></div><div class="line">    initLifecycle(vm)</div><div class="line">    initEvents(vm)</div><div class="line">    initRender(vm)</div><div class="line">    callHook(vm, <span class="string">'beforeCreate'</span>)</div><div class="line">    initState(vm)</div><div class="line">    initInjections(vm)</div><div class="line">    callHook(vm, <span class="string">'created'</span>)</div><div class="line"></div><div class="line">    <span class="comment">/* istanbul ignore if */</span></div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; perf) &#123;</div><div class="line">      vm._name = formatComponentName(vm, <span class="literal">false</span>)</div><div class="line">      perf.mark(<span class="string">'init end'</span>)</div><div class="line">      perf.measure(<span class="string">`<span class="subst">$&#123;vm._name&#125;</span> init`</span>, <span class="string">'init'</span>, <span class="string">'init end'</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</div><div class="line">      <span class="comment">// options有el参数的时候会自动执行绑定函数</span></div><div class="line">      vm.$mount(vm.$options.el)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 组件的初始化使用的函数，效率比使用mergeOptions效率高</span></div><div class="line"><span class="comment">// 因为函数内只赋值了特定的属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initInternalComponent</span> (<span class="params">vm: Component, options: InternalComponentOptions</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> opts = vm.$options = <span class="built_in">Object</span>.create(vm.constructor.options)</div><div class="line">  opts.parent = options.parent</div><div class="line">  opts.propsData = options.propsData</div><div class="line">  opts._parentVnode = options._parentVnode</div><div class="line">  opts._parentListeners = options._parentListeners</div><div class="line">  opts._renderChildren = options._renderChildren</div><div class="line">  opts._componentTag = options._componentTag</div><div class="line">  opts._parentElm = options._parentElm</div><div class="line">  opts._refElm = options._refElm</div><div class="line">  <span class="keyword">if</span> (options.render) &#123;</div><div class="line">    opts.render = options.render</div><div class="line">    opts.staticRenderFns = options.staticRenderFns</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 整理获取类的options</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span> (<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> options = Ctor.options</div><div class="line">  <span class="keyword">if</span> (Ctor.super) &#123;</div><div class="line">    <span class="comment">// 如果有父类，就整理父类的options</span></div><div class="line">    <span class="keyword">const</span> superOptions = resolveConstructorOptions(Ctor.super)</div><div class="line">    <span class="keyword">const</span> cachedSuperOptions = Ctor.superOptions</div><div class="line">    <span class="keyword">if</span> (superOptions !== cachedSuperOptions) &#123;</div><div class="line">      <span class="comment">// 如果父类的options有变化，需要重新获取父类的options</span></div><div class="line">      Ctor.superOptions = superOptions</div><div class="line">      <span class="comment">// resolveModifiedOptions可以检查options的更新</span></div><div class="line">      <span class="keyword">const</span> modifiedOptions = resolveModifiedOptions(Ctor)</div><div class="line">      <span class="comment">// 同步修改过的属性</span></div><div class="line">      <span class="keyword">if</span> (modifiedOptions) &#123;</div><div class="line">        extend(Ctor.extendOptions, modifiedOptions)</div><div class="line">      &#125;</div><div class="line">      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)</div><div class="line">      <span class="keyword">if</span> (options.name) &#123;</div><div class="line">        options.components[options.name] = Ctor</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> options</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 检查options的更新</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveModifiedOptions</span> (<span class="params">Ctor: Class&lt;Component&gt;</span>): ?<span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="keyword">let</span> modified</div><div class="line">  <span class="keyword">const</span> latest = Ctor.options</div><div class="line">  <span class="keyword">const</span> sealed = Ctor.sealedOptions</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> latest) &#123;</div><div class="line">    <span class="keyword">if</span> (latest[key] !== sealed[key]) &#123;</div><div class="line">      <span class="keyword">if</span> (!modified) modified = &#123;&#125;</div><div class="line">      modified[key] = dedupe(latest[key], sealed[key])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> modified</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 删除重复数据的函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span> (<span class="params">latest, sealed</span>) </span>&#123;</div><div class="line">  <span class="comment">// 主要是处理生命周期回调，让回调不会直接被替换赋值，而是被逐个添加</span></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(latest)) &#123;</div><div class="line">    <span class="keyword">const</span> res = []</div><div class="line">    sealed = <span class="built_in">Array</span>.isArray(sealed) ? sealed : [sealed]</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; latest.length; i++) &#123;</div><div class="line">      <span class="keyword">if</span> (sealed.indexOf(latest[i]) &lt; <span class="number">0</span>) &#123;</div><div class="line">        res.push(latest[i])</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> latest</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个模块对于 vue 实例的处理有很多都可以在官方文档的说明中找到，文档中没有描述的是 options 对象的继承。可以看到 options 对象的继承和并不是基于原型链的，而是基于合并赋值，我猜这么做的目的是为了让程序运行起来更快，毕竟省了一个遍历原型链的过程……</p>
<h2 id="proxy-js"><a href="#proxy-js" class="headerlink" title="proxy.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/instance/proxy.js" target="_blank" rel="external">proxy.js</a></h2><p>proxy 这部分的启动逻辑只有在非生产环境才能起作用，感觉不是很重要啊……主要的作用是用来检查vm添加的属性是不是系统变量，如果是系统变量就报警告，貌似是这样吧……Proxy方法是用来定义对象属性的基本操作的，感觉跟defineProperty有点像</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//flow无法检查原生对象Proxy，所有这个文件就没用flow</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'core/config'</span></div><div class="line"><span class="keyword">import</span> &#123; warn, makeMap &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> initProxy</div><div class="line"></div><div class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">  <span class="keyword">const</span> allowedGlobals = makeMap(</div><div class="line">    <span class="string">'Infinity,undefined,NaN,isFinite,isNaN,'</span> +</div><div class="line">    <span class="string">'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,'</span> +</div><div class="line">    <span class="string">'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,'</span> +</div><div class="line">    <span class="string">'require'</span> <span class="comment">// for Webpack/Browserify</span></div><div class="line">  )</div><div class="line"></div><div class="line">  <span class="keyword">const</span> warnNonPresent = <span class="function">(<span class="params">target, key</span>) =&gt;</span> &#123;</div><div class="line">    warn(</div><div class="line">      <span class="string">`Property or method "<span class="subst">$&#123;key&#125;</span>" is not defined on the instance but `</span> +</div><div class="line">      <span class="string">`referenced during render. Make sure to declare reactive data `</span> +</div><div class="line">      <span class="string">`properties in the data option.`</span>,</div><div class="line">      target</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> hasProxy =</div><div class="line">    <span class="keyword">typeof</span> <span class="built_in">Proxy</span> !== <span class="string">'undefined'</span> &amp;&amp;</div><div class="line">    <span class="built_in">Proxy</span>.toString().match(<span class="regexp">/native code/</span>)</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (hasProxy) &#123;</div><div class="line">    <span class="keyword">const</span> isBuiltInModifier = makeMap(<span class="string">'stop,prevent,self,ctrl,shift,alt,meta'</span>)</div><div class="line">    config.keyCodes = <span class="keyword">new</span> <span class="built_in">Proxy</span>(config.keyCodes, &#123;</div><div class="line">      set (target, key, value) &#123;</div><div class="line">        <span class="keyword">if</span> (isBuiltInModifier(key)) &#123;</div><div class="line">          warn(<span class="string">`Avoid overwriting built-in modifier in config.keyCodes: .<span class="subst">$&#123;key&#125;</span>`</span>)</div><div class="line">          <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          target[key] = value</div><div class="line">          <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> hasHandler = &#123;</div><div class="line">    has (target, key) &#123;</div><div class="line">      <span class="keyword">const</span> has = key <span class="keyword">in</span> target</div><div class="line">      <span class="keyword">const</span> isAllowed = allowedGlobals(key) || key.charAt(<span class="number">0</span>) === <span class="string">'_'</span></div><div class="line">      <span class="keyword">if</span> (!has &amp;&amp; !isAllowed) &#123;</div><div class="line">        warnNonPresent(target, key)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> has || !isAllowed</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> getHandler = &#123;</div><div class="line">    get (target, key) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'string'</span> &amp;&amp; !(key <span class="keyword">in</span> target)) &#123;</div><div class="line">        warnNonPresent(target, key)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> target[key]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  initProxy = <span class="function"><span class="keyword">function</span> <span class="title">initProxy</span> (<span class="params">vm</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (hasProxy) &#123;</div><div class="line">      <span class="comment">// determine which proxy handler to use</span></div><div class="line">      <span class="keyword">const</span> options = vm.$options</div><div class="line">      <span class="comment">// _withStripped这个属性如果被设为true，则不能给vm添加系统变量作为属性，貌似吧……具体的用法是在测试代码里找到的……</span></div><div class="line">      <span class="keyword">const</span> handlers = options.render &amp;&amp; options.render._withStripped</div><div class="line">        ? getHandler</div><div class="line">        : hasHandler</div><div class="line">      vm._renderProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(vm, handlers)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      vm._renderProxy = vm</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123; initProxy &#125;</div></pre></td></tr></table></figure>
<p>今天就到这儿吧，累了，话说下周开始我们也要007了……真是嘴贱某次跟领导吃饭的时候把007当笑话告诉了他，结果给他打开了新世界的大门……如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的力度了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，距离上次读vue的源码已经过了一个月了，再次捡起来已经完全不认得了……啊……俗话说，一天不练手脚慢,两天不练丢一半,三天不练门外汉,四天不练瞪眼看，俗话诚不欺我……总之写到哪儿算哪儿吧，希望能跟之前写的接上……╮(￣▽￣)╭&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Picodom中的diff算法补完</title>
    <link href="http://brooch.me/2017/06/16/picodom-introduce-additional/"/>
    <id>http://brooch.me/2017/06/16/picodom-introduce-additional/</id>
    <published>2017-06-16T05:13:27.000Z</published>
    <updated>2017-06-16T14:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2017/06/09/picodom-introduce/">上次</a>看 Picodom 代码的时候，patch 函数中有段代码没怎么看懂，所以就没分析，算是挖下了坑。经过这几天的思考，我终于把逻辑想明白了，今儿咱就来把这个坑给填上~（美错儿，我今天又要划水了，来打我呀打我呀打我呀~）</p>
<a id="more"></a>
<h2 id="逻辑梳理"><a href="#逻辑梳理" class="headerlink" title="逻辑梳理"></a>逻辑梳理</h2><p>上次看到 Picodom 中 的 patch 函数中，逻辑分为三个分支，分别是新增节点（没有oldNode），修改节点（newNode和oldNode标签名一样），替换节点（newNode和oldNode标签名不一样）。其中，新增节点和替换节点的操作比较简单。单修改节点的操作，除了要修改节点本身的属性外，还要对比更新节点的子节点，逻辑比较复杂，直接讲代码的话不太容易看出其中的逻辑，咱们先来梳理一下。</p>
<p>说到子节点变化，一般会分为以下这几种情况：</p>
<ol>
<li>增加新节点：有可能在旧列表的最开始，中间或者之后添加</li>
<li>复用旧节点：还记得之前看的代码中，Picodom 会把节点的 key 属性特殊对待吗？这里就是把 key 作为节点的唯一标识的，只要 key 对上了就认为是能复用，dom节点不用新建，不过位置有可能发生变化</li>
<li>删除旧节点：删除单个或者多个节点</li>
<li>把以上这些情况综合起来~</li>
</ol>
<p>如图，比如像下面这种情况：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/picodom-introduce-additional-01.jpg" alt="01"></p>
<p>其实这逻辑说起来感觉还挺简单，但是如何用代码实现呢？我们先说下 Picodom 的处理方法，以上图为例。</p>
<p>遍历新节点列表，新节点列表和旧节点列表里各取一个，作为当前新节点和当前旧节点，对比他们，这俩节点 key 不一样，而且在旧节点列表里也没有找到这个节点，于是在当前旧节点前添加新节点，当前新节点切换到下一节点。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/picodom-introduce-additional-02.jpg" alt="02"></p>
<p>当前新节点和当前旧节点 key 不一样，但是在旧节点列表里能找到，就把找到的旧节点插入到当前旧节点前面，当前新节点切换到下一节点。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/picodom-introduce-additional-03.jpg" alt="03"></p>
<p>对新节点列表中的 4 和 7 的处理和前面一样，就不再多说了。处理过他们之后，取到的当前新节点和当前旧节点的 key 是一样的。这时把新旧节点都传入 patch 函数，递归处理这两个节点。处理过之后，当前新节点和当前旧节点都切换到下一节点。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/picodom-introduce-additional-04.jpg" alt="04"></p>
<p>根据之前的步骤，把 2 也处理了，最后当前新节点是 8 ，当前旧节点是 3 ，8 是新增的，所以插入到 3 前面。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/picodom-introduce-additional-05.jpg" alt="05"></p>
<p>最后将未用到的旧节点删除掉，既把 3 删掉，得到最终结果。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>ok，让我们来看下 Picodom 是如何用代码来实现上述逻辑的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> len = node.children.length</div><div class="line"><span class="comment">// 新子节点vnode列表的长度</span></div><div class="line"><span class="keyword">var</span> oldLen = oldNode.children.length</div><div class="line"><span class="comment">// 旧子节点vnode列表的长度</span></div><div class="line"><span class="keyword">var</span> reusableChildren = &#123;&#125;</div><div class="line"><span class="comment">// 可复用节点列表</span></div><div class="line"><span class="keyword">var</span> oldElements = []</div><div class="line"><span class="comment">// 旧子节点dom列表</span></div><div class="line"><span class="keyword">var</span> newKeys = &#123;&#125;</div><div class="line"><span class="comment">// 这边变量用来标记新子节点列表中复用的节点</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oldLen; i++) &#123;</div><div class="line">    <span class="keyword">var</span> oldElement = element.childNodes[i]</div><div class="line">    oldElements[i] = oldElement</div><div class="line"></div><div class="line">    <span class="keyword">var</span> oldChild = oldNode.children[i]</div><div class="line">    <span class="keyword">var</span> oldKey = getKeyFrom(oldChild)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != oldKey) &#123;</div><div class="line">        reusableChildren[oldKey] = [oldElement, oldChil]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 上面这个循环是在遍历旧子节点vnode列表，把有key的挑出来，放到可复用节点列表里</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> j = <span class="number">0</span></div><div class="line"><span class="comment">// i是旧子节点vnode列表的索引，j是新子节点vnode列表的索引</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> (j &lt; len) &#123;</div><div class="line"><span class="comment">// 遍历新子节点vnode列表</span></div><div class="line">    <span class="keyword">var</span> oldElement = oldElements[i]</div><div class="line">    <span class="comment">// 取当前旧节点dom</span></div><div class="line">    <span class="keyword">var</span> oldChild = oldNode.children[i]</div><div class="line">    <span class="comment">// 取当前旧节点vnode</span></div><div class="line">    <span class="keyword">var</span> newChild = node.children[j]</div><div class="line">    <span class="comment">// 取当前新节点vnode</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> oldKey = getKeyFrom(oldChild)</div><div class="line">    <span class="comment">// 取当前旧节点的key</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (newKeys[oldKey]) &#123;</div><div class="line">        i++</div><div class="line">        <span class="keyword">continue</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 上面这个判断是为了跳过已经被使用过的旧子节点</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> newKey = getKeyFrom(newChild)</div><div class="line">    <span class="comment">// 取当前新节点的key</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> reusableChild = reusableChildren[newKey] || []</div><div class="line">    <span class="comment">// 取当前新节点key对应的可复用节点</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == newKey) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == oldKey) &#123;</div><div class="line">            patch(element, oldElement, oldChild, newChild)</div><div class="line">            j++</div><div class="line">            <span class="comment">// 如果新节点和旧节点都没有key则在当前旧节点对应的dom节点前插入新节点</span></div><div class="line">            <span class="comment">// 然后切换当前新节点</span></div><div class="line">        &#125;</div><div class="line">        i++</div><div class="line">        <span class="comment">// 这里的处理方式让人很难理解，为啥是新节点和旧节点都没有key的时候才插入？</span></div><div class="line">        <span class="comment">// 我感觉这样处理主要是为了处理文本节点……因为文本节点是肯定没有key的</span></div><div class="line">        <span class="comment">// 另外如果新节点里出现了一个没有key的节点，</span></div><div class="line">        <span class="comment">// 那么上面这段逻辑就会一直切换的当前旧节点，</span></div><div class="line">        <span class="comment">// 直到找到一个同样没有key的旧节点，再用patch对比两个节点，</span></div><div class="line">        <span class="comment">// 如果一直没有找到没有key的旧节点，最后oldElement和oldChild都是null，</span></div><div class="line">        <span class="comment">// 相当于在旧节点列表最后添加一个新的节点，</span></div><div class="line">        <span class="comment">// 此时当前旧节点已经切到旧节点列表最后了，</span></div><div class="line">        <span class="comment">// 所以后续的所有操作都是往旧节点列表最后添加新的节点</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (oldKey === newKey) &#123;</div><div class="line">            patch(element, reusableChild[<span class="number">0</span>], reusableChild[<span class="number">1</span>], newChild)</div><div class="line">            i++</div><div class="line">            <span class="comment">// 如果新节点和旧节点的key相同，则用patch再去对比这两个节点</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reusableChild[<span class="number">0</span>]) &#123;</div><div class="line">            element.insertBefore(reusableChild[<span class="number">0</span>], oldElement)</div><div class="line">            patch(element, reusableChild[<span class="number">0</span>], reusableChild[<span class="number">1</span>], newChild)</div><div class="line">            <span class="comment">// 如果key不相同但是存在可复用节点，则把可复用节点插入到当前旧节点前面</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            patch(element, oldElement, <span class="literal">null</span>, newChild)</div><div class="line">            <span class="comment">// 如果key不同而且不存在可复用节点，则在当前旧节点前面插入个新节点</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        j++</div><div class="line">        <span class="comment">// 切换当前新节点</span></div><div class="line">        newKeys[newKey] = newChild</div><div class="line">        <span class="comment">// 记录已经使用的节点的key，后续可以用来过滤出已经使用的可复用节点</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 根据key复用旧节点</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> (i &lt; oldLen) &#123;</div><div class="line">    <span class="keyword">var</span> oldChild = oldNode.children[i]</div><div class="line">    <span class="keyword">var</span> oldKey = getKeyFrom(oldChild)</div><div class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == oldKey) &#123;</div><div class="line">        removeElement(element, oldElements[i], oldChild)</div><div class="line">    &#125;</div><div class="line">    i++</div><div class="line">&#125;</div><div class="line"><span class="comment">// 移除没有key的旧节点</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> reusableChildren) &#123;</div><div class="line">    <span class="keyword">var</span> reusableChild = reusableChildren[i]</div><div class="line">    <span class="keyword">var</span> reusableNode = reusableChild[<span class="number">1</span>]</div><div class="line">    <span class="keyword">if</span> (!newKeys[reusableNode.data.key]) &#123;</div><div class="line">        removeElement(element, reusableChild[<span class="number">0</span>], reusableNode)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 根据新节点的key过滤并移除掉已经使用的可复用节点</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>看过代码之后我们会发现，如果出现没有key的节点那么之前那套算法的效率就会变差，因为有可能需要遍历整个旧节点列表之后才能对比，这也就是不难理解为啥之前版本的react会自动生成一个datareact-id了……从这个角度来看，感觉给节点加上唯一key做表示可以提升界面更新的效率，不知道react或者vue里这么搞是不是有效……</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/picodom-introduce-additional-06.jpg" alt="06"></p>
<p>好的那么由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2017/06/09/picodom-introduce/&quot;&gt;上次&lt;/a&gt;看 Picodom 代码的时候，patch 函数中有段代码没怎么看懂，所以就没分析，算是挖下了坑。经过这几天的思考，我终于把逻辑想明白了，今儿咱就来把这个坑给填上~（美错儿，我今天又要划水了，来打我呀打我呀打我呀~）&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="virtual dom" scheme="http://brooch.me/tags/virtual-dom/"/>
    
      <category term="picodom" scheme="http://brooch.me/tags/picodom/"/>
    
  </entry>
  
  <entry>
    <title>Picodom -- 1kb的Virtual DOM库</title>
    <link href="http://brooch.me/2017/06/09/picodom-introduce/"/>
    <id>http://brooch.me/2017/06/09/picodom-introduce/</id>
    <published>2017-06-09T12:10:23.000Z</published>
    <updated>2017-06-09T15:01:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>话说，对于Virtual DOM解析的文章不少。但是，要不就是浅尝辄止，说到把dom解析成树型数据结构就结束了，不讲补丁算法，要不就是补丁算法说的太深奥完全理解不了。今天发现个好货，<a href="https://github.com/picodom/" target="_blank" rel="external">Picodom</a>，这个库用了200多行代码就把 virtual dom 和 patch 算法实现了，这下好了，有了实际代码理论也好理解，废话少说，快来一起读代码吧~</p>
<a id="more"></a>
<p>咱们先看看咋使，官方给出了一个<a href="https://codepen.io/picodom/pen/BRbJpG" target="_blank" rel="external">小栗子</a>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; h, patch &#125; <span class="keyword">from</span> <span class="string">"picodom"</span></div><div class="line"></div><div class="line"><span class="comment">/** @jsx h */</span></div><div class="line"><span class="comment">// 加了这个之后babel就会用h作为jsx中的vnode构造函数</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> element, oldNode</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 重新刷新界面用的</div><div class="line"> * @param newNode 新的vnode</div><div class="line"> * @return 更新后的dom对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">newNode</span>) </span>&#123;</div><div class="line">    <span class="comment">// 为了方便理解我稍微修改了下这个函数</span></div><div class="line">    element = patch(</div><div class="line">        <span class="built_in">document</span>.body, <span class="comment">// 要更新的节点的父级</span></div><div class="line">        element, <span class="comment">// 要更新的节点对应的dom对象</span></div><div class="line">        oldNode, <span class="comment">// 根据旧状态构造的vnode</span></div><div class="line">        newNode <span class="comment">// 根据新状态构造的vnode</span></div><div class="line">    )</div><div class="line">    <span class="comment">// patch函数会更新界面，返回更新后的dom节点</span></div><div class="line">    oldNode = newNode</div><div class="line">    <span class="comment">// 更新后将传入的vnode标记为旧的</span></div><div class="line">    <span class="keyword">return</span> element</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据不同的state生成不同的vnode对象</div><div class="line"> * @param state 新的状态</div><div class="line"> * @return 构造好的vnode对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">view</span>(<span class="params">state</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        &lt;div&gt;</div><div class="line">        &lt;h1&gt;&#123;state&#125;&lt;/h1&gt;</div><div class="line">        &lt;input</div><div class="line">            oninput=&#123;e =&gt; render(view(e.target.value))&#125;</div><div class="line">            // 每次input框的值变化时都重新运行render，来刷新界面</div><div class="line">            value=&#123;state&#125;</div><div class="line">            type="text"</div><div class="line">        /&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    )</div><div class="line">&#125;</div><div class="line"></div><div class="line">render(view("Hello Picodom!"))</div><div class="line">// 启动~！</div></pre></td></tr></table></figure>
<p>picodom 的 核心的一共就俩文件，h.js 用来实现 virtual dom ，patch.js 用来实现补丁算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|</div><div class="line">|-- index.js <span class="comment">// 导出h和patch方法</span></div><div class="line">|-- h.js <span class="comment">// 实现 virtual dom </span></div><div class="line">|-- patch.js <span class="comment">// 实现 patch</span></div></pre></td></tr></table></figure>
<p>先看看 virtual dom 是怎么实现的吧。</p>
<p>平时写jsx没感觉，但是看babel转换后的代码就可以看到，比如这样的结构：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">    &lt;h1&gt;&#123;state&#125;&lt;/h1&gt;</div><div class="line">    &lt;input</div><div class="line">        oninput=&#123;e =&gt; <span class="built_in">console</span>.log(e.target.value)&#125;</div><div class="line">        value=&#123;state&#125;</div><div class="line">        type=<span class="string">"text"</span></div><div class="line">    /&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>转换后应该是类似这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假设fn是vnode构造函数</span></div><div class="line">fn(<span class="string">'div'</span>, <span class="literal">null</span>, </div><div class="line">    fn(<span class="string">'h1'</span>, <span class="literal">null</span>, state), </div><div class="line">    fn(<span class="string">'input'</span>, &#123;</div><div class="line">        <span class="attr">oninput</span>: <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e.target.value),</div><div class="line">        <span class="attr">value</span>: state,</div><div class="line">        <span class="attr">type</span>: <span class="string">"text"</span></div><div class="line">    &#125;)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>从上面的伪码可已看出，一般 virtual dom 的构造函数接收的参数中，第一个参数是标签名，第二个参数是属性，后面的参数是子节点。ok，那我们来看下 h.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * virtual dom 节点构造函数</div><div class="line"> * @param tag 标签名</div><div class="line"> * @param data 标签属性</div><div class="line"> * @return 构造好的vnode</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> node</div><div class="line">    <span class="keyword">var</span> stack = []</div><div class="line">    <span class="keyword">var</span> children = []</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="built_in">arguments</span>.length; i-- &gt; <span class="number">2</span>;) &#123;</div><div class="line">        stack[stack.length] = <span class="built_in">arguments</span>[i]</div><div class="line">        <span class="comment">// 除了前两个参数，其他的参数作为子节点的数据，都推入stack备用</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (stack.length) &#123;</div><div class="line">        <span class="comment">// 循环stack</span></div><div class="line">        node = stack.pop()</div><div class="line">        <span class="comment">// 逐个取出子节点的数据</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(node)) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = node.length; i--;) &#123;</div><div class="line">                stack[stack.length] = node[i]</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果子节点数据是个数组，就把他展开</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; node !== <span class="literal">true</span> &amp;&amp; node !== <span class="literal">false</span>) &#123;</div><div class="line">            <span class="comment">// 子节点数据是null、true、false时不做处理</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">"number"</span>) &#123;</div><div class="line">                node = node + <span class="string">""</span></div><div class="line">                <span class="comment">// 如果子节点数据是数字，则转换成字符串</span></div><div class="line">            &#125;</div><div class="line">            children[children.length] = node</div><div class="line">            <span class="comment">//把子节点数据存到children里</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 上面的循环结束后，所有的子节点数据都已经展开，并存到children中</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> tag === <span class="string">"string"</span> ?</div><div class="line">        &#123;</div><div class="line">            <span class="attr">tag</span>: tag,</div><div class="line">            <span class="attr">data</span>: data || &#123;&#125;,</div><div class="line">            <span class="attr">children</span>: children</div><div class="line">        &#125; :</div><div class="line">        tag(data, children)</div><div class="line">    <span class="comment">// 如果tag是字符串就返回一个节点的描述对象</span></div><div class="line">    <span class="comment">// 如果tag不是字符串就认为tag是组件构造函数，将节点的属性信息和子节点信息都传进去，让其创建节点描述对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看过上面的代码我们不难想象，最终构造出的 virtual dom，就是一个描述dom片段的树状结构的对象，每个节点有tag、data、children三个属性，tag、data描述当前节点，children描述子节点，最终描述出整个dom片段。</p>
<p>看过 virtual dom 的构造函数之后，是不是觉得比想象中简单？只要理清逻辑，其实你也能写出来对不对？</p>
<p>好的，那我们再来看看patch.js，代码中不重要的函数我先标注作用，想看具体实现就往后拉吧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 非重点函数的功能</div><div class="line"> * createElementFrom 根据vnode创建节点，里面会递归children创建子节点</div><div class="line"> * updateElementData 根据新的vnode更新当前dom对象的属性值</div><div class="line"> * getKeyFrom 获取vnode的key属性，key属性使用来标记元素唯一性的</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 补丁算法实现函数</div><div class="line"> * @param parent    要更新节点的父节点dom对象</div><div class="line"> * @param element   要更新节点的dom对象</div><div class="line"> * @param oldNode   要更新节点旧的vnode对象</div><div class="line"> * @param node      要更新节点新的vnode对象</div><div class="line"> * @return 刷新后的dom节点</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">parent, element, oldNode, node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (oldNode == <span class="literal">null</span>) &#123;</div><div class="line">        element = parent.insertBefore(createElementFrom(node), element)</div><div class="line">        <span class="comment">// 如果没有旧的vnode对象则直接创建插入节点</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.tag &amp;&amp; node.tag === oldNode.tag) &#123;</div><div class="line">        updateElementData(element, oldNode.data, node.data)</div><div class="line">        <span class="comment">// 如果当前节点的标签名没有变化，则直接当前节点的属性</span></div><div class="line">        <span class="keyword">var</span> len = node.children.length</div><div class="line">        <span class="keyword">var</span> oldLen = oldNode.children.length</div><div class="line">        <span class="keyword">var</span> reusableChildren = &#123;&#125;</div><div class="line">        <span class="keyword">var</span> oldElements = []</div><div class="line">        <span class="keyword">var</span> newKeys = &#123;&#125;</div><div class="line"></div><div class="line">        <span class="comment">// 下面主要做的就是对比子节点</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oldLen; i++) &#123;</div><div class="line">            <span class="keyword">var</span> oldElement = element.childNodes[i]</div><div class="line">            oldElements[i] = oldElement</div><div class="line"></div><div class="line">            <span class="keyword">var</span> oldChild = oldNode.children[i]</div><div class="line">            <span class="keyword">var</span> oldKey = getKeyFrom(oldChild)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != oldKey) &#123;</div><div class="line">                reusableChildren[oldKey] = [oldElement, oldChil]</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 用旧vnode的子节点构造一个可复用的列表</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">        <span class="keyword">var</span> j = <span class="number">0</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (j &lt; len) &#123;</div><div class="line">            <span class="keyword">var</span> oldElement = oldElements[i]</div><div class="line">            <span class="keyword">var</span> oldChild = oldNode.children[i]</div><div class="line">            <span class="keyword">var</span> newChild = node.children[j]</div><div class="line"></div><div class="line">            <span class="keyword">var</span> oldKey = getKeyFrom(oldChild)</div><div class="line">            <span class="keyword">if</span> (newKeys[oldKey]) &#123;</div><div class="line">                i++</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">var</span> newKey = getKeyFrom(newChild)</div><div class="line"></div><div class="line">            <span class="keyword">var</span> reusableChild = reusableChildren[newKey] || []</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == newKey) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == oldKey) &#123;</div><div class="line">                    patch(element, oldElement, oldChild, newChild)</div><div class="line">                    j++</div><div class="line">                &#125;</div><div class="line">                i++</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (oldKey === newKey) &#123;</div><div class="line">                    patch(element, reusableChild[<span class="number">0</span>], reusableChild[<span class="number">1</span>], newChild)</div><div class="line">                    i++</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reusableChild[<span class="number">0</span>]) &#123;</div><div class="line">                    element.insertBefore(reusableChild[<span class="number">0</span>], oldElement)</div><div class="line">                    patch(element, reusableChild[<span class="number">0</span>], reusableChild[<span class="number">1</span>], newChild)</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    patch(element, oldElement, <span class="literal">null</span>, newChild)</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                j++</div><div class="line">                newKeys[newKey] = newChild</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 根据key复用旧节点</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (i &lt; oldLen) &#123;</div><div class="line">            <span class="keyword">var</span> oldChild = oldNode.children[i]</div><div class="line">            <span class="keyword">var</span> oldKey = getKeyFrom(oldChild)</div><div class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == oldKey) &#123;</div><div class="line">                removeElement(element, oldElements[i], oldChild)</div><div class="line">            &#125;</div><div class="line">            i++</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 移除没有key的旧节点</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> reusableChildren) &#123;</div><div class="line">            <span class="keyword">var</span> reusableChild = reusableChildren[i]</div><div class="line">            <span class="keyword">var</span> reusableNode = reusableChild[<span class="number">1</span>]</div><div class="line">            <span class="keyword">if</span> (!newKeys[reusableNode.data.key]) &#123;</div><div class="line">                removeElement(element, reusableChild[<span class="number">0</span>], reusableNode)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 根据新的key过滤掉无用的节点</span></div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node !== oldNode) &#123;</div><div class="line">        <span class="keyword">var</span> i = element</div><div class="line">        parent.replaceChild((element = createElementFrom(node)), i)</div><div class="line">        <span class="comment">// 如果标签名变了就创建新节点替换当前节点，replaceChild是dom的api</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> element</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>嗯，根据key更换节点的逻辑我也看得比较模糊，坑先挖下，后续再填吧。总的来说 picodom 非常适合用来做研究，从中可以大概了解到virtual dom 和 patch 的基本原理，至于实用性的话……拿来做jsx解析的模板语言没准儿能行吧……</p>
<p>好的那么由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话说，对于Virtual DOM解析的文章不少。但是，要不就是浅尝辄止，说到把dom解析成树型数据结构就结束了，不讲补丁算法，要不就是补丁算法说的太深奥完全理解不了。今天发现个好货，&lt;a href=&quot;https://github.com/picodom/&quot;&gt;Picodom&lt;/a&gt;，这个库用了200多行代码就把 virtual dom 和 patch 算法实现了，这下好了，有了实际代码理论也好理解，废话少说，快来一起读代码吧~&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="virtual dom" scheme="http://brooch.me/tags/virtual-dom/"/>
    
      <category term="picodom" scheme="http://brooch.me/tags/picodom/"/>
    
  </entry>
  
  <entry>
    <title>新版Create React App里的新鲜玩意儿</title>
    <link href="http://brooch.me/2017/06/02/whats-new-in-create-react-app/"/>
    <id>http://brooch.me/2017/06/02/whats-new-in-create-react-app/</id>
    <published>2017-06-02T09:19:43.000Z</published>
    <updated>2017-06-02T12:47:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>话说玩儿react的同学可能都知道<a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">Create React App</a>这个项目吧（不知道的戳<a href="http://www.jianshu.com/p/dd4cee273bed" target="_blank" rel="external">这里</a>了解，这是来自Facebook官方的零配置命令行工具，能够帮你自动创建基于Webpack的最简易的React项目模板）。话说今天看期刊的时候发现了一篇react的官方blog更新了一篇叫<a href="https://facebook.github.io/react/blog/2017/05/18/whats-new-in-create-react-app.html" target="_blank" rel="external">What’s New in Create React App</a>的博客，随手翻了下发现 Create React App 这个项目居然也更新新版本了？！而且还添加进来很多有趣的功能。我半翻译半解读一下这篇文章，咱们看看有哪些有趣的新功能吧。</p>
<a id="more"></a>
<p>Create React App 这个项目推出大概有一年了，作为一个官方推荐的快速搭建react项目的脚手架，这个项目吸引了大量的开发者。而这个项目在沉寂了几个月之后，于5月18号发布了1.0.0版本（最近这十四天有release了七次，真是猛啊……），添加了好多新的特性。如果你当前正在开发的应用是使用 Create React App 创建的，想体验新版本的特性，并且你的项目并没有执行弹出操作（Create React App 有个 eject命令），可以参考官方的<a href="https://github.com/facebookincubator/create-react-app/releases/tag/v1.0.0" target="_blank" rel="external">升级说明</a>来升级 Create React App。</p>
<h2 id="webpack-2"><a href="#webpack-2" class="headerlink" title="webpack 2"></a>webpack 2</h2><p>虽然 webpack 2 相比 webpack 的改动很大，有可能存在很多问题，但是 webpack 2 已经正式发布几个月了，Create React App 团队经过了一段时间的测试，认为目前 webpack 2 已经足够稳定了，所以将模板中的构建工具也修改为 webpack 2。而且 Create React App 的用户并不需要担心 webpack 2 配置上的改动，Create React App 内部对 webpack 的配置进行了兼容。</p>
<p>如果你的项目已经执行过弹出操作了，则需要参考 webpack 提过的<a href="https://webpack.js.org/guides/migrating/" target="_blank" rel="external">升级指南</a>自己手动修改配置。</p>
<p>webpack 2 最引人注目的新特性就是其对 <a href="http://2ality.com/2014/09/es6-modules-final.html" target="_blank" rel="external">ES6 模块</a> 的支持，可以将将 ES6 模块 直接转化为 CommonJS 模块。虽然这对开发来说可能没啥影响，但是它可以在编译阶段捕获更多的错误，比如exports 的变量undefined之类的：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-01.gif" alt="whats-new-in-create-react-app-01"></p>
<p>webpack 2 还提供了 <a href="http://www.css88.com/archives/6946" target="_blank" rel="external">tree shaking</a> 特性，可以通过去除冗余代码，优化打包后脚本的尺寸。</p>
<h2 id="Runtime-Error-Overlay"><a href="#Runtime-Error-Overlay" class="headerlink" title="Runtime Error Overlay"></a>Runtime Error Overlay</h2><p>你有没有这种经历，代码中写错了一个地方，控制台里也报错了，但是死活找不到报错代码的位置……</p>
<p>为了解决这个问题，我们引入了一个专门捕获错误的弹窗，当程序报错的时候他会展示报错信息和引发错误的位置！当然，他只会出现在开发阶段，产出代码的时候会被去掉。</p>
<p>有图，有真相，就在这儿晒！</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-02.gif" alt="whats-new-in-create-react-app-02"></p>
<p>更牛逼的是，他还能跟你的编辑器结合到一起，惊不惊喜？意不意外？</p>
<p>未来 Creat React App 还准备支持更多错误捕获。比如在React 16 版本发布之后，Creat React App 计划支持 React 组件调用栈的展示。</p>
<h1 id="默认支持渐进式web应用"><a href="#默认支持渐进式web应用" class="headerlink" title="默认支持渐进式web应用"></a>默认支持渐进式web应用</h1><p>使用新版本 Creat React App 创建的项目默认就会支持 [渐进式web应用(PWA)] (<a href="https://developers.google.com/web/progressive-web-apps/)，会使用" target="_blank" rel="external">https://developers.google.com/web/progressive-web-apps/)，会使用</a> <a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers" target="_blank" rel="external">service workers</a> 实现 <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network" target="_blank" rel="external">缓存优先策略</a> 来优化用户再次访问应用的速度。当然，你也可以通过设置默认不开启这个特性，但是如果你在开发新的应用，我推荐你使用它，特别是在移动设备上运行的应用，会有惊喜哦~</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-03.png" alt="whats-new-in-create-react-app-03"></p>
<p>关于 Creat React App 中 PWA 的配置，更详细的说明请戳<a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#making-a-progressive-web-app" target="_blank" rel="external">这里</a>。</p>
<p>题外话，貌似最近 PWA 很火呢，前段时间看到 vue 官方也退出了基于自己框架的<a href="https://github.com/vuejs-templates/pwa" target="_blank" rel="external">pwa脚手架</a>，另外我还发现一个在线的 PWA 脚手架工具，有兴趣的可以玩儿玩儿，<a href="http://www.pwabuilder.com/" target="_blank" rel="external">www.pwabuilder.com</a>，回头有时间我也打算写一篇关于 PWA 的文章~</p>
<h2 id="Jest-20"><a href="#Jest-20" class="headerlink" title="Jest 20"></a>Jest 20</h2><p>先科普一下，<a href="http://facebook.github.io/jest/" target="_blank" rel="external">Jest</a> 是facebook出的一个自动化测试工具，用来跑单测的。</p>
<p>新版的 Creat React App 使用的也是新版的 Jest，20版本的 Jest 包含了许多改进，具体有哪些修改自己看<a href="http://facebook.github.io/jest/blog/2017/05/06/jest-20-delightful-testing-multi-project-runner.html" target="_blank" rel="external">文档</a>吧。</p>
<p>现在 Create React App 只需要做少量 Jest 的配置就可以生成覆盖率报告了。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-04.gif" alt="whats-new-in-create-react-app-04"></p>
<h2 id="动态import-代码分割"><a href="#动态import-代码分割" class="headerlink" title="动态import()代码分割"></a>动态import()代码分割</h2><p>保持应用初始化最小下载量和按需加载的重要性我就不说了哈，其实上个版本的 Create React App 也支持代码分割，不过是基于 webpack 的 require.ensure() 特性，这使得这部分代码没法通过 Jest 的测试。</p>
<p>在这个版本的 Create React App 中，我们加入了对未来web标准中 <a href="http://2ality.com/2017/01/import-operator.html#loading-code-on-demand" target="_blank" rel="external">动态 import()</a> 提案的支持，我建议你使用 import() 来延迟加载非常用组件。巧的是，上期的文章里也涉及到了这个问题，咱们来看看 Create React App 中的解决方案吧：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-05.gif" alt="whats-new-in-create-react-app-05"></p>
<h2 id="更好的控制台输出"><a href="#更好的控制台输出" class="headerlink" title="更好的控制台输出"></a>更好的控制台输出</h2><p>新版的 Create React App 改善了控制台的输出。举个例子，当你启动测试服务时，新版的 Create React App 除了会显示本地地址之外，还会显示局域网ip地址，这样你就能更快的用你的手机测试应用了，总之就是更注重细节了吧……╮(￣▽￣)╭</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-06.png" alt="whats-new-in-create-react-app-06"></p>
<h2 id="更多的特性"><a href="#更多的特性" class="headerlink" title="更多的特性"></a>更多的特性</h2><p>上面描述的其实只是新特性中的一小部分，这个版本中还包含了更多的特性，有兴趣的可以看看这个版本的 <a href="https://github.com/facebookincubator/create-react-app/releases/tag/v1.0.0" target="_blank" rel="external">changelog</a></p>
<p>好的那么由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话说玩儿react的同学可能都知道&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;这个项目吧（不知道的戳&lt;a href=&quot;http://www.jianshu.com/p/dd4cee273bed&quot;&gt;这里&lt;/a&gt;了解，这是来自Facebook官方的零配置命令行工具，能够帮你自动创建基于Webpack的最简易的React项目模板）。话说今天看期刊的时候发现了一篇react的官方blog更新了一篇叫&lt;a href=&quot;https://facebook.github.io/react/blog/2017/05/18/whats-new-in-create-react-app.html&quot;&gt;What’s New in Create React App&lt;/a&gt;的博客，随手翻了下发现 Create React App 这个项目居然也更新新版本了？！而且还添加进来很多有趣的功能。我半翻译半解读一下这篇文章，咱们看看有哪些有趣的新功能吧。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>闲扯react组件动态加载机制 -- webpack打包方案</title>
    <link href="http://brooch.me/2017/05/26/react-component-dynamic-loading-2/"/>
    <id>http://brooch.me/2017/05/26/react-component-dynamic-loading-2/</id>
    <published>2017-05-26T06:42:00.000Z</published>
    <updated>2017-05-26T15:22:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次写的文章被朋友吐槽看不懂了……好吧，这次我们继续说说动态加载组件的打包方案，就算是狗尾续狗，他自己挖的坑填平吧。</p>
<a id="more"></a>
<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>先总结下上次的文章，其实我上次写的那些，归结起来就是一点：</p>
<p>在用react开发应用时，如果想要动态加载子组件，只需要在componentDidMount或者componentWillReceiveProps中加入异步获取组件的逻辑就可以实现了。再进一次，可以把这个功能单独抽成一个专门做加载的组件。</p>
<h2 id="webpack打包"><a href="#webpack打包" class="headerlink" title="webpack打包"></a>webpack打包</h2><p>上篇文章的最后我也说了，之前实现的只是代码逻辑，要想真正用到生产环境，还得过构建打包那一关……说到打包，虽然市面上打包工具不少，不过基本上现在都是用webpack了吧。</p>
<p>根据之前的预测，直接使用System.import()来替换里面的require就可以实现功能了。需要注意的是，根据webpack文档中的描述<a href="https://doc.webpack-china.org/guides/code-splitting-async/#-import-" target="_blank" rel="external">动态引入：import()</a>，import不能支持完全的动态语句，至少要给他一个范围。所以需要将原来使用变量的语句改为一个拼接的路径，类似下面这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "loader" */</span> <span class="string">`./<span class="subst">$&#123;componentName&#125;</span>`</span>)</div><div class="line">    .then(<span class="function"><span class="params">Component</span> =&gt;</span> &#123;</div><div class="line">        \\...</div><div class="line">    &#125;)</div><div class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">        \\...</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>这样webpack在打包时，会将这个路径下所有的文件都作为可能被异步加载chunk来打包。所以最好在目录上做规范，将需要异步加载的组件放到一个特定的目录下，避免打包的时候生成冗余文件。</p>
<h2 id="随之而来的问题"><a href="#随之而来的问题" class="headerlink" title="随之而来的问题"></a>随之而来的问题</h2><p>虽然打包的问题解决了，但是随之也暴露了问题。由于webpack打包是基于入口的，不同入口之间是独立的，而用import拆分出来的chunk是无入口的，所以webpack认为他们之间并没有联系，也就不会提取他们之间的公共内容。</p>
<p>比如我写的demo，具体的引用关系如下图</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/react-component-dynamic-loading-01.jpg" alt="01"></p>
<p>最后打包出来的动态加载的组件例会很多重复的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">chunk &#123;0&#125; page2.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/Page.css</div><div class="line">    css-loader/lib/css-base.js</div><div class="line">    style-loader/lib/addStyles.js</div><div class="line">    style-loader/lib/urls.js</div><div class="line">    containers/LoadComponent.js</div><div class="line">    pages/PageB.js</div><div class="line">    styles/Page.css</div><div class="line"></div><div class="line">chunk &#123;1&#125; page0.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/Page.css</div><div class="line">    css-loader/lib/css-base.js</div><div class="line">    style-loader/lib/addStyles.js</div><div class="line">    style-loader/lib/urls.js</div><div class="line">    containers/LoadComponent.js</div><div class="line">    pages/PageA.js</div><div class="line">    styles/Page.css</div><div class="line">    </div><div class="line">chunk &#123;2&#125; component4.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleB.css</div><div class="line">    components/ComponentC.js</div><div class="line">    lib/BaseComponent.js</div><div class="line">    styles/StyleB.css</div><div class="line"></div><div class="line">chunk &#123;3&#125; component2.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleA.css</div><div class="line">    components/ComponentB.js</div><div class="line">    lib/BaseComponent.js</div><div class="line">    styles/StyleA.css</div><div class="line">    </div><div class="line">chunk &#123;4&#125; component0.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleA.css</div><div class="line">    components/ComponentA.js</div><div class="line">    lib/BaseComponent.js</div><div class="line">    styles/StyleA.css</div><div class="line"></div><div class="line">chunk &#123;5&#125; index.entry.js</div><div class="line">    react-dom/index.js</div><div class="line">    react-hot-loader/patch.js</div><div class="line">    react/react.js</div><div class="line">    strip-ansi/index.js</div><div class="line">    url/url.js</div><div class="line">    containers/App.js</div><div class="line">    index.js</div><div class="line">    stores/dataStore.js</div></pre></td></tr></table></figure>
<p>这个时候就得用CommonsChunkPlugin来优化打包结果了。需要注意的是，由于page和comonpent都是异步加载的，没有入口，所以配置CommonsChunkPlugin的时候需要指定引用了异步加载chunk的入口，并加上<code>children:true</code>。另外异步加载chunk里面如果还有有异步加载的chunk需要优化，则需要把父级的chunk也设为入口，再用CommonsChunkPlugin优化。配置类似这样如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    entry: &#123;</div><div class="line">        <span class="attr">index</span>: <span class="string">'./index'</span>,</div><div class="line">        <span class="attr">pageA</span>: <span class="string">'./pages/PageA'</span>,</div><div class="line">        <span class="attr">pageB</span>: <span class="string">'./pages/PageB'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//...</span></div><div class="line">    plugins: [</div><div class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">'index'</span>,</div><div class="line">            <span class="attr">children</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">async</span>: <span class="literal">true</span></div><div class="line">        &#125;),</div><div class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">            <span class="attr">names</span>: [<span class="string">'pageA'</span>, <span class="string">'pageB'</span>],</div><div class="line">            <span class="attr">children</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">async</span>: <span class="literal">true</span></div><div class="line">        &#125;),</div><div class="line">    ]</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加上<code>async: true</code>的配置之后，生成的公共chunk也会用异步的方式加载进来，这样就能完全的实现动态加载了~</p>
<p>最后打包出来的文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">chunk &#123;0&#125; component4.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleB.css</div><div class="line">    components/ComponentC.js</div><div class="line">    styles/StyleB.css</div><div class="line"></div><div class="line">chunk &#123;1&#125; component2.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleA.css</div><div class="line">    components/ComponentB.js</div><div class="line">    styles/StyleA.css</div><div class="line"></div><div class="line">chunk &#123;2&#125; component0.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleA.css</div><div class="line">    components/ComponentA.js</div><div class="line">    styles/StyleA.css</div><div class="line"></div><div class="line">chunk &#123;3&#125; 3.bundle .js</div><div class="line">    lib/BaseComponent.js</div><div class="line"></div><div class="line">chunk &#123;4&#125; 4.bundle .js</div><div class="line">    css-loader/index.js?modules!./styles/Page.css</div><div class="line">    css-loader/lib/css-base.js</div><div class="line">    style-loader/lib/addStyles.js</div><div class="line">    style-loader/lib/urls.js</div><div class="line">    components lazy recursive ^\.\/.*$</div><div class="line">    containers/LoadComponent.js</div><div class="line">    styles/Page.css</div><div class="line"></div><div class="line">chunk &#123;5&#125; page2.bundle.js</div><div class="line">    pages/PageB.js</div><div class="line"></div><div class="line">chunk &#123;6&#125; page0.bundle.js</div><div class="line">    pages/PageA.js</div><div class="line"></div><div class="line">chunk &#123;7&#125; index.entry.js</div><div class="line">    mobx-react/index.js</div><div class="line">    react-hot-loader/patch.js</div><div class="line">    react/react.js</div><div class="line">    strip-ansi/index.js</div><div class="line">    url/url.js</div><div class="line">    containers/App.js</div><div class="line">    index.js</div><div class="line">    stores/dataStore.js</div><div class="line"></div><div class="line">chunk &#123;8&#125; pageB.entry.js</div><div class="line">    mobx-react/index.js</div><div class="line">    react-dom/index.js</div><div class="line">    react/react.js</div><div class="line">    strip-ansi/index.js</div><div class="line">    url/url.js</div><div class="line">    containers/LoadComponent.js</div><div class="line">    pages/PageB.js</div><div class="line">    styles/Page.css</div><div class="line"></div><div class="line">chunk &#123;9&#125; pageA.entry.js</div><div class="line">    mobx-react/index.js</div><div class="line">    react-dom/index.js</div><div class="line">    react/react.js</div><div class="line">    strip-ansi/index.js</div><div class="line">    url/url.js</div><div class="line">    containers/LoadComponent.js</div><div class="line">    pages/PageA.js</div><div class="line">    styles/Page.css</div></pre></td></tr></table></figure>
<p>可以看到3号chunk是component的公共模块，4号chunk是page的公共模块，8号chunk和9号chunk是设置了入口后生成的冗余文件。</p>
<p>可能有人注意到component的里引用的css文件并没有提取出来，这是因为并不是所有的component chunk都引用了它造成的。如果想要把他也提出来，设置一下CommonsChunkPlugin的minChunks属性就行了。</p>
<p>具体的在项目中使用的时候，需要根据业务手动去调整入口配置和CommonsChunkPlugin里的参数了，要想做到完全自动化，CommonsChunkPlugin是支持不了，需要开发新的webpack插件才行。至于怎么开发webpack插件，这个不在本次文章的范畴里，以后有时间了在专门开新坑说明吧。</p>
<p>最后附上我自己做的<a href="https://github.com/81735595/react-component-dynamic-loading/tree/master/webpack" target="_blank" rel="external">demo</a>，clone下来之后 npm install &amp;&amp; npm start 就能跑起来了。这次算是有示例有真相了吧？就在这儿晒~(￣▽￣)~*</p>
<p>好的那么由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次写的文章被朋友吐槽看不懂了……好吧，这次我们继续说说动态加载组件的打包方案，就算是狗尾续狗，他自己挖的坑填平吧。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
      <category term="webpack" scheme="http://brooch.me/tags/webpack/"/>
    
      <category term="dynamic load" scheme="http://brooch.me/tags/dynamic-load/"/>
    
      <category term="CommonsChunkPlugin" scheme="http://brooch.me/tags/CommonsChunkPlugin/"/>
    
  </entry>
  
  <entry>
    <title>闲扯react组件动态加载机制</title>
    <link href="http://brooch.me/2017/05/19/react-component-dynamic-loading-1/"/>
    <id>http://brooch.me/2017/05/19/react-component-dynamic-loading-1/</id>
    <published>2017-05-19T08:33:12.000Z</published>
    <updated>2017-05-26T06:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>话说之前老写vue的源码有点乏味，今天咱们扯点儿别的。之前在微信群里看到大家聊起react组件动态加载，貌似都没有什么好的解决方案呢，正好最近一直忙着写java，好久没折腾react的代码了，借这个机会捡捡以前的技能，不然都要忘光了……</p>
<a id="more"></a>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>之前在群里聊的时候也没看到有人说起核心的痛点，所以究竟在实际应用中会有啥问题我也不知道 (;￢＿￢) ……所以关于问题的分析，其实都是我脑补出来的，所以大家不要当真，全当看热闹吧……</p>
<p>分析之前，先确定下目标，我的目标是简单实现react组件动态加载的机制。既然是要先串通机制，细节和环境配置就一切从简，后续再考虑实际使用和易用性。</p>
<p>接下来分析问题，说到react组件动态加载，从字面上看可以分为两部分“react组件”和“动态加载”。动态加载其实老早就有就解决方案了，之前打包工具还没流行起来的时候，就有各种五花八门的库来解这问题，requirejs、seajs、YUI Loader啥的，所以这个问题用第三方库应该就能搞定。</p>
<p>然后，跟react组件联系到一起，如何在加载完成后替换组件是个问题。其实这个问题也好解，因为react的组件可以返回新组件，所以做个透传参数的加载器应该就可以了。</p>
<p>另外，现在想开发react的程序，webpack+es6+jsx也算是标配了吧。如何用webpack配合打包也是个问题，要把需要异步加载的都生成chunk。还得搭建一套构建环境……毕竟我的目标是实现机制，所以打包这部分就先不考虑，环境配置也省略，直接写浏览器可执行的脚本。</p>
<p>好的，拉个list：</p>
<ul>
<li>动态加载问题 – 使用requirejs</li>
<li>react组件替换 – 做个加载器组件</li>
<li>webpack打包 – 后续考虑</li>
<li>环境问题 – 先不使用jsx，不写浏览器不能直接运行的代码，公共库用unpkg加载，使用creat-react-class模块创建react组件构造函数</li>
</ul>
<p>ok，可以开始了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>之前列出的四个问题，真正需要解决的只有第二个，所以设计一个加载器组件，其实就能实现react组件动态加载的机制了吧……</p>
<p>调用形式应该像下面这样，在标签上指定要加载的组件名，另外，被调用的组件也会需要设置属性，所以加载器也得接收。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">React.createElement(Loader, &#123;</div><div class="line">    <span class="attr">component</span>: <span class="string">'A'</span>,</div><div class="line">    <span class="attr">propA</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">propB</span>: <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 用jsx写应该是下面这样的</span></div><div class="line">&lt;Loader component=<span class="string">'A'</span> propA=&#123;<span class="number">1</span>&#125; propB=&#123;<span class="literal">true</span>&#125;/&gt;</div></pre></td></tr></table></figure>
<p>Loader内部，首先要有个地方记录已经加载了的组件，如果组件已经加载，就直接调用，如果没加载，就先显示loading并开始加载组件，加载完成后调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把记录已加载组件的变量设为公共变量，为了能在多个实例之间共享</span></div><div class="line"><span class="keyword">var</span> componentList = &#123;&#125;</div><div class="line">createReactClass(&#123;</div><div class="line">    <span class="attr">displayName</span>:<span class="string">'Loader'</span>,</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> component = <span class="keyword">this</span>.props.component</div><div class="line">        <span class="keyword">if</span> (componentList[component]) &#123;</div><div class="line">            <span class="keyword">return</span> React.createElement(componentList[component], <span class="keyword">this</span>.props);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            getComponent(component)</div><div class="line">            <span class="keyword">return</span> React.createElement(div, <span class="literal">null</span>, <span class="string">'loading……'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 用es6写应该是这样的，没错，我就是想证明我会写但是我懒…… (￣.￣)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loader</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props) &#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">    &#125;</div><div class="line">    render () &#123;</div><div class="line">        <span class="keyword">let</span> component = &#123;<span class="keyword">this</span>.props&#125;</div><div class="line">        <span class="keyword">if</span> (componentList[component]) &#123;</div><div class="line">            <span class="keyword">return</span> &lt;componentList[component] &#123;...this.props&#125;/&gt;;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 这个函数里面加载组件</div><div class="line">            getComponent(component)</div><div class="line">            return &lt;div&gt;loading……&lt;/div&gt;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大框架有了，继续细化。虽然上面写了加载组件的函数，但是在加载组件之后需要重新触发加载器的渲染，这就需要设置组件的state，所以必须要给加载器添加state属性，用来标记当前显示的组件，并且在getComponent对state进行设置，创建组件的地方也应该改成用state的属性创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">createReactClass(&#123;</div><div class="line">    <span class="attr">displayName</span>:<span class="string">'Loader'</span>,</div><div class="line">    <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">cur</span>: <span class="string">''</span></div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getComponent</span>: <span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</div><div class="line">        <span class="built_in">require</span>([component], (Component) =&gt; &#123;</div><div class="line">            componentList[component] = Component</div><div class="line">            <span class="keyword">this</span>.setState(&#123;</div><div class="line">                <span class="attr">cur</span>: Component</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> component = <span class="keyword">this</span>.props.component</div><div class="line">        <span class="keyword">if</span> (componentList[component]) &#123;</div><div class="line">            <span class="keyword">return</span> React.createElement(<span class="keyword">this</span>.state.cur, <span class="keyword">this</span>.props);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.getComponent(component)</div><div class="line">            <span class="keyword">return</span> React.createElement(div, <span class="literal">null</span>, <span class="string">'loading……'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>接着问题就来了，react里setState会触发render，而上面render里getComponent又会触发setState，会造成死循环，所以要给他换个地方，react的组件运行时一共四个，constructor、componentWillMount、render、componentDidMount，render不能写，文档上说componentWillMount对于web runtime没屌用，所以只能在constructor和componentDidMount里面选了，其实放到哪个里都行，但是constructor是用来初始化组件的，从含以上看，我觉得放componentDidMount里比较合适，官方文档上也说componentDidMount是用来加载异步数据的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">createReactClass(&#123;</div><div class="line">    <span class="attr">displayName</span>:<span class="string">'Loader'</span>,</div><div class="line">    <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">cur</span>: <span class="string">''</span></div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getComponent</span>: <span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</div><div class="line">        <span class="built_in">require</span>([component], (Component) =&gt; &#123;</div><div class="line">            componentList[component] = Component</div><div class="line">            <span class="keyword">this</span>.setState(&#123;</div><div class="line">                <span class="attr">cur</span>: Component</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">componentDidMount</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.getComponent(<span class="keyword">this</span>.props.component)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (componentList[<span class="keyword">this</span>.props.component]) &#123;</div><div class="line">            <span class="keyword">return</span> React.createElement(<span class="keyword">this</span>.state.cur, <span class="keyword">this</span>.props);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> React.createElement(div, <span class="literal">null</span>, <span class="string">'loading……'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>呃……貌似这样就行了呢……至少大体的机制应该就是这样的吧，还有些细节需要完善，比如props变化的时候也切加载控间，现在这个加载器只能加载一次控件，其实只要在属性变化的运行时里加上getComponent函数就行了。再比如减少控件渲染次数，控价加载失败的异常处理之类的，详细的就不说了，自己体会吧，我把我练习的代码传到github上了，可以看看吐吐槽</p>
<p><a href="https://github.com/81735595/react-component-dynamic-loading" target="_blank" rel="external">https://github.com/81735595/react-component-dynamic-loading</a></p>
<p>用npm start就能启动了。</p>
<h2 id="关于打包"><a href="#关于打包" class="headerlink" title="关于打包"></a>关于打包</h2><p>感觉在代码上直接用import替换require就能用webpack2打包了，但是我总觉得打包是个大头儿，有好多坑等着……所以等以后有时间了再补一次打包脚本联系好了。</p>
<p>好的那么由于时间不足，本期的流水账就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话说之前老写vue的源码有点乏味，今天咱们扯点儿别的。之前在微信群里看到大家聊起react组件动态加载，貌似都没有什么好的解决方案呢，正好最近一直忙着写java，好久没折腾react的代码了，借这个机会捡捡以前的技能，不然都要忘光了……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(5)</title>
    <link href="http://brooch.me/2017/05/05/vue-source-notes-5/"/>
    <id>http://brooch.me/2017/05/05/vue-source-notes-5/</id>
    <published>2017-05-05T12:00:29.000Z</published>
    <updated>2017-05-05T13:45:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>五一好好给自己放了个假，去成都玩儿了几天。话说成都的生活可真是悠闲，搞得我都向去成都买房定居了~而且成都的吃的可真是，（¯﹃¯）…… 一想到猪肉锅盔和冒节子肥肠粉我口水就开始往外涌……咳咳……言归正传，上次说这次要读core的全部全局api和config，下面咱们就开始。</p>
<h2 id="use-js"><a href="#use-js" class="headerlink" title="use.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/use.js" target="_blank" rel="external">use.js</a></h2><p>这个文件是用来给构造函数Vue挂载use方法用的，逻辑很简单。use方法是用来安装插件用的，<a href="https://cn.vuejs.org/v2/api/?#Vue-use" target="_blank" rel="external">对应文档</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: Function | Object</span>) </span>&#123;</div><div class="line">    <span class="comment">// 安装过的控件不再安装</span></div><div class="line">    <span class="comment">/* istanbul ignore if */</span></div><div class="line">    <span class="keyword">if</span> (plugin.installed) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 组织要传给控件的参数，Vue构造函数作为第一个参数</span></div><div class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line">    args.unshift(<span class="keyword">this</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 根据plugin的类型使用不同调用方法，文档中只介绍了使用install属性来启动插件的方法，</span></div><div class="line">    <span class="comment">// 如果plugin本身就是个函数，则使用这个函数来安装插件</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">'function'</span>) &#123;</div><div class="line">      plugin.install.apply(plugin, args)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) &#123;</div><div class="line">      plugin.apply(<span class="literal">null</span>, args)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 给安装过的控件加锁</span></div><div class="line">    plugin.installed = <span class="literal">true</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="mixin-js"><a href="#mixin-js" class="headerlink" title="mixin.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/mixin.js" target="_blank" rel="external">mixin.js</a></h2><p>mixin的逻辑主要隐藏在mergeOptions函数里，之前咱么你说过，这个函数是组件实例化和继承的核心方法，其实就是根据不同的属性进行合并，有规定的属性按照规定的规则，没规定的属性直接覆盖。等到读到 src/core/util/options.js 时再详细解读 mergeOptions 函数。<a href="https://cn.vuejs.org/v2/api/?#Vue-mixin" target="_blank" rel="external">对应文档</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mergeOptions &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  <span class="comment">// 挂载mixin方法</span></div><div class="line">  Vue.mixin = <span class="function"><span class="keyword">function</span> (<span class="params">mixin: Object</span>) </span>&#123;</div><div class="line">    <span class="comment">// 使用 mergeOptions 函数合并 Vue.options</span></div><div class="line">    <span class="keyword">this</span>.options = mergeOptions(<span class="keyword">this</span>.options, mixin)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="extend-js"><a href="#extend-js" class="headerlink" title="extend.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/.js" target="_blank" rel="external">extend.js</a></h2><p>extend本身是用来创建子类的，内部使用mergeOptions来合并属性。<a href="https://cn.vuejs.org/v2/api/?#Vue-extend" target="_blank" rel="external">对应文档</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; warn, extend, mergeOptions &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"><span class="keyword">import</span> &#123; defineComputed, proxy &#125; <span class="keyword">from</span> <span class="string">'../instance/state'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initExtend</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 初始化Vue的cid，用来做Vue构造函数和其子类的缓存的索引，每个Vue构造函数的子类也都有cid</div><div class="line">   */</div><div class="line">  Vue.cid = <span class="number">0</span></div><div class="line">  <span class="keyword">let</span> cid = <span class="number">1</span></div><div class="line"></div><div class="line">  <span class="comment">// 挂载extend方法</span></div><div class="line">  Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: Object</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">    <span class="comment">// 子类的options的容错处理</span></div><div class="line">    extendOptions = extendOptions || &#123;&#125;</div><div class="line">    <span class="keyword">const</span> Super = <span class="keyword">this</span></div><div class="line">    <span class="keyword">const</span> SuperId = Super.cid</div><div class="line">    <span class="comment">// 取缓存，缓存是绑在options对象上的，就是说同样的父类、同样的配置，就会走缓存生成相同的子类。</span></div><div class="line">    <span class="keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</div><div class="line">    <span class="keyword">if</span> (cachedCtors[SuperId]) &#123;</div><div class="line">      <span class="keyword">return</span> cachedCtors[SuperId]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> name = extendOptions.name || Super.options.name</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (!<span class="regexp">/^[a-zA-Z][\w-]*$/</span>.test(name)) &#123;</div><div class="line">        warn(</div><div class="line">          <span class="string">'Invalid component name: "'</span> + name + <span class="string">'". Component names '</span> +</div><div class="line">          <span class="string">'can only contain alphanumeric characters and the hyphen, '</span> +</div><div class="line">          <span class="string">'and must start with a letter.'</span></div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 定义子类的构造函数</span></div><div class="line">    <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">      <span class="comment">// 后面会将父类的prototype接到子类的上，就可以调用Vue的_init方法了</span></div><div class="line">      <span class="keyword">this</span>._init(options)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 实现类的继承</span></div><div class="line">    Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</div><div class="line">    Sub.prototype.constructor = Sub</div><div class="line">    Sub.cid = cid++</div><div class="line">    Sub.options = mergeOptions(</div><div class="line">      Super.options,</div><div class="line">      extendOptions</div><div class="line">    )</div><div class="line">    Sub[<span class="string">'super'</span>] = Super</div><div class="line"></div><div class="line">    <span class="comment">// 初始化子类的props属性，这里使用了一个函数来封装遍历的过程</span></div><div class="line">    <span class="comment">// initProps里对options.props的每个属都进行了初始化</span></div><div class="line">    <span class="keyword">if</span> (Sub.options.props) &#123;</div><div class="line">      initProps(Sub)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 与initProps类似</span></div><div class="line">    <span class="keyword">if</span> (Sub.options.computed) &#123;</div><div class="line">      initComputed(Sub)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 让子类也能使用extend、mixin、use方法</span></div><div class="line">    Sub.extend = Super.extend</div><div class="line">    Sub.mixin = Super.mixin</div><div class="line">    Sub.use = Super.use</div><div class="line"></div><div class="line">    <span class="comment">// config._assetTypes里面是所有的控件类型，这些也都复制到子类上</span></div><div class="line">    config._assetTypes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">      Sub[type] = Super[type]</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// 允许递归查找自己</span></div><div class="line">    <span class="keyword">if</span> (name) &#123;</div><div class="line">      Sub.options.components[name] = Sub</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 保存对super和自己当前的options的引用，实例化的时候用于检查options是否更新了</span></div><div class="line">    Sub.superOptions = Super.options</div><div class="line">    Sub.extendOptions = extendOptions</div><div class="line">    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</div><div class="line"></div><div class="line">    <span class="comment">// 添加缓存</span></div><div class="line">    cachedCtors[SuperId] = Sub</div><div class="line">    <span class="keyword">return</span> Sub</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// initProps 和 initComputed 的操作类似，通过代理调用Object.defineProperty</span></div><div class="line"><span class="comment">// 简单看了下代理的逻辑，感觉并没有减少Object.defineProperty的调用次数</span></div><div class="line"><span class="comment">// 只是使用一个固定的对象来减少生成对象的数量</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">Comp</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> props = Comp.options.props</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</div><div class="line">    proxy(Comp.prototype, <span class="string">`_props`</span>, key)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">Comp</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> computed = Comp.options.computed</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</div><div class="line">    defineComputed(Comp.prototype, key, computed[key])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="assets-js"><a href="#assets-js" class="headerlink" title="assets.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/assets.js" target="_blank" rel="external">assets.js</a></h2><p>asset貌似应该翻译为资源，这个文件主要是用来初始化Vue的资源的，所谓的资源就是类似directive、filter、component之类的控件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; warn, isPlainObject &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initAssetRegisters</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  </div><div class="line">  <span class="comment">// 注册Vue默认支持的资源，就是注册了 Vue.directive、Vue.component、Vue.filter方法</span></div><div class="line">  config._assetTypes.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</div><div class="line">    Vue[type] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line">      id: string,</div><div class="line">      definition: Function | Object</div><div class="line">    ): <span class="title">Function</span> | <span class="title">Object</span> | <span class="title">void</span> &#123;</div><div class="line">      <span class="keyword">if</span> (!definition) &#123;</div><div class="line">        <span class="comment">// 获取资源</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.options[type + <span class="string">'s'</span>][id]</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 注册资源</span></div><div class="line">        <span class="comment">/* istanbul ignore if */</span></div><div class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">          <span class="keyword">if</span> (type === <span class="string">'component'</span> &amp;&amp; config.isReservedTag(id)) &#123;</div><div class="line">            warn(</div><div class="line">              <span class="string">'Do not use built-in or reserved HTML elements as component '</span> +</div><div class="line">              <span class="string">'id: '</span> + id</div><div class="line">            )</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 对不同资源进行不同处理</span></div><div class="line">        <span class="keyword">if</span> (type === <span class="string">'component'</span> &amp;&amp; isPlainObject(definition)) &#123;</div><div class="line">          definition.name = definition.name || id</div><div class="line">          definition = <span class="keyword">this</span>.options._base.extend(definition)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (type === <span class="string">'directive'</span> &amp;&amp; <span class="keyword">typeof</span> definition === <span class="string">'function'</span>) &#123;</div><div class="line">          definition = &#123; <span class="attr">bind</span>: definition, <span class="attr">update</span>: definition &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.options[type + <span class="string">'s'</span>][id] = definition</div><div class="line">        <span class="keyword">return</span> definition</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>全局api这部分就算是看完了，总的来说这部分逻辑都不复杂，主要学习的还是机制吧，插件的机制，继承的机制，资源注册获取的机制，基本上算是教科书式的了吧，自己开发中都可以借鉴到的。</p>
<h2 id="config-js"><a href="#config-js" class="headerlink" title="config.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/config.js" target="_blank" rel="external">config.js</a></h2><p>core/config.js 文件里面记录了所有Vue可使用的配置，有些在api文档上查的到，有的则查不到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @flow */</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; no, noop, identity &#125; <span class="keyword">from</span> <span class="string">'shared/util'</span></div><div class="line"></div><div class="line"><span class="comment">// 这部分是给flow检查Config中每个属性的类型用的，简单易懂，同事标注了属性是给哪部分用的</span></div><div class="line"><span class="keyword">export</span> type Config = &#123;</div><div class="line">  <span class="comment">// user(用户可配置的属性)</span></div><div class="line">  optionMergeStrategies: &#123; [key: string]: <span class="built_in">Function</span> &#125;;</div><div class="line">  silent: boolean;</div><div class="line">  productionTip: boolean;</div><div class="line">  performance: boolean;</div><div class="line">  devtools: boolean;</div><div class="line">  errorHandler: ?<span class="function">(<span class="params">err: <span class="built_in">Error</span>, vm: Component, info: string</span>) =&gt;</span> <span class="keyword">void</span>;</div><div class="line">  ignoredElements: <span class="built_in">Array</span>&lt;string&gt;;</div><div class="line">  keyCodes: &#123; [key: string]: number | <span class="built_in">Array</span>&lt;number&gt; &#125;;</div><div class="line">  <span class="comment">// platform(给不同平台用的属性)</span></div><div class="line">  isReservedTag: <span class="function">(<span class="params">x?: string</span>) =&gt;</span> boolean;</div><div class="line">  parsePlatformTagName: <span class="function">(<span class="params">x: string</span>) =&gt;</span> string;</div><div class="line">  isUnknownElement: <span class="function">(<span class="params">x?: string</span>) =&gt;</span> boolean;</div><div class="line">  getTagNamespace: <span class="function">(<span class="params">x?: string</span>) =&gt;</span> string | <span class="keyword">void</span>;</div><div class="line">  mustUseProp: <span class="function">(<span class="params">tag: string, type: ?string, name: string</span>) =&gt;</span> boolean;</div><div class="line">  <span class="comment">// internal(内部用的属性)</span></div><div class="line">  _assetTypes: <span class="built_in">Array</span>&lt;string&gt;;</div><div class="line">  _lifecycleHooks: <span class="built_in">Array</span>&lt;string&gt;;</div><div class="line">  _maxUpdateCount: number;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> config: Config = &#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 用户属性在官方文档中都有详细的说明，我就不做过多解释了，简单翻译一下</div><div class="line">   * 自定义合并策略 (used in core/util/options)</div><div class="line">   */</div><div class="line">  optionMergeStrategies: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 日志的控制开关</div><div class="line">   */</div><div class="line">  silent: <span class="literal">false</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 启东市是否显示生产模式的提示信息，这个是根据构造时测参数决定的</div><div class="line">   */</div><div class="line">  productionTip: process.env.NODE_ENV !== <span class="string">'production'</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 是否使用调试工具</div><div class="line">   */</div><div class="line">  devtools: process.env.NODE_ENV !== <span class="string">'production'</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 是否显示性能数据</div><div class="line">   */</div><div class="line">  performance: process.env.NODE_ENV !== <span class="string">'production'</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 异常处理接口，如果使用官方文档上有</div><div class="line">   */</div><div class="line">  errorHandler: <span class="literal">null</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 忽略某些自定义元素</div><div class="line">   */</div><div class="line">  ignoredElements: [],</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 给 v-on 自定义键位别名</div><div class="line">   */</div><div class="line">  keyCodes: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 检查标签是否是保留标签的方法，各个平台之间不一样，没错，需要是一个返回true、false的方法</div><div class="line">   * 具体检查方法可以在 src/platforms/ 里面找</div><div class="line">   */</div><div class="line">  isReservedTag: no,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 检查标签是否是未知标签</div><div class="line">   */</div><div class="line">  isUnknownElement: no,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取标签的命名空间，也可以理解为获取标签的类型吧，html、svg之类的</div><div class="line">   */</div><div class="line">  getTagNamespace: noop,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 解析标签在平台中的名字……貌似对标签名做映射的</div><div class="line">   */</div><div class="line">  parsePlatformTagName: identity,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 检查标签必须包含的属性，比如input标签必须有value属性之类的……</div><div class="line">   */</div><div class="line">  mustUseProp: no,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 所有支持的资源的列表</div><div class="line">   */</div><div class="line">  _assetTypes: [</div><div class="line">    <span class="string">'component'</span>,</div><div class="line">    <span class="string">'directive'</span>,</div><div class="line">    <span class="string">'filter'</span></div><div class="line">  ],</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 所有生命周期的列表</div><div class="line">   */</div><div class="line">  _lifecycleHooks: [</div><div class="line">    <span class="string">'beforeCreate'</span>,</div><div class="line">    <span class="string">'created'</span>,</div><div class="line">    <span class="string">'beforeMount'</span>,</div><div class="line">    <span class="string">'mounted'</span>,</div><div class="line">    <span class="string">'beforeUpdate'</span>,</div><div class="line">    <span class="string">'updated'</span>,</div><div class="line">    <span class="string">'beforeDestroy'</span>,</div><div class="line">    <span class="string">'destroyed'</span>,</div><div class="line">    <span class="string">'activated'</span>,</div><div class="line">    <span class="string">'deactivated'</span></div><div class="line">  ],</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 更新数据的最大循环次数</div><div class="line">   */</div><div class="line">  _maxUpdateCount: <span class="number">100</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> config</div></pre></td></tr></table></figure>
<p>这个文件本身是没有逻辑的，而且每个属性都有注释，我就简单翻一下注释。感觉flow只是挺好用的呢，作用和typescript类似，如果不用vscode做编辑器，用flow来代替typescript应该会更简单方便一些，如果用vscode，那么使用typescript应该会更方便。虽然不服，但是大微软只是不鸣则已一鸣惊人，vscode甩了atom不知道多少条街……跑题了跑题了，好的那么由于时间不足，本期笔记就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的力度了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;五一好好给自己放了个假，去成都玩儿了几天。话说成都的生活可真是悠闲，搞得我都向去成都买房定居了~而且成都的吃的可真是，（¯﹃¯）…… 一想到猪肉锅盔和冒节子肥肠粉我口水就开始往外涌……咳咳……言归正传，上次说这次要读core的全部全局api和config，下面咱们就开始。&lt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(4)</title>
    <link href="http://brooch.me/2017/04/21/vue-source-notes-4/"/>
    <id>http://brooch.me/2017/04/21/vue-source-notes-4/</id>
    <published>2017-04-21T05:37:29.000Z</published>
    <updated>2017-05-05T13:43:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，又到了一周一度的deadline……之前几次把杂七杂八的部分读完了，这次终于要开始读vue核心部分的代码了。从之前读过的 src/entries 模块中可以看到，vue核心的代码的大概可以分为 runtime 和 compiler 两部分。runtime 对应 src/core 模块，compiler 对应 src/compiler 模块，这次就从 src/core 模块开始读。</p>
<h2 id="Vue核心模块-core"><a href="#Vue核心模块-core" class="headerlink" title="Vue核心模块 core"></a>Vue核心模块 core</h2><p>这个模块最后输出的就是一个Vue的构造函数，里面包含了组件系统、全局API、vue实例、对象属性监测系统、公共方法、虚拟dom、配置，这些模块。因为各个模块之间都有联系，单拎出来一个个看感觉没法看到全貌呀。所以这次换个方式试试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">|- core</div><div class="line">  |- components</div><div class="line">  |- global-api</div><div class="line">  |- instance</div><div class="line">  |- observer</div><div class="line">  |- util</div><div class="line">  |- vdom</div><div class="line">  |- config.js</div><div class="line">  |- index.js</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>从 src/entries/web-runtime.js 文件中可以看出，Vue 这个构造函数是从 src/core/index.js 导出的，这个文件的代码如下：</p>
<h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/index.js" target="_blank" rel="external">index.js</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./instance/index'</span></div><div class="line"><span class="keyword">import</span> &#123; initGlobalAPI &#125; <span class="keyword">from</span> <span class="string">'./global-api/index'</span></div><div class="line"><span class="keyword">import</span> &#123; isServerRendering &#125; <span class="keyword">from</span> <span class="string">'core/util/env'</span></div><div class="line"></div><div class="line"><span class="comment">// Vue构造函数来自src/core/instance/index.js</span></div><div class="line"><span class="comment">// 通过initGlobalAPI这个函数添加全局api</span></div><div class="line">initGlobalAPI(Vue)</div><div class="line"></div><div class="line"><span class="comment">// 是否运行在服务端的标记，对应文档中的 https://cn.vuejs.org/v2/api/?#vm-isServer</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$isServer'</span>, &#123;</div><div class="line">  <span class="attr">get</span>: isServerRendering</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// __VERSION__ 是在 build/config.js 里面配置的，在构建的时候通过脚本替换为配置里的变量</span></div><div class="line">Vue.version = <span class="string">'__VERSION__'</span></div><div class="line"></div><div class="line"><span class="comment">// 导出Vue构造函数</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure>
<p>Vue.prototype.$isServer 和 Vue.version 比较简单就不展开了，Vue构造函数后面再看，先看全局api吧。</p>
<h3 id="index-js-1"><a href="#index-js-1" class="headerlink" title="index.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/index.js" target="_blank" rel="external">index.js</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; initUse &#125; <span class="keyword">from</span> <span class="string">'./use'</span></div><div class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./mixin'</span></div><div class="line"><span class="keyword">import</span> &#123; initExtend &#125; <span class="keyword">from</span> <span class="string">'./extend'</span></div><div class="line"><span class="keyword">import</span> &#123; initAssetRegisters &#125; <span class="keyword">from</span> <span class="string">'./assets'</span></div><div class="line"><span class="keyword">import</span> &#123; set, del &#125; <span class="keyword">from</span> <span class="string">'../observer/index'</span></div><div class="line"><span class="keyword">import</span> builtInComponents <span class="keyword">from</span> <span class="string">'../components/index'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  warn,</div><div class="line">  extend,</div><div class="line">  nextTick,</div><div class="line">  mergeOptions,</div><div class="line">  defineReactive</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initGlobalAPI</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  <span class="comment">// 首先配置 Vue.config ，在定义时使用了 Object.defineProperty</span></div><div class="line">  <span class="comment">// 所以在设置 Vue.config 的时候是不能直接 Vue.config = &#123;....&#125;这样的，不然会报错，得一项一项设</span></div><div class="line">  <span class="keyword">const</span> configDef = &#123;&#125;</div><div class="line">  configDef.get = <span class="function"><span class="params">()</span> =&gt;</span> config</div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">    configDef.set = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      warn(</div><div class="line">        <span class="string">'Do not replace the Vue.config object, set individual fields instead.'</span></div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(Vue, <span class="string">'config'</span>, configDef)</div><div class="line"></div><div class="line">  <span class="comment">// Vue.util虽然暴露出来了，但是并不是公共api的一部分，所以用的时候要小心点儿</span></div><div class="line">  Vue.util = &#123;</div><div class="line">    <span class="comment">// 下面这些方法都来自 core/util/这个模块，这里先简单说下每个函数的用途，后续展开</span></div><div class="line">    <span class="comment">// 输出错误信息用的，同事还能输出错误组件的名字和对应的vue文件地址</span></div><div class="line">    warn,</div><div class="line">    <span class="comment">// 顾名思义，浅拷贝</span></div><div class="line">    extend,</div><div class="line">    <span class="comment">// 用来合并实例option的，组件实例化和继承的核心方法</span></div><div class="line">    mergeOptions,</div><div class="line">    <span class="comment">// 用来给对象定义响应属性</span></div><div class="line">    defineReactive</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 给实例添加属性，对应 https://cn.vuejs.org/v2/api/?#Vue-set</span></div><div class="line">  Vue.set = set</div><div class="line">  <span class="comment">// 删除实例属性，对应 https://cn.vuejs.org/v2/api/?#Vue-delete</span></div><div class="line">  Vue.delete = del</div><div class="line">  <span class="comment">// 对应 https://cn.vuejs.org/v2/api/?#Vue-nextTick，一个打包执行延迟任务的方法，采用Promise =&gt; MutationObserver =&gt; setTimeout(0)的退化设计</span></div><div class="line">  <span class="comment">// 在读nextTick源码的时候发现几个有意思的点，本来想憋到写 src/core/util 的时候再写的，但是我实在是憋不住了哈哈</span></div><div class="line">  <span class="comment">// 1. 在使用promise的时候，ios里（其实就是safari和uiwebview）如果直接用promise.resolve()触发一个then的话，</span></div><div class="line">  <span class="comment">// 他不会立即执行，运行一个空的setTimeout之后，在就没问题了……相当神奇……</span></div><div class="line">  <span class="comment">// 另外，我发现他的ios判断里没有判断safari，但是safari里也有这个问题，不知道是不是bug……</span></div><div class="line">  <span class="comment">// 2. MutationObserver是通过观测dom元素的变化来触发事件回调，具体替代promise的方法等看到了再详细说吧</span></div><div class="line">  <span class="comment">// 3. 还有一个细节，在执行一批回调的时候，用的是[].length=0来清空数组，而不是空数组赋值的方法，感觉是为了省内存，不用频繁gc</span></div><div class="line">  Vue.nextTick = nextTick</div><div class="line">  <span class="comment">// options用来存定义过的组件的，支持component, directive, filter，支持的组件列表保存在_assetTypes里面</span></div><div class="line">  <span class="comment">// 具体还没有细看，但是感觉是支持扩展的</span></div><div class="line">  Vue.options = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">  config._assetTypes.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</div><div class="line">    Vue.options[type + <span class="string">'s'</span>] = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 用来给所有实例标记base构造函数用的属性</span></div><div class="line">  Vue.options._base = Vue</div><div class="line"></div><div class="line">  <span class="comment">// 挂载keep-alive组件，https://cn.vuejs.org/v2/api/?#keep-alive</span></div><div class="line">  extend(Vue.options.components, builtInComponents)</div><div class="line"></div><div class="line">  <span class="comment">// 挂载 Vue.use 方法</span></div><div class="line">  initUse(Vue)</div><div class="line">  <span class="comment">// 挂载 Vue.mixin 方法</span></div><div class="line">  initMixin(Vue)</div><div class="line">  <span class="comment">// 挂载 Vue.extend 方法</span></div><div class="line">  initExtend(Vue)</div><div class="line">  <span class="comment">// 挂载 Vue.component, Vue.directive, Vue.filter 方法</span></div><div class="line">  initAssetRegisters(Vue)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>全局api的挂载逻辑还算相对简单，Vue的方法挂载每部分都拆成了单独的函数，利用js中Function是对象、可以作为参数的特性、是引用类型等特性，用这种函数来加工Vue构造函数，不知道这算不算装饰模式呢……</p>
<p>另外我发现一个细节，源码中在生成空对象的时候，会用Object.create(null)来生成，具体原因不明，因为这两种方式，除了原型不一样，其他的没区别，因为也见到有使用字面量来生成空对象的，所以会不会是因为是开源项目，开源项目中大量人员参与其中，每个人的编码习惯有差异造成的呢……</p>
<p>好的那么由于时间不足，本期笔记就先写到这里，话说每次只看这么一点儿，我还真是感觉惭愧呢，希望未来可以挤出更多的时间来读吧……如果不出意外的话，maybe可能也许大概下周五会更新吧，下周准备更新config和全部全局api，能不能准时更新，就全看米娜桑点赞转发安利留言的力度了~、</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，又到了一周一度的deadline……之前几次把杂七杂八的部分读完了，这次终于要开始读vue核心部分的代码了。从之前读过的 src/entries 模块中可以看到，vue核心的代码的大概可以分为 runtime 和 compiler 两部分。runtime 对应 src/
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(3)</title>
    <link href="http://brooch.me/2017/04/14/vue-source-notes-3/"/>
    <id>http://brooch.me/2017/04/14/vue-source-notes-3/</id>
    <published>2017-04-14T08:51:35.000Z</published>
    <updated>2017-04-14T08:46:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>啊……写这篇博客的时候我刚上了一宿的线……现在多一个字都不想说了……直接开始吧……</p>
<a id="more"></a>
<h2 id="公共方法模块-shared"><a href="#公共方法模块-shared" class="headerlink" title="公共方法模块 shared"></a>公共方法模块 shared</h2><p>故名思议，shared模块是放所有公共方法的，里面只有 util.js 一个文件。</p>
<h3 id="util-js"><a href="#util-js" class="headerlink" title="util.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/shared/util.js" target="_blank" rel="external">util.js</a></h3><p>util.js一共暴露了23个方法，每个函数都非常基础，第一眼看上去感觉没啥可看的，但是仔细看每个函数会发现，这些函数都很实用，而且正是因为基础，很可能会成为以后面试的考题……</p>
<p>总之过一遍下这些方法吧，记录下我认为有用的知识点，当做事知识储备了：</p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="_toString"></a>_toString</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个函数可以将任意类型的值转为字符串</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_toString</span> (<span class="params">val: any</span>): <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> val == <span class="literal">null</span></div><div class="line">    <span class="comment">// 如果是null就返回空字符串</span></div><div class="line">    ? <span class="string">''</span></div><div class="line">    : <span class="keyword">typeof</span> val === <span class="string">'object'</span></div><div class="line">      <span class="comment">// 如果是object就转成json</span></div><div class="line">      <span class="comment">// 这里比较特殊的是在调用stringify时除了要转换的值，还多传了两个参数，其中第二个参数用来过滤数据，第三个参数用来控制内容的缩进</span></div><div class="line">      ? <span class="built_in">JSON</span>.stringify(val, <span class="literal">null</span>, <span class="number">2</span>)</div><div class="line">      <span class="comment">// 其他的都是用String来转换为字符串，其实跟调用对象的toString是一样的吧？</span></div><div class="line">      : <span class="built_in">String</span>(val)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="toNumber"><a href="#toNumber" class="headerlink" title="toNumber"></a>toNumber</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将传入的值转换为浮点数，如果转换失败就返回传入值</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toNumber</span> (<span class="params">val: string</span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="comment">// 浮点数没加 ",10" ，不知道是不是个隐藏的问题</span></div><div class="line">  <span class="keyword">const</span> n = <span class="built_in">parseFloat</span>(val)</div><div class="line">  <span class="keyword">return</span> <span class="built_in">isNaN</span>(n) ? val : n</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="makeMap"><a href="#makeMap" class="headerlink" title="makeMap"></a>makeMap</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个函数比较有意思，功能有点儿像集合（Set）对象，但是只能存储字符串，最后用来判断值是否已经存在</span></div><div class="line"><span class="comment">// 貌似是用来快速检索某个值是否存在用的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">makeMap</span> (<span class="params"></span></span></div><div class="line">  str: string,</div><div class="line">  expectsLowerCase?: boolean</div><div class="line">): (<span class="params">key: string</span>) =&gt; <span class="title">true</span> | <span class="title">void</span> &#123;</div><div class="line">  <span class="keyword">const</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">  <span class="keyword">const</span> list: <span class="built_in">Array</span>&lt;string&gt; = str.split(<span class="string">','</span>)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line">    map[list[i]] = <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> expectsLowerCase</div><div class="line">    ? <span class="function"><span class="params">val</span> =&gt;</span> map[val.toLowerCase()]</div><div class="line">    : <span class="function"><span class="params">val</span> =&gt;</span> map[val]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isBuiltInTag"><a href="#isBuiltInTag" class="headerlink" title="isBuiltInTag"></a>isBuiltInTag</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成一个用来检索是否是内置标签的函数，用到了之前的makeMap方法</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> isBuiltInTag = makeMap(<span class="string">'slot,component'</span>, <span class="literal">true</span>)</div></pre></td></tr></table></figure>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个工具方法，用来删除数组中匹配到的对象</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">arr: Array&lt;any&gt;, item: any</span>): <span class="title">Array</span>&lt;<span class="title">any</span>&gt; | <span class="title">void</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (arr.length) &#123;</div><div class="line">    <span class="keyword">const</span> index = arr.indexOf(item)</div><div class="line">    <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="hasOwn"><a href="#hasOwn" class="headerlink" title="hasOwn"></a>hasOwn</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对Object.prototype.hasOwnProperty的封装，用来判断对象的属性是否是继承自原型的</span></div><div class="line"><span class="comment">// 顺便复习下instanceof和typeof</span></div><div class="line"><span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof</span></div><div class="line"><span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof</span></div><div class="line"><span class="comment">// 除了三者作用的区别以外，需要注意的是，hasOwnProperty是函数，instanceof和typeof是运算符</span></div><div class="line"><span class="comment">// 其实MDN上写的instanceof是运算符，typeof是操作符，特意查了一下，在英语中操作符和运算符都叫operator，应该可以认为是一个东西吧</span></div><div class="line"><span class="comment">// 与函数的区别在于，一个是符号，一个是有名称的，另外，函数有明确定义的参数表，符号没有</span></div><div class="line"><span class="comment">// 当然，从广义来上来看，任何一个运算符都可看做是一个函数，而它的运算数可看做参数</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hasOwn</span> (<span class="params">obj: Object, key: string</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> hasOwnProperty.call(obj, key)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isPrimitive"><a href="#isPrimitive" class="headerlink" title="isPrimitive"></a>isPrimitive</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断一个值是否是基础类型？字面上看primitive是原始的意思……</span></div><div class="line"><span class="comment">// 总之就是判断传入的参数是否是数字或者字符串</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPrimitive</span> (<span class="params">value: any</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'string'</span> || <span class="keyword">typeof</span> value === <span class="string">'number'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="cached"><a href="#cached" class="headerlink" title="cached"></a>cached</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成一个带缓存的纯函数</span></div><div class="line"><span class="comment">// 就是会把每次函数执行的结果缓存起来</span></div><div class="line"><span class="comment">// 根据纯函数的定义，传入同样的参数值，函数总是求出同样的结果，这样处理之后可以大幅提升函数的运算速度</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cached</span>&lt;<span class="title">F</span>: <span class="title">Function</span>&gt; (<span class="params">fn: F</span>): <span class="title">F</span> </span>&#123;</div><div class="line">  <span class="comment">// 定义缓存对象</span></div><div class="line">  <span class="keyword">const</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">cachedFn</span> (<span class="params">str: string</span>) </span>&#123;</div><div class="line">    <span class="comment">// 根据传入的参数取缓存</span></div><div class="line">    <span class="keyword">const</span> hit = cache[str]</div><div class="line">    <span class="comment">// 检查缓存是否存在，如果存在就直接返回缓存，缓存不存在就运行函数缓存结果</span></div><div class="line">    <span class="keyword">return</span> hit || (cache[str] = fn(str))</div><div class="line">  &#125;: any)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="camelize"><a href="#camelize" class="headerlink" title="camelize"></a>camelize</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将破折号分割的命名修改为驼峰命名</span></div><div class="line"><span class="comment">// 感觉是在解析模板时，将tag name转换为 class name用的</span></div><div class="line"><span class="keyword">const</span> camelizeRE = <span class="regexp">/-(\w)/g</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> camelize = cached((str: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> str.replace(camelizeRE, (_, c) =&gt; c ? c.toUpperCase() : <span class="string">''</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="capitalize"><a href="#capitalize" class="headerlink" title="capitalize"></a>capitalize</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将字符串首字母转换为大写的函数</span></div><div class="line"><span class="comment">// 估计是跟camelize配合一起使用的吧</span></div><div class="line"><span class="comment">// 最后的效果就是：&lt;my-component&gt; ==&gt; MyComponent</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> capitalize = cached((str: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>).toUpperCase() + str.slice(<span class="number">1</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="hyphenate"><a href="#hyphenate" class="headerlink" title="hyphenate"></a>hyphenate</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将驼峰命名再改回中划线命名……(￣.￣)</span></div><div class="line"><span class="comment">// 效果类似于：ABCD =&gt; a-b-c-d</span></div><div class="line"><span class="keyword">const</span> hyphenateRE = <span class="regexp">/([^-])([A-Z])/g</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> hyphenate = cached((str: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> st</div><div class="line">    <span class="comment">// 这里要调用两次replace是因为，如果是 ABCD 这种包含三个连续大写字母的字符串，</span></div><div class="line">    <span class="comment">// 只replace一次会变成A-BC-D这样，需要再replace一次……</span></div><div class="line">    .replace(hyphenateRE, <span class="string">'$1-$2'</span>)</div><div class="line">    .replace(hyphenateRE, <span class="string">'$1-$2'</span>)</div><div class="line">    .toLowerCase()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单实现的bind方法，源码的注释中说比原生的bind快</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">fn: Function, ctx: Object</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">boundFn</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> l: number = <span class="built_in">arguments</span>.length</div><div class="line">    <span class="keyword">return</span> l</div><div class="line">      ? l &gt; <span class="number">1</span></div><div class="line">        ? fn.apply(ctx, <span class="built_in">arguments</span>)</div><div class="line">        : fn.call(ctx, a)</div><div class="line">      : fn.call(ctx)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 记录原始函数的参数个数</span></div><div class="line">  boundFn._length = fn.length</div><div class="line">  <span class="keyword">return</span> boundFn</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将类数组对象转化为一个数组，其实这个操作挺常见的，但是这样用循环处理貌似效率低呢</span></div><div class="line"><span class="comment">// 测试了一下使用Array.prototype上的方法来做转换会快100倍……</span></div><div class="line"><span class="comment">// 不知道为啥不用……</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toArray</span> (<span class="params">list: any, start?: number</span>): <span class="title">Array</span>&lt;<span class="title">any</span>&gt; </span>&#123;</div><div class="line">  start = start || <span class="number">0</span></div><div class="line">  <span class="keyword">let</span> i = list.length - start</div><div class="line">  <span class="keyword">const</span> ret: <span class="built_in">Array</span>&lt;any&gt; = <span class="keyword">new</span> <span class="built_in">Array</span>(i)</div><div class="line">  <span class="keyword">while</span> (i--) &#123;</div><div class="line">    ret[i] = list[i + start]</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> ret</div><div class="line">&#125;</div><div class="line"><span class="comment">// 用14年的mac air测试，</span></div><div class="line"><span class="comment">// 使用concat和slice来做转换的版本，转换10000次耗时10ms，</span></div><div class="line"><span class="comment">// 用循环的版本耗时1000ms</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toArray</span> (<span class="params">list: any, start?: number</span>): <span class="title">Array</span>&lt;<span class="title">any</span>&gt; </span>&#123;</div><div class="line">  start = start || <span class="number">0</span></div><div class="line">  <span class="keyword">const</span> ret: <span class="built_in">Array</span>&lt;any&gt; = [].concat(list)</div><div class="line">  <span class="keyword">return</span> ret.slice(start)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单的浅拷贝，原来用的object.keys来取key，现在改成用循环了，估计用原生API效率低吧</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span> (<span class="params">to: Object, _from: ?Object</span>): <span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> _from) &#123;</div><div class="line">    to[key] = _from[key]</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> to</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isObject"><a href="#isObject" class="headerlink" title="isObject"></a>isObject</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 超简单的对象检查……</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isObject</span> (<span class="params">obj: mixed</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isPlainObject"><a href="#isPlainObject" class="headerlink" title="isPlainObject"></a>isPlainObject</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用Object.prototype.toString做的严格对象检查</span></div><div class="line"><span class="keyword">const</span> toString = <span class="built_in">Object</span>.prototype.toString</div><div class="line"><span class="keyword">const</span> OBJECT_STRING = <span class="string">'[object Object]'</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span> (<span class="params">obj: any</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> toString.call(obj) === OBJECT_STRING</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="toObject"><a href="#toObject" class="headerlink" title="toObject"></a>toObject</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 讲一个元素都是对象的数组合并成一个对象……</span></div><div class="line"><span class="comment">// 貌似是用来将标签的属性合并为一个配置对象用的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toObject</span> (<span class="params">arr: Array&lt;any&gt;</span>): <span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> res = &#123;&#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (arr[i]) &#123;</div><div class="line">      extend(res, arr[i])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res</div><div class="line">&#125;</div><div class="line"><span class="comment">// 话说之前看到的使用reduce来遍历对象的方法，其实也能够使在这里的</span></div><div class="line"><span class="comment">// 比如这样</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toObject</span> (<span class="params">arr: Array&lt;any&gt;</span>): <span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">res, cur</span>) =&gt;</span> extend(res,cur), &#123;&#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 是不是简洁多了呢？</span></div></pre></td></tr></table></figure>
<h2 id="noop"><a href="#noop" class="headerlink" title="noop"></a>noop</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不执行操作的空函数</span></div><div class="line"><span class="comment">// 抓要是为了兼容那些需要函数作为参数的函数，有没有可做的操作时用的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">noop</span> (<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="no"><a href="#no" class="headerlink" title="no"></a>no</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 永远返回false的函数，作用跟noop一样的</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> no = <span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">false</span></div></pre></td></tr></table></figure>
<h2 id="identity"><a href="#identity" class="headerlink" title="identity"></a>identity</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回传入的参数，同上，嗯……</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> identity = <span class="function">(<span class="params">_: any</span>) =&gt;</span> _</div></pre></td></tr></table></figure>
<h2 id="genStaticKeys"><a href="#genStaticKeys" class="headerlink" title="genStaticKeys"></a>genStaticKeys</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用来将模块数组转换出模块名的一个字符串……</span></div><div class="line"><span class="comment">// 这个方法也是用了reduce来做遍历赋值，使用这种方法还真是挺简洁的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">genStaticKeys</span> (<span class="params">modules: Array&lt;ModuleOptions&gt;</span>): <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> modules.reduce(<span class="function">(<span class="params">keys, m</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> keys.concat(m.staticKeys || [])</div><div class="line">  &#125;, []).join(<span class="string">','</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="looseEqual"><a href="#looseEqual" class="headerlink" title="looseEqual"></a>looseEqual</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单比较两个对象是否一致，就是转成字符串然后比较字符串是否一致</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">looseEqual</span> (<span class="params">a: mixed, b: mixed</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> isObjectA = isObject(a)</div><div class="line">  <span class="keyword">const</span> isObjectB = isObject(b)</div><div class="line">  <span class="keyword">if</span> (isObjectA &amp;&amp; isObjectB) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(a) === <span class="built_in">JSON</span>.stringify(b)</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isObjectA &amp;&amp; !isObjectB) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(a) === <span class="built_in">String</span>(b)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="looseIndexOf"><a href="#looseIndexOf" class="headerlink" title="looseIndexOf"></a>looseIndexOf</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用了looseEqual的indexOf</span></div><div class="line"><span class="comment">// 话说这个判断方法的思想就是，只要有同样的结构，那么就是同样的对象</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">looseIndexOf</span> (<span class="params">arr: Array&lt;mixed&gt;, val: mixed</span>): <span class="title">number</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (looseEqual(arr[i], val)) <span class="keyword">return</span> i</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="once"><a href="#once" class="headerlink" title="once"></a>once</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 确保只调用一次函数</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">once</span> (<span class="params">fn: Function</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">  <span class="comment">// called应该算是一个锁吧</span></div><div class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!called) &#123;</div><div class="line">      <span class="comment">// 上锁</span></div><div class="line">      called = <span class="literal">true</span></div><div class="line">      fn()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>昏昏沉沉的总算是完了……不知道是缺觉还是怎么的，写着技术的文章，心里却想到了很多技术之外的东西。不过今天实在是没精力写了，留个TODO吧，后续整理好了再更新上来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊……写这篇博客的时候我刚上了一宿的线……现在多一个字都不想说了……直接开始吧……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>nodejs热更新的方法</title>
    <link href="http://brooch.me/2017/04/07/nodejs-hotreload/"/>
    <id>http://brooch.me/2017/04/07/nodejs-hotreload/</id>
    <published>2017-04-07T14:04:44.000Z</published>
    <updated>2017-04-14T08:47:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，没错，我又来要放水了今天……这个周末停休了，没辙没辙的……</p>
<a id="more"></a>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>话说上周看了朋友的一篇博客 <a href="https://yj1438.github.io/2017/03/31/respawn.html" target="_blank" rel="external">通过 respawn 加强需要即时生效的开发环境构建系统</a> ，里面说到了用子进程来更新应用的方法，个人感觉就是像Jetty那样的热部署机制吧。但是归根结底，还是要重新启动整个应用才能完成更新，这点上来说感觉并不完美。那么能不能做到真正的0重启热更新代码呢？本文提一个另类的思路给大家参考一下。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>废话不多说了，认真读过nodejs文档的人都应该注意过这个api <a href="http://nodejs.cn/api/globals.html#globals_require_cache" target="_blank" rel="external">require.cache</a> 。文档里写的很清楚，如果这个对象中的引用被清除了，下次再调用就会重新加载，我们可以使用这个机制来热加载更新的模块。</p>
<p>下面有个小栗子可以验证这个思路的可行性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanCache</span> (<span class="params">module</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> path = <span class="built_in">require</span>.resolve(<span class="built_in">module</span>);</div><div class="line">    <span class="built_in">require</span>.cache[path] &amp;&amp; (<span class="built_in">require</span>.cache[path] = <span class="literal">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span> (<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                fs.writeFileSync(<span class="string">"test.js"</span>, <span class="string">"module.exports = \""</span> + text + <span class="string">"\";"</span>);</div><div class="line">                resolve(<span class="literal">true</span>)</div><div class="line">            &#125;,<span class="number">1000</span>)</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fs.watchFile(<span class="string">'test.js'</span>,&#123;</div><div class="line">    <span class="attr">interval</span>:<span class="number">100</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    cleanCache(<span class="string">'./test'</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">require</span>(<span class="string">'./test'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">write(<span class="string">"hello"</span>)().then(write(<span class="string">"my name is zxc"</span>))</div><div class="line"></div><div class="line"><span class="comment">// test.js</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="string">''</span>;</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当然这种方法看上去挺好，但是存在的问题也挺多的。首先，这个方法没办法更新c\c++模块，另外，原生模块也是没法更新的。然后，由于 node.js 本身缺乏对有效的留存对象的扫描机制，有时会出现老模块的资源无法释放的问题，比如setInterval中引用的模块之类的……╮(￣▽￣)╭。总之，生产环境就别想了，但是用来开发调试些经常修改的简单模块的话，会是个不错的选择，比如router之类的配置文件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>怎么说呢，既然是个另类的思路，所以应用场景远没有线程替换那种方法大的。如果是生产环境，依然是推荐使用使用重启或者 PM2 的 hot reload 功能来保证稳定性。另外，webpack也有热替换的功能，HMR嘛，其实这也可以算是一个思路，具体的可以参考这个系列的文章<a href="http://jlongster.com/search?query=Backend%20Apps%20with%20Webpack" target="_blank" rel="external">Backend Apps with Webpack</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://segmentfault.com/a/1190000003888845" target="_blank" rel="external">Webpack 做 Node.js 代码热替换, 第一步</a></li>
<li><a href="https://github.com/rlidwka/node-hotswap" target="_blank" rel="external">node-hotswap</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，没错，我又来要放水了今天……这个周末停休了，没辙没辙的……&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(2)</title>
    <link href="http://brooch.me/2017/03/31/vue-source-notes-2/"/>
    <id>http://brooch.me/2017/03/31/vue-source-notes-2/</id>
    <published>2017-03-31T00:23:23.000Z</published>
    <updated>2017-03-31T07:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>啊，又到deadline了……话说因为之前一直在整理<a href="/2017/03/17/vue-source-notes-1/index.html">上一篇</a>笔记，所以过了这么长时间一直都没怎么读新的，真是惭愧啊……那么这次就读两个简单的模块吧，把简单的解决了，后续再啃硬骨头。</p>
<a id="more"></a>
<h2 id="解析单文件组件-sfc"><a href="#解析单文件组件-sfc" class="headerlink" title="解析单文件组件 sfc"></a>解析单文件组件 sfc</h2><p>之前在说目录结构的时候说过，sfc模块是用来解析.vue文件的，sfc貌似就是single file component的意思……(￣.￣;) 整个模块只有一个文件，但是逻辑却不简单呢……另外在官方文档中对单文件组件的描述也只有短短一个章节，所以感觉这部分通过源码能更充分的了解细节呢，那么先看下代码逻辑：</p>
<h3 id="parser-js"><a href="#parser-js" class="headerlink" title="parser.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/sfc/parser.js" target="_blank" rel="external">parser.js</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 用来匹配换行的正则表达式</span></div><div class="line"><span class="keyword">const</span> splitRE = <span class="regexp">/\r?\n/g</span></div><div class="line"><span class="comment">// 定义了一个判断标签是否是script、style、template标签的函数</span></div><div class="line"><span class="keyword">const</span> isSpecialTag = makeMap(<span class="string">'script,style,template'</span>, <span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="comment">// 解析单个.vue文件的函数</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parseComponent</span> (<span class="params"></span></span></div><div class="line">    <span class="regexp">//</span> 这里特意没有去掉flow的语法，顺便记录下flow的用法</div><div class="line">    <span class="regexp">//</span> 参数后面加（: 类型）表示参数的类型</div><div class="line">    content: string,</div><div class="line">    <span class="regexp">//</span> 参数后面加（?: 类型）表示可省略参数和类型， (= &#123;&#125;) 是<span class="title">es6</span>语法，表示参数的默认值……</div><div class="line">    <span class="title">options</span>?: <span class="title">Object</span> = &#123;&#125;</div><div class="line">    <span class="comment">// （function(): 类型）表示函数的返回值类型，</span></div><div class="line">    <span class="comment">// 这里的SFCDescriptor是一个自定义类型，定义在flow/complier.js里面</span></div><div class="line">    <span class="comment">// 感觉有点像结构体(struct)，另外flow还支持interface和class的定义</span></div><div class="line"> ): SFCDescriptor &#123;</div><div class="line">    <span class="comment">// 最后导出的sfc对象，分为template、script、style和自定义块四部分</span></div><div class="line">    <span class="comment">// 其中style和自定义块允许多个，template和script只允许一个</span></div><div class="line">    <span class="keyword">const</span> sfc: SFCDescriptor = &#123;</div><div class="line">        <span class="attr">template</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">script</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">styles</span>: [],</div><div class="line">        <span class="attr">customBlocks</span>: []</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 因为最后是使用compiler/parser/html-parser模块进行解析的，而html-parser模块会根据dom结构进行递归解析的，</span></div><div class="line">    <span class="comment">// 所以每个代码块都有自己的深度，这里的depth就是用来标记深度的，从后续的代码中可以看出，sfc/parser模块不会处理嵌套的块，只处理一层，这个变量被用来做锁了……</span></div><div class="line">    <span class="keyword">let</span> depth = <span class="number">0</span></div><div class="line">    <span class="comment">// 当前处理的代码块</span></div><div class="line">    <span class="keyword">let</span> currentBlock: ?(SFCBlock | SFCCustomBlock) = <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment">// 稍微调整了下代码的顺序，这个parseHTML的调用本来是放到最后的，这样其实也不会报错吧~</span></div><div class="line">    <span class="comment">// 这个调用也是整个parseComponent函数最核心的部分，使用compiler/parser/html-parser模块的能力来解析模板</span></div><div class="line">    <span class="comment">// parseHTML函数接收一个options参数（第二个），里面可以设置匹配到标签开始和结束时的钩子，通过钩子来获取自己写想要的内容，</span></div><div class="line">    <span class="comment">// 就是说，比如有个&lt;tag&gt;xxx&lt;/tag&gt;这样的内容，匹配到&lt;tag&gt;时，执行start，匹配到&lt;/tag&gt;时，执行end，</span></div><div class="line">    <span class="comment">// 如果匹配到&lt;tab/&gt;，就只执行start，貌似是这样吧，我只粗略的看了下parseHTML，后续详细看发现错了再纠正。</span></div><div class="line">    <span class="comment">// 其实直接运行parseHTML不加options也是可以的，只不过不会返回任何的内容，是完全无意义的操作呢……╮(￣▽￣)╭</span></div><div class="line">    parseHTML(content, &#123;</div><div class="line">        start,</div><div class="line">        end</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 匹配到标签开始时的钩子，主要是对标签的属性进行处理</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">start</span> (<span class="params"></span></span></div><div class="line">        tag: string,</div><div class="line">        attrs: Array&lt;Attribute&gt;,</div><div class="line">        unary: boolean,</div><div class="line">        start: number,</div><div class="line">        end: number</div><div class="line">    ) &#123;</div><div class="line">        <span class="comment">// 根据当前解析深度进行判断</span></div><div class="line">        <span class="keyword">if</span> (depth === <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 如果当前深度是0，也就是说不是嵌套的标签，则进行处理</span></div><div class="line">            <span class="comment">// 先缓存当前块的信息</span></div><div class="line">            currentBlock = &#123;</div><div class="line">                <span class="attr">type</span>: tag,</div><div class="line">                <span class="attr">content</span>: <span class="string">''</span>,</div><div class="line">                <span class="comment">// 这里的start是用来标记标签内的内容的起点的</span></div><div class="line">                start: end,</div><div class="line">                <span class="comment">// 设置属性列表这个地方有意思，通过函数定义的flow里面可以看到arrts是个数组，这里通过数组的reduce特性直接把一个[&#123;"key","value"&#125;...]形式的数组转换为&#123;"key":"value"...&#125;形式的对象了</span></div><div class="line">                attrs: attrs.reduce(<span class="function">(<span class="params">cumulated, &#123; name, value &#125;</span>) =&gt;</span> &#123;</div><div class="line">                    cumulated[name] = value || <span class="literal">true</span></div><div class="line">                    <span class="keyword">return</span> cumulated</div><div class="line">                &#125;, <span class="built_in">Object</span>.create(<span class="literal">null</span>))</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 判断是否是特殊标签</span></div><div class="line">            <span class="keyword">if</span> (isSpecialTag(tag)) &#123;</div><div class="line">                <span class="comment">// 是特殊标签，则检查标签属性，并对特殊属性进行处理</span></div><div class="line">                checkAttrs(currentBlock, attrs)</div><div class="line">                <span class="comment">// 检查是否是style标签</span></div><div class="line">                <span class="keyword">if</span> (tag === <span class="string">'style'</span>) &#123;</div><div class="line">                    <span class="comment">// 是style标签就推进队列</span></div><div class="line">                    sfc.styles.push(currentBlock)</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 不是就直接赋值</span></div><div class="line">                    sfc[tag] = currentBlock</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 不是特殊标签，则推进自定义标签的队列</span></div><div class="line">                sfc.customBlocks.push(currentBlock)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 这个属性是根据parseHTML接收的options.isUnaryTag返回的，因为在调用parseHTML时没传，所以unary总是false</span></div><div class="line">        <span class="keyword">if</span> (!unary) &#123;</div><div class="line">            <span class="comment">// 上锁</span></div><div class="line">            depth++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 检查标签的特殊属性，以便做特殊的处理，特殊属性的使用方法貌似文档中都没有写呢，</span></div><div class="line">    <span class="comment">// 貌似这些属性都是给style标签用的，我是从https://github.com/vuejs-templates/webpack 这个项目中看到的相关例子</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkAttrs</span> (<span class="params">block: SFCBlock, attrs: Array&lt;Attribute&gt;</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attrs.length; i++) &#123;</div><div class="line">            <span class="keyword">const</span> attr = attrs[i]</div><div class="line">            <span class="comment">// 可以用lang标签设置style标签内用的预处理语法，less，sass之类的</span></div><div class="line">            <span class="keyword">if</span> (attr.name === <span class="string">'lang'</span>) &#123;</div><div class="line">                block.lang = attr.value</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果设置了scoped属性，那么这个标签就只对当前组件有作用</span></div><div class="line">            <span class="keyword">if</span> (attr.name === <span class="string">'scoped'</span>) &#123;</div><div class="line">                block.scoped = <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 没找到这个属性是干嘛使的……╮(￣▽￣)╭有可能是为了配合src来用的，module作为src的前缀，</span></div><div class="line">            <span class="comment">// 具体参考 https://github.com/vuejs-templates/webpack/blob/17351f5e3b1306a117aaa80b7d575b9aa3144866/docs/static.md#asset-resolving-rules URLs prefixed with 这一小节的说明。</span></div><div class="line">            <span class="keyword">if</span> (attr.name === <span class="string">'module'</span>) &#123;</div><div class="line">                block.module = attr.value || <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 用src属性设置内容对应的文件</span></div><div class="line">            <span class="keyword">if</span> (attr.name === <span class="string">'src'</span>) &#123;</div><div class="line">                block.src = attr.value</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 匹配到标签结束时调用的钩子，主要是对标签里的内容进行处理</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">end</span> (<span class="params">tag: string, start: number, end: number</span>) </span>&#123;</div><div class="line">        <span class="comment">// 检查锁的状态，并且标签不是不对称标签(不是&lt;tag/&gt;这样的)</span></div><div class="line">        <span class="keyword">if</span> (depth === <span class="number">1</span> &amp;&amp; currentBlock) &#123;</div><div class="line">            <span class="comment">// end标记的是标签内的内容结束的位置</span></div><div class="line">            currentBlock.end = start</div><div class="line">            <span class="comment">// 去除标签内的缩进，deindent是尤大大专门为了去除缩进开发的模块……</span></div><div class="line">            <span class="keyword">let</span> text = deindent(content.slice(currentBlock.start, currentBlock.end))</div><div class="line">            <span class="comment">// 判断是不是template标签，不是统一都要加pad，目的是在lint报错时，报错信息行数能对应上……</span></div><div class="line">            <span class="keyword">if</span> (currentBlock.type !== <span class="string">'template'</span> &amp;&amp; options.pad) &#123;</div><div class="line">                text = padContent(currentBlock) + ext</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 给content属性赋值</span></div><div class="line">            currentBlock.content = text</div><div class="line">            <span class="comment">// 至空currentBlock的引用，currentBlock其实已经保存在sfc的属性的引用上了，currentBlock其实只是个临时变量，这里充分的运用了js对象都是引用类型的特性呢……</span></div><div class="line">            currentBlock = <span class="literal">null</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 解锁</span></div><div class="line">        depth--</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 用来生成能跟.vue文件行数对应上的内容用的……用来对应lint软件或者预编译软件的报错信息的行数……</span></div><div class="line">    <span class="comment">// 话说做框架可真不容易呢，不止要实现功能，连报错信息能不能对应上都要考虑……</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">padContent</span> (<span class="params">block: SFCBlock | SFCCustomBlock</span>) </span>&#123;</div><div class="line">        <span class="comment">// 获取当前这段代码到底在多少行</span></div><div class="line">        <span class="keyword">const</span> offset = content.slice(<span class="number">0</span>, block.start).split(splitRE).length</div><div class="line">        <span class="comment">// 根据不同的块使用不同的换行……</span></div><div class="line">        <span class="keyword">const</span> padChar = block.type === <span class="string">'script'</span> &amp;&amp; !block.lang</div><div class="line">        ? <span class="string">'//\n'</span></div><div class="line">        : <span class="string">'\n'</span></div><div class="line">        <span class="comment">// 最后返回对应行数的换行</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(offset).join(padChar)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 最后返回实例</span></div><div class="line">    <span class="keyword">return</span> sfc</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>怎么说呢，虽然sfc这个模块很短，但是详细分析起来还是挺费时间的……连读带写花了我4个小时啊……总的来说作用就是将文本解析成对象，话说如果要是自己也准备写dom类文件解析的，可以参考这部分的功能呢。看完这部分我觉得比较有趣的点有：</p>
<ul>
<li>flow真是好用啊，特别是看函数的时候，有了参数类型和返回类型的标注，一下就能理解用途了，连文档都省了，这么看来typescript也没那么那接受了的说……有机会一定要在项目中实践一下</li>
<li>使用reduce把数组转成对象。这个还真是开眼了以前没见过这种方法呢，以后可以借鉴到自己开发中</li>
<li>解析dom文本的方法，话说如果自己也要写解析dom操作的话（比如要写爬虫或者写要读xml、svg之类的？），可以借鉴这部分的代码呢，因为用了钩子的形式来扩展自定义操作，所以扩展性还挺强的</li>
<li>为了对应lint报错而使用pad这种方法……怎么说呢，为了良好的开发体验作者还挺下功夫的呢，如果以后自己也要开发框架，借鉴这类细节肯定会给自己的作品大大加分的~</li>
</ul>
<p>以上就是我的感悟，那么你的感悟又是什么呢？有想法就留言告诉我吧，欢迎各路灌水拍砖~(￣▽￣)</p>
<p>好的那么由于时间不足本次的博客就到这里，话说我发觉笔记这种东西就得每天读每天写效果才更好，所以我觉得要不要就改成日更算了~所以如果不出意外的话，大概可能maybe也许明天就会更新了呢~！能不能准时更新，就全看米娜桑点赞打赏转发安利发评论的热情啦~！</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊，又到deadline了……话说因为之前一直在整理&lt;a href=&quot;/2017/03/17/vue-source-notes-1/index.html&quot;&gt;上一篇&lt;/a&gt;笔记，所以过了这么长时间一直都没怎么读新的，真是惭愧啊……那么这次就读两个简单的模块吧，把简单的解决了，后续再啃硬骨头。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
</feed>
