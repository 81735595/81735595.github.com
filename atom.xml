<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep Walking</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://brooch.me/"/>
  <updated>2017-06-02T12:43:54.000Z</updated>
  <id>http://brooch.me/</id>
  
  <author>
    <name>投身烈火</name>
    <email>81735595@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Create React App 里的新鲜玩意儿</title>
    <link href="http://brooch.me/2017/06/02/whats-new-in-create-react-app/"/>
    <id>http://brooch.me/2017/06/02/whats-new-in-create-react-app/</id>
    <published>2017-06-02T09:19:43.000Z</published>
    <updated>2017-06-02T12:43:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>话说玩儿react的同学可能都知道<a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">Create React App</a>这个项目吧（不知道的戳<a href="http://www.jianshu.com/p/dd4cee273bed" target="_blank" rel="external">这里</a>了解，这是来自Facebook官方的零配置命令行工具，能够帮你自动创建基于Webpack的最简易的React项目模板）。话说今天看期刊的时候发现了一篇react的官方blog更新了一篇叫<a href="https://facebook.github.io/react/blog/2017/05/18/whats-new-in-create-react-app.html" target="_blank" rel="external">What’s New in Create React App</a>的博客，随手翻了下发现 Create React App 这个项目居然也更新新版本了？！而且还添加进来很多有趣的功能。我半翻译半解读一下这篇文章，咱们看看有哪些有趣的新功能吧。</p>
<a id="more"></a>
<p>Create React App 这个项目推出大概有一年了，作为一个官方推荐的快速搭建react项目的脚手架，这个项目吸引了大量的开发者。而这个项目在沉寂了几个月之后，于5月18号发布了1.0.0版本（最近这十四天有release了七次，真是猛啊……），添加了好多新的特性。如果你当前正在开发的应用是使用 Create React App 创建的，想体验新版本的特性，并且你的项目并没有执行弹出操作（Create React App 有个 eject命令），可以参考官方的<a href="https://github.com/facebookincubator/create-react-app/releases/tag/v1.0.0" target="_blank" rel="external">升级说明</a>来升级 Create React App。</p>
<h2 id="webpack-2"><a href="#webpack-2" class="headerlink" title="webpack 2"></a>webpack 2</h2><p>虽然 webpack 2 相比 webpack 的改动很大，有可能存在很多问题，但是 webpack 2 已经正式发布几个月了，Create React App 团队经过了一段时间的测试，认为目前 webpack 2 已经足够稳定了，所以将模板中的构建工具也修改为 webpack 2。而且 Create React App 的用户并不需要担心 webpack 2 配置上的改动，Create React App 内部对 webpack 的配置进行了兼容。</p>
<p>如果你的项目已经执行过弹出操作了，则需要参考 webpack 提过的<a href="https://webpack.js.org/guides/migrating/" target="_blank" rel="external">升级指南</a>自己手动修改配置。</p>
<p>webpack 2 最引人注目的新特性就是其对 <a href="http://2ality.com/2014/09/es6-modules-final.html" target="_blank" rel="external">ES6 模块</a> 的支持，可以将将 ES6 模块 直接转化为 CommonJS 模块。虽然这对开发来说可能没啥影响，但是它可以在编译阶段捕获更多的错误，比如exports 的变量undefined之类的：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-01.gif" alt="whats-new-in-create-react-app-01"></p>
<p>webpack 2 还提供了 <a href="http://www.css88.com/archives/6946" target="_blank" rel="external">tree shaking</a> 特性，可以通过去除冗余代码，优化打包后脚本的尺寸。</p>
<h2 id="Runtime-Error-Overlay"><a href="#Runtime-Error-Overlay" class="headerlink" title="Runtime Error Overlay"></a>Runtime Error Overlay</h2><p>你有没有这种经历，代码中写错了一个地方，控制台里也报错了，但是死活找不到报错代码的位置……</p>
<p>为了解决这个问题，我们引入了一个专门捕获错误的弹窗，当程序报错的时候他会展示报错信息和引发错误的位置！当然，他只会出现在开发阶段，产出代码的时候会被去掉。</p>
<p>有图，有真相，就在这儿晒！</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-02.gif" alt="whats-new-in-create-react-app-02"></p>
<p>更牛逼的是，他还能跟你的编辑器结合到一起，惊不惊喜？意不意外？</p>
<p>未来 Creat React App 还准备支持更多错误捕获。比如在React 16 版本发布之后，Creat React App 计划支持 React 组件调用栈的展示。</p>
<h1 id="默认支持渐进式web应用"><a href="#默认支持渐进式web应用" class="headerlink" title="默认支持渐进式web应用"></a>默认支持渐进式web应用</h1><p>使用新版本 Creat React App 创建的项目默认就会支持 [渐进式web应用(PWA)] (<a href="https://developers.google.com/web/progressive-web-apps/)，会使用" target="_blank" rel="external">https://developers.google.com/web/progressive-web-apps/)，会使用</a> <a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers" target="_blank" rel="external">service workers</a> 实现 <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network" target="_blank" rel="external">缓存优先策略</a> 来优化用户再次访问应用的速度。当然，你也可以通过设置默认不开启这个特性，但是如果你在开发新的应用，我推荐你使用它，特别是在移动设备上运行的应用，会有惊喜哦~</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-03.png" alt="whats-new-in-create-react-app-03"></p>
<p>关于 Creat React App 中 PWA 的配置，更详细的说明请戳<a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#making-a-progressive-web-app" target="_blank" rel="external">这里</a>。</p>
<p>题外话，貌似最近 PWA 很火呢，前段时间看到 vue 官方也退出了基于自己框架的<a href="https://github.com/vuejs-templates/pwa" target="_blank" rel="external">pwa脚手架</a>，另外我还发现一个在线的 PWA 脚手架工具，有兴趣的可以玩儿玩儿，<a href="http://www.pwabuilder.com/" target="_blank" rel="external">www.pwabuilder.com</a>，回头有时间我也打算写一篇关于 PWA 的文章~</p>
<h2 id="Jest-20"><a href="#Jest-20" class="headerlink" title="Jest 20"></a>Jest 20</h2><p>先科普一下，<a href="http://facebook.github.io/jest/" target="_blank" rel="external">Jest</a> 是facebook出的一个自动化测试工具，用来跑单测的。</p>
<p>新版的 Creat React App 使用的也是新版的 Jest，20版本的 Jest 包含了许多改进，具体有哪些修改自己看<a href="http://facebook.github.io/jest/blog/2017/05/06/jest-20-delightful-testing-multi-project-runner.html" target="_blank" rel="external">文档</a>吧。</p>
<p>现在 Create React App 只需要做少量 Jest 的配置就可以生成覆盖率报告了。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-04.gif" alt="whats-new-in-create-react-app-04"></p>
<h2 id="动态import-代码分割"><a href="#动态import-代码分割" class="headerlink" title="动态import()代码分割"></a>动态import()代码分割</h2><p>保持应用初始化最小下载量和按需加载的重要性我就不说了哈，其实上个版本的 Create React App 也支持代码分割，不过是基于 webpack 的 require.ensure() 特性，这使得这部分代码没法通过 Jest 的测试。</p>
<p>在这个版本的 Create React App 中，我们加入了对未来web标准中 <a href="http://2ality.com/2017/01/import-operator.html#loading-code-on-demand" target="_blank" rel="external">动态 import()</a> 提案的支持，我建议你使用 import() 来延迟加载非常用组件。巧的是，上期的文章里也涉及到了这个问题，咱们来看看 Create React App 中的解决方案吧：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-05.gif" alt="whats-new-in-create-react-app-05"></p>
<h2 id="更好的控制台输出"><a href="#更好的控制台输出" class="headerlink" title="更好的控制台输出"></a>更好的控制台输出</h2><p>新版的 Create React App 改善了控制台的输出。举个例子，当你启动测试服务时，新版的 Create React App 除了会显示本地地址之外，还会显示局域网ip地址，这样你就能更快的用你的手机测试应用了，总之就是更注重细节了吧……╮(￣▽￣)╭</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-06.png" alt="whats-new-in-create-react-app-06"></p>
<h2 id="更多的特性"><a href="#更多的特性" class="headerlink" title="更多的特性"></a>更多的特性</h2><p>上面描述的其实只是新特性中的一小部分，这个版本中还包含了更多的特性，有兴趣的可以看看这个版本的 <a href="https://github.com/facebookincubator/create-react-app/releases/tag/v1.0.0" target="_blank" rel="external">changelog</a></p>
<p>好的那么由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话说玩儿react的同学可能都知道&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;这个项目吧（不知道的戳&lt;a href=&quot;http://www.jianshu.com/p/dd4cee273bed&quot;&gt;这里&lt;/a&gt;了解，这是来自Facebook官方的零配置命令行工具，能够帮你自动创建基于Webpack的最简易的React项目模板）。话说今天看期刊的时候发现了一篇react的官方blog更新了一篇叫&lt;a href=&quot;https://facebook.github.io/react/blog/2017/05/18/whats-new-in-create-react-app.html&quot;&gt;What’s New in Create React App&lt;/a&gt;的博客，随手翻了下发现 Create React App 这个项目居然也更新新版本了？！而且还添加进来很多有趣的功能。我半翻译半解读一下这篇文章，咱们看看有哪些有趣的新功能吧。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>闲扯react组件动态加载机制 -- webpack打包方案</title>
    <link href="http://brooch.me/2017/05/26/react-component-dynamic-loading-2/"/>
    <id>http://brooch.me/2017/05/26/react-component-dynamic-loading-2/</id>
    <published>2017-05-26T06:42:00.000Z</published>
    <updated>2017-05-26T15:22:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次写的文章被朋友吐槽看不懂了……好吧，这次我们继续说说动态加载组件的打包方案，就算是狗尾续狗，他自己挖的坑填平吧。</p>
<a id="more"></a>
<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>先总结下上次的文章，其实我上次写的那些，归结起来就是一点：</p>
<p>在用react开发应用时，如果想要动态加载子组件，只需要在componentDidMount或者componentWillReceiveProps中加入异步获取组件的逻辑就可以实现了。再进一次，可以把这个功能单独抽成一个专门做加载的组件。</p>
<h2 id="webpack打包"><a href="#webpack打包" class="headerlink" title="webpack打包"></a>webpack打包</h2><p>上篇文章的最后我也说了，之前实现的只是代码逻辑，要想真正用到生产环境，还得过构建打包那一关……说到打包，虽然市面上打包工具不少，不过基本上现在都是用webpack了吧。</p>
<p>根据之前的预测，直接使用System.import()来替换里面的require就可以实现功能了。需要注意的是，根据webpack文档中的描述<a href="https://doc.webpack-china.org/guides/code-splitting-async/#-import-" target="_blank" rel="external">动态引入：import()</a>，import不能支持完全的动态语句，至少要给他一个范围。所以需要将原来使用变量的语句改为一个拼接的路径，类似下面这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "loader" */</span> <span class="string">`./<span class="subst">$&#123;componentName&#125;</span>`</span>)</div><div class="line">    .then(<span class="function"><span class="params">Component</span> =&gt;</span> &#123;</div><div class="line">        \\...</div><div class="line">    &#125;)</div><div class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">        \\...</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>这样webpack在打包时，会将这个路径下所有的文件都作为可能被异步加载chunk来打包。所以最好在目录上做规范，将需要异步加载的组件放到一个特定的目录下，避免打包的时候生成冗余文件。</p>
<h2 id="随之而来的问题"><a href="#随之而来的问题" class="headerlink" title="随之而来的问题"></a>随之而来的问题</h2><p>虽然打包的问题解决了，但是随之也暴露了问题。由于webpack打包是基于入口的，不同入口之间是独立的，而用import拆分出来的chunk是无入口的，所以webpack认为他们之间并没有联系，也就不会提取他们之间的公共内容。</p>
<p>比如我写的demo，具体的引用关系如下图</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/react-component-dynamic-loading-01.jpg" alt="01"></p>
<p>最后打包出来的动态加载的组件例会很多重复的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">chunk &#123;0&#125; page2.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/Page.css</div><div class="line">    css-loader/lib/css-base.js</div><div class="line">    style-loader/lib/addStyles.js</div><div class="line">    style-loader/lib/urls.js</div><div class="line">    containers/LoadComponent.js</div><div class="line">    pages/PageB.js</div><div class="line">    styles/Page.css</div><div class="line"></div><div class="line">chunk &#123;1&#125; page0.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/Page.css</div><div class="line">    css-loader/lib/css-base.js</div><div class="line">    style-loader/lib/addStyles.js</div><div class="line">    style-loader/lib/urls.js</div><div class="line">    containers/LoadComponent.js</div><div class="line">    pages/PageA.js</div><div class="line">    styles/Page.css</div><div class="line">    </div><div class="line">chunk &#123;2&#125; component4.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleB.css</div><div class="line">    components/ComponentC.js</div><div class="line">    lib/BaseComponent.js</div><div class="line">    styles/StyleB.css</div><div class="line"></div><div class="line">chunk &#123;3&#125; component2.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleA.css</div><div class="line">    components/ComponentB.js</div><div class="line">    lib/BaseComponent.js</div><div class="line">    styles/StyleA.css</div><div class="line">    </div><div class="line">chunk &#123;4&#125; component0.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleA.css</div><div class="line">    components/ComponentA.js</div><div class="line">    lib/BaseComponent.js</div><div class="line">    styles/StyleA.css</div><div class="line"></div><div class="line">chunk &#123;5&#125; index.entry.js</div><div class="line">    react-dom/index.js</div><div class="line">    react-hot-loader/patch.js</div><div class="line">    react/react.js</div><div class="line">    strip-ansi/index.js</div><div class="line">    url/url.js</div><div class="line">    containers/App.js</div><div class="line">    index.js</div><div class="line">    stores/dataStore.js</div></pre></td></tr></table></figure>
<p>这个时候就得用CommonsChunkPlugin来优化打包结果了。需要注意的是，由于page和comonpent都是异步加载的，没有入口，所以配置CommonsChunkPlugin的时候需要指定引用了异步加载chunk的入口，并加上<code>children:true</code>。另外异步加载chunk里面如果还有有异步加载的chunk需要优化，则需要把父级的chunk也设为入口，再用CommonsChunkPlugin优化。配置类似这样如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    entry: &#123;</div><div class="line">        <span class="attr">index</span>: <span class="string">'./index'</span>,</div><div class="line">        <span class="attr">pageA</span>: <span class="string">'./pages/PageA'</span>,</div><div class="line">        <span class="attr">pageB</span>: <span class="string">'./pages/PageB'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//...</span></div><div class="line">    plugins: [</div><div class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">'index'</span>,</div><div class="line">            <span class="attr">children</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">async</span>: <span class="literal">true</span></div><div class="line">        &#125;),</div><div class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">            <span class="attr">names</span>: [<span class="string">'pageA'</span>, <span class="string">'pageB'</span>],</div><div class="line">            <span class="attr">children</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">async</span>: <span class="literal">true</span></div><div class="line">        &#125;),</div><div class="line">    ]</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加上<code>async: true</code>的配置之后，生成的公共chunk也会用异步的方式加载进来，这样就能完全的实现动态加载了~</p>
<p>最后打包出来的文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">chunk &#123;0&#125; component4.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleB.css</div><div class="line">    components/ComponentC.js</div><div class="line">    styles/StyleB.css</div><div class="line"></div><div class="line">chunk &#123;1&#125; component2.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleA.css</div><div class="line">    components/ComponentB.js</div><div class="line">    styles/StyleA.css</div><div class="line"></div><div class="line">chunk &#123;2&#125; component0.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleA.css</div><div class="line">    components/ComponentA.js</div><div class="line">    styles/StyleA.css</div><div class="line"></div><div class="line">chunk &#123;3&#125; 3.bundle .js</div><div class="line">    lib/BaseComponent.js</div><div class="line"></div><div class="line">chunk &#123;4&#125; 4.bundle .js</div><div class="line">    css-loader/index.js?modules!./styles/Page.css</div><div class="line">    css-loader/lib/css-base.js</div><div class="line">    style-loader/lib/addStyles.js</div><div class="line">    style-loader/lib/urls.js</div><div class="line">    components lazy recursive ^\.\/.*$</div><div class="line">    containers/LoadComponent.js</div><div class="line">    styles/Page.css</div><div class="line"></div><div class="line">chunk &#123;5&#125; page2.bundle.js</div><div class="line">    pages/PageB.js</div><div class="line"></div><div class="line">chunk &#123;6&#125; page0.bundle.js</div><div class="line">    pages/PageA.js</div><div class="line"></div><div class="line">chunk &#123;7&#125; index.entry.js</div><div class="line">    mobx-react/index.js</div><div class="line">    react-hot-loader/patch.js</div><div class="line">    react/react.js</div><div class="line">    strip-ansi/index.js</div><div class="line">    url/url.js</div><div class="line">    containers/App.js</div><div class="line">    index.js</div><div class="line">    stores/dataStore.js</div><div class="line"></div><div class="line">chunk &#123;8&#125; pageB.entry.js</div><div class="line">    mobx-react/index.js</div><div class="line">    react-dom/index.js</div><div class="line">    react/react.js</div><div class="line">    strip-ansi/index.js</div><div class="line">    url/url.js</div><div class="line">    containers/LoadComponent.js</div><div class="line">    pages/PageB.js</div><div class="line">    styles/Page.css</div><div class="line"></div><div class="line">chunk &#123;9&#125; pageA.entry.js</div><div class="line">    mobx-react/index.js</div><div class="line">    react-dom/index.js</div><div class="line">    react/react.js</div><div class="line">    strip-ansi/index.js</div><div class="line">    url/url.js</div><div class="line">    containers/LoadComponent.js</div><div class="line">    pages/PageA.js</div><div class="line">    styles/Page.css</div></pre></td></tr></table></figure>
<p>可以看到3号chunk是component的公共模块，4号chunk是page的公共模块，8号chunk和9号chunk是设置了入口后生成的冗余文件。</p>
<p>可能有人注意到component的里引用的css文件并没有提取出来，这是因为并不是所有的component chunk都引用了它造成的。如果想要把他也提出来，设置一下CommonsChunkPlugin的minChunks属性就行了。</p>
<p>具体的在项目中使用的时候，需要根据业务手动去调整入口配置和CommonsChunkPlugin里的参数了，要想做到完全自动化，CommonsChunkPlugin是支持不了，需要开发新的webpack插件才行。至于怎么开发webpack插件，这个不在本次文章的范畴里，以后有时间了在专门开新坑说明吧。</p>
<p>最后附上我自己做的<a href="https://github.com/81735595/react-component-dynamic-loading/tree/master/webpack" target="_blank" rel="external">demo</a>，clone下来之后 npm install &amp;&amp; npm start 就能跑起来了。这次算是有示例有真相了吧？就在这儿晒~(￣▽￣)~*</p>
<p>好的那么由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次写的文章被朋友吐槽看不懂了……好吧，这次我们继续说说动态加载组件的打包方案，就算是狗尾续狗，他自己挖的坑填平吧。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
      <category term="webpack" scheme="http://brooch.me/tags/webpack/"/>
    
      <category term="dynamic load" scheme="http://brooch.me/tags/dynamic-load/"/>
    
      <category term="CommonsChunkPlugin" scheme="http://brooch.me/tags/CommonsChunkPlugin/"/>
    
  </entry>
  
  <entry>
    <title>闲扯react组件动态加载机制</title>
    <link href="http://brooch.me/2017/05/19/react-component-dynamic-loading-1/"/>
    <id>http://brooch.me/2017/05/19/react-component-dynamic-loading-1/</id>
    <published>2017-05-19T08:33:12.000Z</published>
    <updated>2017-05-26T06:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>话说之前老写vue的源码有点乏味，今天咱们扯点儿别的。之前在微信群里看到大家聊起react组件动态加载，貌似都没有什么好的解决方案呢，正好最近一直忙着写java，好久没折腾react的代码了，借这个机会捡捡以前的技能，不然都要忘光了……</p>
<a id="more"></a>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>之前在群里聊的时候也没看到有人说起核心的痛点，所以究竟在实际应用中会有啥问题我也不知道 (;￢＿￢) ……所以关于问题的分析，其实都是我脑补出来的，所以大家不要当真，全当看热闹吧……</p>
<p>分析之前，先确定下目标，我的目标是简单实现react组件动态加载的机制。既然是要先串通机制，细节和环境配置就一切从简，后续再考虑实际使用和易用性。</p>
<p>接下来分析问题，说到react组件动态加载，从字面上看可以分为两部分“react组件”和“动态加载”。动态加载其实老早就有就解决方案了，之前打包工具还没流行起来的时候，就有各种五花八门的库来解这问题，requirejs、seajs、YUI Loader啥的，所以这个问题用第三方库应该就能搞定。</p>
<p>然后，跟react组件联系到一起，如何在加载完成后替换组件是个问题。其实这个问题也好解，因为react的组件可以返回新组件，所以做个透传参数的加载器应该就可以了。</p>
<p>另外，现在想开发react的程序，webpack+es6+jsx也算是标配了吧。如何用webpack配合打包也是个问题，要把需要异步加载的都生成chunk。还得搭建一套构建环境……毕竟我的目标是实现机制，所以打包这部分就先不考虑，环境配置也省略，直接写浏览器可执行的脚本。</p>
<p>好的，拉个list：</p>
<ul>
<li>动态加载问题 – 使用requirejs</li>
<li>react组件替换 – 做个加载器组件</li>
<li>webpack打包 – 后续考虑</li>
<li>环境问题 – 先不使用jsx，不写浏览器不能直接运行的代码，公共库用unpkg加载，使用creat-react-class模块创建react组件构造函数</li>
</ul>
<p>ok，可以开始了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>之前列出的四个问题，真正需要解决的只有第二个，所以设计一个加载器组件，其实就能实现react组件动态加载的机制了吧……</p>
<p>调用形式应该像下面这样，在标签上指定要加载的组件名，另外，被调用的组件也会需要设置属性，所以加载器也得接收。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">React.createElement(Loader, &#123;</div><div class="line">    <span class="attr">component</span>: <span class="string">'A'</span>,</div><div class="line">    <span class="attr">propA</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">propB</span>: <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 用jsx写应该是下面这样的</span></div><div class="line">&lt;Loader component=<span class="string">'A'</span> propA=&#123;<span class="number">1</span>&#125; propB=&#123;<span class="literal">true</span>&#125;/&gt;</div></pre></td></tr></table></figure>
<p>Loader内部，首先要有个地方记录已经加载了的组件，如果组件已经加载，就直接调用，如果没加载，就先显示loading并开始加载组件，加载完成后调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把记录已加载组件的变量设为公共变量，为了能在多个实例之间共享</span></div><div class="line"><span class="keyword">var</span> componentList = &#123;&#125;</div><div class="line">createReactClass(&#123;</div><div class="line">    <span class="attr">displayName</span>:<span class="string">'Loader'</span>,</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> component = <span class="keyword">this</span>.props.component</div><div class="line">        <span class="keyword">if</span> (componentList[component]) &#123;</div><div class="line">            <span class="keyword">return</span> React.createElement(componentList[component], <span class="keyword">this</span>.props);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            getComponent(component)</div><div class="line">            <span class="keyword">return</span> React.createElement(div, <span class="literal">null</span>, <span class="string">'loading……'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 用es6写应该是这样的，没错，我就是想证明我会写但是我懒…… (￣.￣)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loader</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props) &#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">    &#125;</div><div class="line">    render () &#123;</div><div class="line">        <span class="keyword">let</span> component = &#123;<span class="keyword">this</span>.props&#125;</div><div class="line">        <span class="keyword">if</span> (componentList[component]) &#123;</div><div class="line">            <span class="keyword">return</span> &lt;componentList[component] &#123;...this.props&#125;/&gt;;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 这个函数里面加载组件</div><div class="line">            getComponent(component)</div><div class="line">            return &lt;div&gt;loading……&lt;/div&gt;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大框架有了，继续细化。虽然上面写了加载组件的函数，但是在加载组件之后需要重新触发加载器的渲染，这就需要设置组件的state，所以必须要给加载器添加state属性，用来标记当前显示的组件，并且在getComponent对state进行设置，创建组件的地方也应该改成用state的属性创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">createReactClass(&#123;</div><div class="line">    <span class="attr">displayName</span>:<span class="string">'Loader'</span>,</div><div class="line">    <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">cur</span>: <span class="string">''</span></div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getComponent</span>: <span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</div><div class="line">        <span class="built_in">require</span>([component], (Component) =&gt; &#123;</div><div class="line">            componentList[component] = Component</div><div class="line">            <span class="keyword">this</span>.setState(&#123;</div><div class="line">                <span class="attr">cur</span>: Component</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> component = <span class="keyword">this</span>.props.component</div><div class="line">        <span class="keyword">if</span> (componentList[component]) &#123;</div><div class="line">            <span class="keyword">return</span> React.createElement(<span class="keyword">this</span>.state.cur, <span class="keyword">this</span>.props);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.getComponent(component)</div><div class="line">            <span class="keyword">return</span> React.createElement(div, <span class="literal">null</span>, <span class="string">'loading……'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>接着问题就来了，react里setState会触发render，而上面render里getComponent又会触发setState，会造成死循环，所以要给他换个地方，react的组件运行时一共四个，constructor、componentWillMount、render、componentDidMount，render不能写，文档上说componentWillMount对于web runtime没屌用，所以只能在constructor和componentDidMount里面选了，其实放到哪个里都行，但是constructor是用来初始化组件的，从含以上看，我觉得放componentDidMount里比较合适，官方文档上也说componentDidMount是用来加载异步数据的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">createReactClass(&#123;</div><div class="line">    <span class="attr">displayName</span>:<span class="string">'Loader'</span>,</div><div class="line">    <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">cur</span>: <span class="string">''</span></div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getComponent</span>: <span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</div><div class="line">        <span class="built_in">require</span>([component], (Component) =&gt; &#123;</div><div class="line">            componentList[component] = Component</div><div class="line">            <span class="keyword">this</span>.setState(&#123;</div><div class="line">                <span class="attr">cur</span>: Component</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">componentDidMount</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.getComponent(<span class="keyword">this</span>.props.component)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (componentList[<span class="keyword">this</span>.props.component]) &#123;</div><div class="line">            <span class="keyword">return</span> React.createElement(<span class="keyword">this</span>.state.cur, <span class="keyword">this</span>.props);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> React.createElement(div, <span class="literal">null</span>, <span class="string">'loading……'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>呃……貌似这样就行了呢……至少大体的机制应该就是这样的吧，还有些细节需要完善，比如props变化的时候也切加载控间，现在这个加载器只能加载一次控件，其实只要在属性变化的运行时里加上getComponent函数就行了。再比如减少控件渲染次数，控价加载失败的异常处理之类的，详细的就不说了，自己体会吧，我把我练习的代码传到github上了，可以看看吐吐槽</p>
<p><a href="https://github.com/81735595/react-component-dynamic-loading" target="_blank" rel="external">https://github.com/81735595/react-component-dynamic-loading</a></p>
<p>用npm start就能启动了。</p>
<h2 id="关于打包"><a href="#关于打包" class="headerlink" title="关于打包"></a>关于打包</h2><p>感觉在代码上直接用import替换require就能用webpack2打包了，但是我总觉得打包是个大头儿，有好多坑等着……所以等以后有时间了再补一次打包脚本联系好了。</p>
<p>好的那么由于时间不足，本期的流水账就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话说之前老写vue的源码有点乏味，今天咱们扯点儿别的。之前在微信群里看到大家聊起react组件动态加载，貌似都没有什么好的解决方案呢，正好最近一直忙着写java，好久没折腾react的代码了，借这个机会捡捡以前的技能，不然都要忘光了……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(5)</title>
    <link href="http://brooch.me/2017/05/05/vue-source-notes-5/"/>
    <id>http://brooch.me/2017/05/05/vue-source-notes-5/</id>
    <published>2017-05-05T12:00:29.000Z</published>
    <updated>2017-05-05T13:45:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>五一好好给自己放了个假，去成都玩儿了几天。话说成都的生活可真是悠闲，搞得我都向去成都买房定居了~而且成都的吃的可真是，（¯﹃¯）…… 一想到猪肉锅盔和冒节子肥肠粉我口水就开始往外涌……咳咳……言归正传，上次说这次要读core的全部全局api和config，下面咱们就开始。</p>
<h2 id="use-js"><a href="#use-js" class="headerlink" title="use.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/use.js" target="_blank" rel="external">use.js</a></h2><p>这个文件是用来给构造函数Vue挂载use方法用的，逻辑很简单。use方法是用来安装插件用的，<a href="https://cn.vuejs.org/v2/api/?#Vue-use" target="_blank" rel="external">对应文档</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: Function | Object</span>) </span>&#123;</div><div class="line">    <span class="comment">// 安装过的控件不再安装</span></div><div class="line">    <span class="comment">/* istanbul ignore if */</span></div><div class="line">    <span class="keyword">if</span> (plugin.installed) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 组织要传给控件的参数，Vue构造函数作为第一个参数</span></div><div class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line">    args.unshift(<span class="keyword">this</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 根据plugin的类型使用不同调用方法，文档中只介绍了使用install属性来启动插件的方法，</span></div><div class="line">    <span class="comment">// 如果plugin本身就是个函数，则使用这个函数来安装插件</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">'function'</span>) &#123;</div><div class="line">      plugin.install.apply(plugin, args)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) &#123;</div><div class="line">      plugin.apply(<span class="literal">null</span>, args)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 给安装过的控件加锁</span></div><div class="line">    plugin.installed = <span class="literal">true</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="mixin-js"><a href="#mixin-js" class="headerlink" title="mixin.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/mixin.js" target="_blank" rel="external">mixin.js</a></h2><p>mixin的逻辑主要隐藏在mergeOptions函数里，之前咱么你说过，这个函数是组件实例化和继承的核心方法，其实就是根据不同的属性进行合并，有规定的属性按照规定的规则，没规定的属性直接覆盖。等到读到 src/core/util/options.js 时再详细解读 mergeOptions 函数。<a href="https://cn.vuejs.org/v2/api/?#Vue-mixin" target="_blank" rel="external">对应文档</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mergeOptions &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  <span class="comment">// 挂载mixin方法</span></div><div class="line">  Vue.mixin = <span class="function"><span class="keyword">function</span> (<span class="params">mixin: Object</span>) </span>&#123;</div><div class="line">    <span class="comment">// 使用 mergeOptions 函数合并 Vue.options</span></div><div class="line">    <span class="keyword">this</span>.options = mergeOptions(<span class="keyword">this</span>.options, mixin)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="extend-js"><a href="#extend-js" class="headerlink" title="extend.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/.js" target="_blank" rel="external">extend.js</a></h2><p>extend本身是用来创建子类的，内部使用mergeOptions来合并属性。<a href="https://cn.vuejs.org/v2/api/?#Vue-extend" target="_blank" rel="external">对应文档</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; warn, extend, mergeOptions &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"><span class="keyword">import</span> &#123; defineComputed, proxy &#125; <span class="keyword">from</span> <span class="string">'../instance/state'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initExtend</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 初始化Vue的cid，用来做Vue构造函数和其子类的缓存的索引，每个Vue构造函数的子类也都有cid</div><div class="line">   */</div><div class="line">  Vue.cid = <span class="number">0</span></div><div class="line">  <span class="keyword">let</span> cid = <span class="number">1</span></div><div class="line"></div><div class="line">  <span class="comment">// 挂载extend方法</span></div><div class="line">  Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: Object</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">    <span class="comment">// 子类的options的容错处理</span></div><div class="line">    extendOptions = extendOptions || &#123;&#125;</div><div class="line">    <span class="keyword">const</span> Super = <span class="keyword">this</span></div><div class="line">    <span class="keyword">const</span> SuperId = Super.cid</div><div class="line">    <span class="comment">// 取缓存，缓存是绑在options对象上的，就是说同样的父类、同样的配置，就会走缓存生成相同的子类。</span></div><div class="line">    <span class="keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</div><div class="line">    <span class="keyword">if</span> (cachedCtors[SuperId]) &#123;</div><div class="line">      <span class="keyword">return</span> cachedCtors[SuperId]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> name = extendOptions.name || Super.options.name</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (!<span class="regexp">/^[a-zA-Z][\w-]*$/</span>.test(name)) &#123;</div><div class="line">        warn(</div><div class="line">          <span class="string">'Invalid component name: "'</span> + name + <span class="string">'". Component names '</span> +</div><div class="line">          <span class="string">'can only contain alphanumeric characters and the hyphen, '</span> +</div><div class="line">          <span class="string">'and must start with a letter.'</span></div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 定义子类的构造函数</span></div><div class="line">    <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">      <span class="comment">// 后面会将父类的prototype接到子类的上，就可以调用Vue的_init方法了</span></div><div class="line">      <span class="keyword">this</span>._init(options)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 实现类的继承</span></div><div class="line">    Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</div><div class="line">    Sub.prototype.constructor = Sub</div><div class="line">    Sub.cid = cid++</div><div class="line">    Sub.options = mergeOptions(</div><div class="line">      Super.options,</div><div class="line">      extendOptions</div><div class="line">    )</div><div class="line">    Sub[<span class="string">'super'</span>] = Super</div><div class="line"></div><div class="line">    <span class="comment">// 初始化子类的props属性，这里使用了一个函数来封装遍历的过程</span></div><div class="line">    <span class="comment">// initProps里对options.props的每个属都进行了初始化</span></div><div class="line">    <span class="keyword">if</span> (Sub.options.props) &#123;</div><div class="line">      initProps(Sub)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 与initProps类似</span></div><div class="line">    <span class="keyword">if</span> (Sub.options.computed) &#123;</div><div class="line">      initComputed(Sub)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 让子类也能使用extend、mixin、use方法</span></div><div class="line">    Sub.extend = Super.extend</div><div class="line">    Sub.mixin = Super.mixin</div><div class="line">    Sub.use = Super.use</div><div class="line"></div><div class="line">    <span class="comment">// config._assetTypes里面是所有的控件类型，这些也都复制到子类上</span></div><div class="line">    config._assetTypes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">      Sub[type] = Super[type]</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// 允许递归查找自己</span></div><div class="line">    <span class="keyword">if</span> (name) &#123;</div><div class="line">      Sub.options.components[name] = Sub</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 保存对super和自己当前的options的引用，实例化的时候用于检查options是否更新了</span></div><div class="line">    Sub.superOptions = Super.options</div><div class="line">    Sub.extendOptions = extendOptions</div><div class="line">    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</div><div class="line"></div><div class="line">    <span class="comment">// 添加缓存</span></div><div class="line">    cachedCtors[SuperId] = Sub</div><div class="line">    <span class="keyword">return</span> Sub</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// initProps 和 initComputed 的操作类似，通过代理调用Object.defineProperty</span></div><div class="line"><span class="comment">// 简单看了下代理的逻辑，感觉并没有减少Object.defineProperty的调用次数</span></div><div class="line"><span class="comment">// 只是使用一个固定的对象来减少生成对象的数量</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">Comp</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> props = Comp.options.props</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</div><div class="line">    proxy(Comp.prototype, <span class="string">`_props`</span>, key)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">Comp</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> computed = Comp.options.computed</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</div><div class="line">    defineComputed(Comp.prototype, key, computed[key])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="assets-js"><a href="#assets-js" class="headerlink" title="assets.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/assets.js" target="_blank" rel="external">assets.js</a></h2><p>asset貌似应该翻译为资源，这个文件主要是用来初始化Vue的资源的，所谓的资源就是类似directive、filter、component之类的控件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; warn, isPlainObject &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initAssetRegisters</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  </div><div class="line">  <span class="comment">// 注册Vue默认支持的资源，就是注册了 Vue.directive、Vue.component、Vue.filter方法</span></div><div class="line">  config._assetTypes.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</div><div class="line">    Vue[type] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line">      id: string,</div><div class="line">      definition: Function | Object</div><div class="line">    ): <span class="title">Function</span> | <span class="title">Object</span> | <span class="title">void</span> &#123;</div><div class="line">      <span class="keyword">if</span> (!definition) &#123;</div><div class="line">        <span class="comment">// 获取资源</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.options[type + <span class="string">'s'</span>][id]</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 注册资源</span></div><div class="line">        <span class="comment">/* istanbul ignore if */</span></div><div class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">          <span class="keyword">if</span> (type === <span class="string">'component'</span> &amp;&amp; config.isReservedTag(id)) &#123;</div><div class="line">            warn(</div><div class="line">              <span class="string">'Do not use built-in or reserved HTML elements as component '</span> +</div><div class="line">              <span class="string">'id: '</span> + id</div><div class="line">            )</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 对不同资源进行不同处理</span></div><div class="line">        <span class="keyword">if</span> (type === <span class="string">'component'</span> &amp;&amp; isPlainObject(definition)) &#123;</div><div class="line">          definition.name = definition.name || id</div><div class="line">          definition = <span class="keyword">this</span>.options._base.extend(definition)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (type === <span class="string">'directive'</span> &amp;&amp; <span class="keyword">typeof</span> definition === <span class="string">'function'</span>) &#123;</div><div class="line">          definition = &#123; <span class="attr">bind</span>: definition, <span class="attr">update</span>: definition &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.options[type + <span class="string">'s'</span>][id] = definition</div><div class="line">        <span class="keyword">return</span> definition</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>全局api这部分就算是看完了，总的来说这部分逻辑都不复杂，主要学习的还是机制吧，插件的机制，继承的机制，资源注册获取的机制，基本上算是教科书式的了吧，自己开发中都可以借鉴到的。</p>
<h2 id="config-js"><a href="#config-js" class="headerlink" title="config.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/config.js" target="_blank" rel="external">config.js</a></h2><p>core/config.js 文件里面记录了所有Vue可使用的配置，有些在api文档上查的到，有的则查不到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @flow */</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; no, noop, identity &#125; <span class="keyword">from</span> <span class="string">'shared/util'</span></div><div class="line"></div><div class="line"><span class="comment">// 这部分是给flow检查Config中每个属性的类型用的，简单易懂，同事标注了属性是给哪部分用的</span></div><div class="line"><span class="keyword">export</span> type Config = &#123;</div><div class="line">  <span class="comment">// user(用户可配置的属性)</span></div><div class="line">  optionMergeStrategies: &#123; [key: string]: <span class="built_in">Function</span> &#125;;</div><div class="line">  silent: boolean;</div><div class="line">  productionTip: boolean;</div><div class="line">  performance: boolean;</div><div class="line">  devtools: boolean;</div><div class="line">  errorHandler: ?<span class="function">(<span class="params">err: <span class="built_in">Error</span>, vm: Component, info: string</span>) =&gt;</span> <span class="keyword">void</span>;</div><div class="line">  ignoredElements: <span class="built_in">Array</span>&lt;string&gt;;</div><div class="line">  keyCodes: &#123; [key: string]: number | <span class="built_in">Array</span>&lt;number&gt; &#125;;</div><div class="line">  <span class="comment">// platform(给不同平台用的属性)</span></div><div class="line">  isReservedTag: <span class="function">(<span class="params">x?: string</span>) =&gt;</span> boolean;</div><div class="line">  parsePlatformTagName: <span class="function">(<span class="params">x: string</span>) =&gt;</span> string;</div><div class="line">  isUnknownElement: <span class="function">(<span class="params">x?: string</span>) =&gt;</span> boolean;</div><div class="line">  getTagNamespace: <span class="function">(<span class="params">x?: string</span>) =&gt;</span> string | <span class="keyword">void</span>;</div><div class="line">  mustUseProp: <span class="function">(<span class="params">tag: string, type: ?string, name: string</span>) =&gt;</span> boolean;</div><div class="line">  <span class="comment">// internal(内部用的属性)</span></div><div class="line">  _assetTypes: <span class="built_in">Array</span>&lt;string&gt;;</div><div class="line">  _lifecycleHooks: <span class="built_in">Array</span>&lt;string&gt;;</div><div class="line">  _maxUpdateCount: number;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> config: Config = &#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 用户属性在官方文档中都有详细的说明，我就不做过多解释了，简单翻译一下</div><div class="line">   * 自定义合并策略 (used in core/util/options)</div><div class="line">   */</div><div class="line">  optionMergeStrategies: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 日志的控制开关</div><div class="line">   */</div><div class="line">  silent: <span class="literal">false</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 启东市是否显示生产模式的提示信息，这个是根据构造时测参数决定的</div><div class="line">   */</div><div class="line">  productionTip: process.env.NODE_ENV !== <span class="string">'production'</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 是否使用调试工具</div><div class="line">   */</div><div class="line">  devtools: process.env.NODE_ENV !== <span class="string">'production'</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 是否显示性能数据</div><div class="line">   */</div><div class="line">  performance: process.env.NODE_ENV !== <span class="string">'production'</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 异常处理接口，如果使用官方文档上有</div><div class="line">   */</div><div class="line">  errorHandler: <span class="literal">null</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 忽略某些自定义元素</div><div class="line">   */</div><div class="line">  ignoredElements: [],</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 给 v-on 自定义键位别名</div><div class="line">   */</div><div class="line">  keyCodes: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 检查标签是否是保留标签的方法，各个平台之间不一样，没错，需要是一个返回true、false的方法</div><div class="line">   * 具体检查方法可以在 src/platforms/ 里面找</div><div class="line">   */</div><div class="line">  isReservedTag: no,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 检查标签是否是未知标签</div><div class="line">   */</div><div class="line">  isUnknownElement: no,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取标签的命名空间，也可以理解为获取标签的类型吧，html、svg之类的</div><div class="line">   */</div><div class="line">  getTagNamespace: noop,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 解析标签在平台中的名字……貌似对标签名做映射的</div><div class="line">   */</div><div class="line">  parsePlatformTagName: identity,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 检查标签必须包含的属性，比如input标签必须有value属性之类的……</div><div class="line">   */</div><div class="line">  mustUseProp: no,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 所有支持的资源的列表</div><div class="line">   */</div><div class="line">  _assetTypes: [</div><div class="line">    <span class="string">'component'</span>,</div><div class="line">    <span class="string">'directive'</span>,</div><div class="line">    <span class="string">'filter'</span></div><div class="line">  ],</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 所有生命周期的列表</div><div class="line">   */</div><div class="line">  _lifecycleHooks: [</div><div class="line">    <span class="string">'beforeCreate'</span>,</div><div class="line">    <span class="string">'created'</span>,</div><div class="line">    <span class="string">'beforeMount'</span>,</div><div class="line">    <span class="string">'mounted'</span>,</div><div class="line">    <span class="string">'beforeUpdate'</span>,</div><div class="line">    <span class="string">'updated'</span>,</div><div class="line">    <span class="string">'beforeDestroy'</span>,</div><div class="line">    <span class="string">'destroyed'</span>,</div><div class="line">    <span class="string">'activated'</span>,</div><div class="line">    <span class="string">'deactivated'</span></div><div class="line">  ],</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 更新数据的最大循环次数</div><div class="line">   */</div><div class="line">  _maxUpdateCount: <span class="number">100</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> config</div></pre></td></tr></table></figure>
<p>这个文件本身是没有逻辑的，而且每个属性都有注释，我就简单翻一下注释。感觉flow只是挺好用的呢，作用和typescript类似，如果不用vscode做编辑器，用flow来代替typescript应该会更简单方便一些，如果用vscode，那么使用typescript应该会更方便。虽然不服，但是大微软只是不鸣则已一鸣惊人，vscode甩了atom不知道多少条街……跑题了跑题了，好的那么由于时间不足，本期笔记就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的力度了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;五一好好给自己放了个假，去成都玩儿了几天。话说成都的生活可真是悠闲，搞得我都向去成都买房定居了~而且成都的吃的可真是，（¯﹃¯）…… 一想到猪肉锅盔和冒节子肥肠粉我口水就开始往外涌……咳咳……言归正传，上次说这次要读core的全部全局api和config，下面咱们就开始。&lt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(4)</title>
    <link href="http://brooch.me/2017/04/21/vue-source-notes-4/"/>
    <id>http://brooch.me/2017/04/21/vue-source-notes-4/</id>
    <published>2017-04-21T05:37:29.000Z</published>
    <updated>2017-05-05T13:43:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，又到了一周一度的deadline……之前几次把杂七杂八的部分读完了，这次终于要开始读vue核心部分的代码了。从之前读过的 src/entries 模块中可以看到，vue核心的代码的大概可以分为 runtime 和 compiler 两部分。runtime 对应 src/core 模块，compiler 对应 src/compiler 模块，这次就从 src/core 模块开始读。</p>
<h2 id="Vue核心模块-core"><a href="#Vue核心模块-core" class="headerlink" title="Vue核心模块 core"></a>Vue核心模块 core</h2><p>这个模块最后输出的就是一个Vue的构造函数，里面包含了组件系统、全局API、vue实例、对象属性监测系统、公共方法、虚拟dom、配置，这些模块。因为各个模块之间都有联系，单拎出来一个个看感觉没法看到全貌呀。所以这次换个方式试试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">|- core</div><div class="line">  |- components</div><div class="line">  |- global-api</div><div class="line">  |- instance</div><div class="line">  |- observer</div><div class="line">  |- util</div><div class="line">  |- vdom</div><div class="line">  |- config.js</div><div class="line">  |- index.js</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>从 src/entries/web-runtime.js 文件中可以看出，Vue 这个构造函数是从 src/core/index.js 导出的，这个文件的代码如下：</p>
<h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/index.js" target="_blank" rel="external">index.js</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./instance/index'</span></div><div class="line"><span class="keyword">import</span> &#123; initGlobalAPI &#125; <span class="keyword">from</span> <span class="string">'./global-api/index'</span></div><div class="line"><span class="keyword">import</span> &#123; isServerRendering &#125; <span class="keyword">from</span> <span class="string">'core/util/env'</span></div><div class="line"></div><div class="line"><span class="comment">// Vue构造函数来自src/core/instance/index.js</span></div><div class="line"><span class="comment">// 通过initGlobalAPI这个函数添加全局api</span></div><div class="line">initGlobalAPI(Vue)</div><div class="line"></div><div class="line"><span class="comment">// 是否运行在服务端的标记，对应文档中的 https://cn.vuejs.org/v2/api/?#vm-isServer</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$isServer'</span>, &#123;</div><div class="line">  <span class="attr">get</span>: isServerRendering</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// __VERSION__ 是在 build/config.js 里面配置的，在构建的时候通过脚本替换为配置里的变量</span></div><div class="line">Vue.version = <span class="string">'__VERSION__'</span></div><div class="line"></div><div class="line"><span class="comment">// 导出Vue构造函数</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure>
<p>Vue.prototype.$isServer 和 Vue.version 比较简单就不展开了，Vue构造函数后面再看，先看全局api吧。</p>
<h3 id="index-js-1"><a href="#index-js-1" class="headerlink" title="index.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/index.js" target="_blank" rel="external">index.js</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; initUse &#125; <span class="keyword">from</span> <span class="string">'./use'</span></div><div class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./mixin'</span></div><div class="line"><span class="keyword">import</span> &#123; initExtend &#125; <span class="keyword">from</span> <span class="string">'./extend'</span></div><div class="line"><span class="keyword">import</span> &#123; initAssetRegisters &#125; <span class="keyword">from</span> <span class="string">'./assets'</span></div><div class="line"><span class="keyword">import</span> &#123; set, del &#125; <span class="keyword">from</span> <span class="string">'../observer/index'</span></div><div class="line"><span class="keyword">import</span> builtInComponents <span class="keyword">from</span> <span class="string">'../components/index'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  warn,</div><div class="line">  extend,</div><div class="line">  nextTick,</div><div class="line">  mergeOptions,</div><div class="line">  defineReactive</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initGlobalAPI</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  <span class="comment">// 首先配置 Vue.config ，在定义时使用了 Object.defineProperty</span></div><div class="line">  <span class="comment">// 所以在设置 Vue.config 的时候是不能直接 Vue.config = &#123;....&#125;这样的，不然会报错，得一项一项设</span></div><div class="line">  <span class="keyword">const</span> configDef = &#123;&#125;</div><div class="line">  configDef.get = <span class="function"><span class="params">()</span> =&gt;</span> config</div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">    configDef.set = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      warn(</div><div class="line">        <span class="string">'Do not replace the Vue.config object, set individual fields instead.'</span></div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(Vue, <span class="string">'config'</span>, configDef)</div><div class="line"></div><div class="line">  <span class="comment">// Vue.util虽然暴露出来了，但是并不是公共api的一部分，所以用的时候要小心点儿</span></div><div class="line">  Vue.util = &#123;</div><div class="line">    <span class="comment">// 下面这些方法都来自 core/util/这个模块，这里先简单说下每个函数的用途，后续展开</span></div><div class="line">    <span class="comment">// 输出错误信息用的，同事还能输出错误组件的名字和对应的vue文件地址</span></div><div class="line">    warn,</div><div class="line">    <span class="comment">// 顾名思义，浅拷贝</span></div><div class="line">    extend,</div><div class="line">    <span class="comment">// 用来合并实例option的，组件实例化和继承的核心方法</span></div><div class="line">    mergeOptions,</div><div class="line">    <span class="comment">// 用来给对象定义响应属性</span></div><div class="line">    defineReactive</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 给实例添加属性，对应 https://cn.vuejs.org/v2/api/?#Vue-set</span></div><div class="line">  Vue.set = set</div><div class="line">  <span class="comment">// 删除实例属性，对应 https://cn.vuejs.org/v2/api/?#Vue-delete</span></div><div class="line">  Vue.delete = del</div><div class="line">  <span class="comment">// 对应 https://cn.vuejs.org/v2/api/?#Vue-nextTick，一个打包执行延迟任务的方法，采用Promise =&gt; MutationObserver =&gt; setTimeout(0)的退化设计</span></div><div class="line">  <span class="comment">// 在读nextTick源码的时候发现几个有意思的点，本来想憋到写 src/core/util 的时候再写的，但是我实在是憋不住了哈哈</span></div><div class="line">  <span class="comment">// 1. 在使用promise的时候，ios里（其实就是safari和uiwebview）如果直接用promise.resolve()触发一个then的话，</span></div><div class="line">  <span class="comment">// 他不会立即执行，运行一个空的setTimeout之后，在就没问题了……相当神奇……</span></div><div class="line">  <span class="comment">// 另外，我发现他的ios判断里没有判断safari，但是safari里也有这个问题，不知道是不是bug……</span></div><div class="line">  <span class="comment">// 2. MutationObserver是通过观测dom元素的变化来触发事件回调，具体替代promise的方法等看到了再详细说吧</span></div><div class="line">  <span class="comment">// 3. 还有一个细节，在执行一批回调的时候，用的是[].length=0来清空数组，而不是空数组赋值的方法，感觉是为了省内存，不用频繁gc</span></div><div class="line">  Vue.nextTick = nextTick</div><div class="line">  <span class="comment">// options用来存定义过的组件的，支持component, directive, filter，支持的组件列表保存在_assetTypes里面</span></div><div class="line">  <span class="comment">// 具体还没有细看，但是感觉是支持扩展的</span></div><div class="line">  Vue.options = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">  config._assetTypes.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</div><div class="line">    Vue.options[type + <span class="string">'s'</span>] = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 用来给所有实例标记base构造函数用的属性</span></div><div class="line">  Vue.options._base = Vue</div><div class="line"></div><div class="line">  <span class="comment">// 挂载keep-alive组件，https://cn.vuejs.org/v2/api/?#keep-alive</span></div><div class="line">  extend(Vue.options.components, builtInComponents)</div><div class="line"></div><div class="line">  <span class="comment">// 挂载 Vue.use 方法</span></div><div class="line">  initUse(Vue)</div><div class="line">  <span class="comment">// 挂载 Vue.mixin 方法</span></div><div class="line">  initMixin(Vue)</div><div class="line">  <span class="comment">// 挂载 Vue.extend 方法</span></div><div class="line">  initExtend(Vue)</div><div class="line">  <span class="comment">// 挂载 Vue.component, Vue.directive, Vue.filter 方法</span></div><div class="line">  initAssetRegisters(Vue)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>全局api的挂载逻辑还算相对简单，Vue的方法挂载每部分都拆成了单独的函数，利用js中Function是对象、可以作为参数的特性、是引用类型等特性，用这种函数来加工Vue构造函数，不知道这算不算装饰模式呢……</p>
<p>另外我发现一个细节，源码中在生成空对象的时候，会用Object.create(null)来生成，具体原因不明，因为这两种方式，除了原型不一样，其他的没区别，因为也见到有使用字面量来生成空对象的，所以会不会是因为是开源项目，开源项目中大量人员参与其中，每个人的编码习惯有差异造成的呢……</p>
<p>好的那么由于时间不足，本期笔记就先写到这里，话说每次只看这么一点儿，我还真是感觉惭愧呢，希望未来可以挤出更多的时间来读吧……如果不出意外的话，maybe可能也许大概下周五会更新吧，下周准备更新config和全部全局api，能不能准时更新，就全看米娜桑点赞转发安利留言的力度了~、</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，又到了一周一度的deadline……之前几次把杂七杂八的部分读完了，这次终于要开始读vue核心部分的代码了。从之前读过的 src/entries 模块中可以看到，vue核心的代码的大概可以分为 runtime 和 compiler 两部分。runtime 对应 src/
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(3)</title>
    <link href="http://brooch.me/2017/04/14/vue-source-notes-3/"/>
    <id>http://brooch.me/2017/04/14/vue-source-notes-3/</id>
    <published>2017-04-14T08:51:35.000Z</published>
    <updated>2017-04-14T08:46:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>啊……写这篇博客的时候我刚上了一宿的线……现在多一个字都不想说了……直接开始吧……</p>
<a id="more"></a>
<h2 id="公共方法模块-shared"><a href="#公共方法模块-shared" class="headerlink" title="公共方法模块 shared"></a>公共方法模块 shared</h2><p>故名思议，shared模块是放所有公共方法的，里面只有 util.js 一个文件。</p>
<h3 id="util-js"><a href="#util-js" class="headerlink" title="util.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/shared/util.js" target="_blank" rel="external">util.js</a></h3><p>util.js一共暴露了23个方法，每个函数都非常基础，第一眼看上去感觉没啥可看的，但是仔细看每个函数会发现，这些函数都很实用，而且正是因为基础，很可能会成为以后面试的考题……</p>
<p>总之过一遍下这些方法吧，记录下我认为有用的知识点，当做事知识储备了：</p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="_toString"></a>_toString</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个函数可以将任意类型的值转为字符串</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_toString</span> (<span class="params">val: any</span>): <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> val == <span class="literal">null</span></div><div class="line">    <span class="comment">// 如果是null就返回空字符串</span></div><div class="line">    ? <span class="string">''</span></div><div class="line">    : <span class="keyword">typeof</span> val === <span class="string">'object'</span></div><div class="line">      <span class="comment">// 如果是object就转成json</span></div><div class="line">      <span class="comment">// 这里比较特殊的是在调用stringify时除了要转换的值，还多传了两个参数，其中第二个参数用来过滤数据，第三个参数用来控制内容的缩进</span></div><div class="line">      ? <span class="built_in">JSON</span>.stringify(val, <span class="literal">null</span>, <span class="number">2</span>)</div><div class="line">      <span class="comment">// 其他的都是用String来转换为字符串，其实跟调用对象的toString是一样的吧？</span></div><div class="line">      : <span class="built_in">String</span>(val)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="toNumber"><a href="#toNumber" class="headerlink" title="toNumber"></a>toNumber</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将传入的值转换为浮点数，如果转换失败就返回传入值</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toNumber</span> (<span class="params">val: string</span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="comment">// 浮点数没加 ",10" ，不知道是不是个隐藏的问题</span></div><div class="line">  <span class="keyword">const</span> n = <span class="built_in">parseFloat</span>(val)</div><div class="line">  <span class="keyword">return</span> <span class="built_in">isNaN</span>(n) ? val : n</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="makeMap"><a href="#makeMap" class="headerlink" title="makeMap"></a>makeMap</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个函数比较有意思，功能有点儿像集合（Set）对象，但是只能存储字符串，最后用来判断值是否已经存在</span></div><div class="line"><span class="comment">// 貌似是用来快速检索某个值是否存在用的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">makeMap</span> (<span class="params"></span></span></div><div class="line">  str: string,</div><div class="line">  expectsLowerCase?: boolean</div><div class="line">): (<span class="params">key: string</span>) =&gt; <span class="title">true</span> | <span class="title">void</span> &#123;</div><div class="line">  <span class="keyword">const</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">  <span class="keyword">const</span> list: <span class="built_in">Array</span>&lt;string&gt; = str.split(<span class="string">','</span>)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line">    map[list[i]] = <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> expectsLowerCase</div><div class="line">    ? <span class="function"><span class="params">val</span> =&gt;</span> map[val.toLowerCase()]</div><div class="line">    : <span class="function"><span class="params">val</span> =&gt;</span> map[val]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isBuiltInTag"><a href="#isBuiltInTag" class="headerlink" title="isBuiltInTag"></a>isBuiltInTag</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成一个用来检索是否是内置标签的函数，用到了之前的makeMap方法</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> isBuiltInTag = makeMap(<span class="string">'slot,component'</span>, <span class="literal">true</span>)</div></pre></td></tr></table></figure>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个工具方法，用来删除数组中匹配到的对象</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">arr: Array&lt;any&gt;, item: any</span>): <span class="title">Array</span>&lt;<span class="title">any</span>&gt; | <span class="title">void</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (arr.length) &#123;</div><div class="line">    <span class="keyword">const</span> index = arr.indexOf(item)</div><div class="line">    <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="hasOwn"><a href="#hasOwn" class="headerlink" title="hasOwn"></a>hasOwn</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对Object.prototype.hasOwnProperty的封装，用来判断对象的属性是否是继承自原型的</span></div><div class="line"><span class="comment">// 顺便复习下instanceof和typeof</span></div><div class="line"><span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof</span></div><div class="line"><span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof</span></div><div class="line"><span class="comment">// 除了三者作用的区别以外，需要注意的是，hasOwnProperty是函数，instanceof和typeof是运算符</span></div><div class="line"><span class="comment">// 其实MDN上写的instanceof是运算符，typeof是操作符，特意查了一下，在英语中操作符和运算符都叫operator，应该可以认为是一个东西吧</span></div><div class="line"><span class="comment">// 与函数的区别在于，一个是符号，一个是有名称的，另外，函数有明确定义的参数表，符号没有</span></div><div class="line"><span class="comment">// 当然，从广义来上来看，任何一个运算符都可看做是一个函数，而它的运算数可看做参数</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hasOwn</span> (<span class="params">obj: Object, key: string</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> hasOwnProperty.call(obj, key)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isPrimitive"><a href="#isPrimitive" class="headerlink" title="isPrimitive"></a>isPrimitive</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断一个值是否是基础类型？字面上看primitive是原始的意思……</span></div><div class="line"><span class="comment">// 总之就是判断传入的参数是否是数字或者字符串</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPrimitive</span> (<span class="params">value: any</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'string'</span> || <span class="keyword">typeof</span> value === <span class="string">'number'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="cached"><a href="#cached" class="headerlink" title="cached"></a>cached</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成一个带缓存的纯函数</span></div><div class="line"><span class="comment">// 就是会把每次函数执行的结果缓存起来</span></div><div class="line"><span class="comment">// 根据纯函数的定义，传入同样的参数值，函数总是求出同样的结果，这样处理之后可以大幅提升函数的运算速度</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cached</span>&lt;<span class="title">F</span>: <span class="title">Function</span>&gt; (<span class="params">fn: F</span>): <span class="title">F</span> </span>&#123;</div><div class="line">  <span class="comment">// 定义缓存对象</span></div><div class="line">  <span class="keyword">const</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">cachedFn</span> (<span class="params">str: string</span>) </span>&#123;</div><div class="line">    <span class="comment">// 根据传入的参数取缓存</span></div><div class="line">    <span class="keyword">const</span> hit = cache[str]</div><div class="line">    <span class="comment">// 检查缓存是否存在，如果存在就直接返回缓存，缓存不存在就运行函数缓存结果</span></div><div class="line">    <span class="keyword">return</span> hit || (cache[str] = fn(str))</div><div class="line">  &#125;: any)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="camelize"><a href="#camelize" class="headerlink" title="camelize"></a>camelize</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将破折号分割的命名修改为驼峰命名</span></div><div class="line"><span class="comment">// 感觉是在解析模板时，将tag name转换为 class name用的</span></div><div class="line"><span class="keyword">const</span> camelizeRE = <span class="regexp">/-(\w)/g</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> camelize = cached((str: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> str.replace(camelizeRE, (_, c) =&gt; c ? c.toUpperCase() : <span class="string">''</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="capitalize"><a href="#capitalize" class="headerlink" title="capitalize"></a>capitalize</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将字符串首字母转换为大写的函数</span></div><div class="line"><span class="comment">// 估计是跟camelize配合一起使用的吧</span></div><div class="line"><span class="comment">// 最后的效果就是：&lt;my-component&gt; ==&gt; MyComponent</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> capitalize = cached((str: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>).toUpperCase() + str.slice(<span class="number">1</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="hyphenate"><a href="#hyphenate" class="headerlink" title="hyphenate"></a>hyphenate</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将驼峰命名再改回中划线命名……(￣.￣)</span></div><div class="line"><span class="comment">// 效果类似于：ABCD =&gt; a-b-c-d</span></div><div class="line"><span class="keyword">const</span> hyphenateRE = <span class="regexp">/([^-])([A-Z])/g</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> hyphenate = cached((str: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> st</div><div class="line">    <span class="comment">// 这里要调用两次replace是因为，如果是 ABCD 这种包含三个连续大写字母的字符串，</span></div><div class="line">    <span class="comment">// 只replace一次会变成A-BC-D这样，需要再replace一次……</span></div><div class="line">    .replace(hyphenateRE, <span class="string">'$1-$2'</span>)</div><div class="line">    .replace(hyphenateRE, <span class="string">'$1-$2'</span>)</div><div class="line">    .toLowerCase()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单实现的bind方法，源码的注释中说比原生的bind快</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">fn: Function, ctx: Object</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">boundFn</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> l: number = <span class="built_in">arguments</span>.length</div><div class="line">    <span class="keyword">return</span> l</div><div class="line">      ? l &gt; <span class="number">1</span></div><div class="line">        ? fn.apply(ctx, <span class="built_in">arguments</span>)</div><div class="line">        : fn.call(ctx, a)</div><div class="line">      : fn.call(ctx)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 记录原始函数的参数个数</span></div><div class="line">  boundFn._length = fn.length</div><div class="line">  <span class="keyword">return</span> boundFn</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将类数组对象转化为一个数组，其实这个操作挺常见的，但是这样用循环处理貌似效率低呢</span></div><div class="line"><span class="comment">// 测试了一下使用Array.prototype上的方法来做转换会快100倍……</span></div><div class="line"><span class="comment">// 不知道为啥不用……</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toArray</span> (<span class="params">list: any, start?: number</span>): <span class="title">Array</span>&lt;<span class="title">any</span>&gt; </span>&#123;</div><div class="line">  start = start || <span class="number">0</span></div><div class="line">  <span class="keyword">let</span> i = list.length - start</div><div class="line">  <span class="keyword">const</span> ret: <span class="built_in">Array</span>&lt;any&gt; = <span class="keyword">new</span> <span class="built_in">Array</span>(i)</div><div class="line">  <span class="keyword">while</span> (i--) &#123;</div><div class="line">    ret[i] = list[i + start]</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> ret</div><div class="line">&#125;</div><div class="line"><span class="comment">// 用14年的mac air测试，</span></div><div class="line"><span class="comment">// 使用concat和slice来做转换的版本，转换10000次耗时10ms，</span></div><div class="line"><span class="comment">// 用循环的版本耗时1000ms</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toArray</span> (<span class="params">list: any, start?: number</span>): <span class="title">Array</span>&lt;<span class="title">any</span>&gt; </span>&#123;</div><div class="line">  start = start || <span class="number">0</span></div><div class="line">  <span class="keyword">const</span> ret: <span class="built_in">Array</span>&lt;any&gt; = [].concat(list)</div><div class="line">  <span class="keyword">return</span> ret.slice(start)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单的浅拷贝，原来用的object.keys来取key，现在改成用循环了，估计用原生API效率低吧</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span> (<span class="params">to: Object, _from: ?Object</span>): <span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> _from) &#123;</div><div class="line">    to[key] = _from[key]</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> to</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isObject"><a href="#isObject" class="headerlink" title="isObject"></a>isObject</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 超简单的对象检查……</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isObject</span> (<span class="params">obj: mixed</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isPlainObject"><a href="#isPlainObject" class="headerlink" title="isPlainObject"></a>isPlainObject</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用Object.prototype.toString做的严格对象检查</span></div><div class="line"><span class="keyword">const</span> toString = <span class="built_in">Object</span>.prototype.toString</div><div class="line"><span class="keyword">const</span> OBJECT_STRING = <span class="string">'[object Object]'</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span> (<span class="params">obj: any</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> toString.call(obj) === OBJECT_STRING</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="toObject"><a href="#toObject" class="headerlink" title="toObject"></a>toObject</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 讲一个元素都是对象的数组合并成一个对象……</span></div><div class="line"><span class="comment">// 貌似是用来将标签的属性合并为一个配置对象用的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toObject</span> (<span class="params">arr: Array&lt;any&gt;</span>): <span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> res = &#123;&#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (arr[i]) &#123;</div><div class="line">      extend(res, arr[i])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res</div><div class="line">&#125;</div><div class="line"><span class="comment">// 话说之前看到的使用reduce来遍历对象的方法，其实也能够使在这里的</span></div><div class="line"><span class="comment">// 比如这样</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toObject</span> (<span class="params">arr: Array&lt;any&gt;</span>): <span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">res, cur</span>) =&gt;</span> extend(res,cur), &#123;&#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 是不是简洁多了呢？</span></div></pre></td></tr></table></figure>
<h2 id="noop"><a href="#noop" class="headerlink" title="noop"></a>noop</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不执行操作的空函数</span></div><div class="line"><span class="comment">// 抓要是为了兼容那些需要函数作为参数的函数，有没有可做的操作时用的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">noop</span> (<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="no"><a href="#no" class="headerlink" title="no"></a>no</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 永远返回false的函数，作用跟noop一样的</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> no = <span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">false</span></div></pre></td></tr></table></figure>
<h2 id="identity"><a href="#identity" class="headerlink" title="identity"></a>identity</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回传入的参数，同上，嗯……</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> identity = <span class="function">(<span class="params">_: any</span>) =&gt;</span> _</div></pre></td></tr></table></figure>
<h2 id="genStaticKeys"><a href="#genStaticKeys" class="headerlink" title="genStaticKeys"></a>genStaticKeys</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用来将模块数组转换出模块名的一个字符串……</span></div><div class="line"><span class="comment">// 这个方法也是用了reduce来做遍历赋值，使用这种方法还真是挺简洁的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">genStaticKeys</span> (<span class="params">modules: Array&lt;ModuleOptions&gt;</span>): <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> modules.reduce(<span class="function">(<span class="params">keys, m</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> keys.concat(m.staticKeys || [])</div><div class="line">  &#125;, []).join(<span class="string">','</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="looseEqual"><a href="#looseEqual" class="headerlink" title="looseEqual"></a>looseEqual</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单比较两个对象是否一致，就是转成字符串然后比较字符串是否一致</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">looseEqual</span> (<span class="params">a: mixed, b: mixed</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> isObjectA = isObject(a)</div><div class="line">  <span class="keyword">const</span> isObjectB = isObject(b)</div><div class="line">  <span class="keyword">if</span> (isObjectA &amp;&amp; isObjectB) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(a) === <span class="built_in">JSON</span>.stringify(b)</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isObjectA &amp;&amp; !isObjectB) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(a) === <span class="built_in">String</span>(b)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="looseIndexOf"><a href="#looseIndexOf" class="headerlink" title="looseIndexOf"></a>looseIndexOf</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用了looseEqual的indexOf</span></div><div class="line"><span class="comment">// 话说这个判断方法的思想就是，只要有同样的结构，那么就是同样的对象</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">looseIndexOf</span> (<span class="params">arr: Array&lt;mixed&gt;, val: mixed</span>): <span class="title">number</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (looseEqual(arr[i], val)) <span class="keyword">return</span> i</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="once"><a href="#once" class="headerlink" title="once"></a>once</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 确保只调用一次函数</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">once</span> (<span class="params">fn: Function</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">  <span class="comment">// called应该算是一个锁吧</span></div><div class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!called) &#123;</div><div class="line">      <span class="comment">// 上锁</span></div><div class="line">      called = <span class="literal">true</span></div><div class="line">      fn()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>昏昏沉沉的总算是完了……不知道是缺觉还是怎么的，写着技术的文章，心里却想到了很多技术之外的东西。不过今天实在是没精力写了，留个TODO吧，后续整理好了再更新上来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊……写这篇博客的时候我刚上了一宿的线……现在多一个字都不想说了……直接开始吧……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>nodejs热更新的方法</title>
    <link href="http://brooch.me/2017/04/07/nodejs-hotreload/"/>
    <id>http://brooch.me/2017/04/07/nodejs-hotreload/</id>
    <published>2017-04-07T14:04:44.000Z</published>
    <updated>2017-04-14T08:47:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，没错，我又来要放水了今天……这个周末停休了，没辙没辙的……</p>
<a id="more"></a>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>话说上周看了朋友的一篇博客 <a href="https://yj1438.github.io/2017/03/31/respawn.html" target="_blank" rel="external">通过 respawn 加强需要即时生效的开发环境构建系统</a> ，里面说到了用子进程来更新应用的方法，个人感觉就是像Jetty那样的热部署机制吧。但是归根结底，还是要重新启动整个应用才能完成更新，这点上来说感觉并不完美。那么能不能做到真正的0重启热更新代码呢？本文提一个另类的思路给大家参考一下。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>废话不多说了，认真读过nodejs文档的人都应该注意过这个api <a href="http://nodejs.cn/api/globals.html#globals_require_cache" target="_blank" rel="external">require.cache</a> 。文档里写的很清楚，如果这个对象中的引用被清除了，下次再调用就会重新加载，我们可以使用这个机制来热加载更新的模块。</p>
<p>下面有个小栗子可以验证这个思路的可行性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanCache</span> (<span class="params">module</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> path = <span class="built_in">require</span>.resolve(<span class="built_in">module</span>);</div><div class="line">    <span class="built_in">require</span>.cache[path] &amp;&amp; (<span class="built_in">require</span>.cache[path] = <span class="literal">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span> (<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                fs.writeFileSync(<span class="string">"test.js"</span>, <span class="string">"module.exports = \""</span> + text + <span class="string">"\";"</span>);</div><div class="line">                resolve(<span class="literal">true</span>)</div><div class="line">            &#125;,<span class="number">1000</span>)</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fs.watchFile(<span class="string">'test.js'</span>,&#123;</div><div class="line">    <span class="attr">interval</span>:<span class="number">100</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    cleanCache(<span class="string">'./test'</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">require</span>(<span class="string">'./test'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">write(<span class="string">"hello"</span>)().then(write(<span class="string">"my name is zxc"</span>))</div><div class="line"></div><div class="line"><span class="comment">// test.js</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="string">''</span>;</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当然这种方法看上去挺好，但是存在的问题也挺多的。首先，这个方法没办法更新c\c++模块，另外，原生模块也是没法更新的。然后，由于 node.js 本身缺乏对有效的留存对象的扫描机制，有时会出现老模块的资源无法释放的问题，比如setInterval中引用的模块之类的……╮(￣▽￣)╭。总之，生产环境就别想了，但是用来开发调试些经常修改的简单模块的话，会是个不错的选择，比如router之类的配置文件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>怎么说呢，既然是个另类的思路，所以应用场景远没有线程替换那种方法大的。如果是生产环境，依然是推荐使用使用重启或者 PM2 的 hot reload 功能来保证稳定性。另外，webpack也有热替换的功能，HMR嘛，其实这也可以算是一个思路，具体的可以参考这个系列的文章<a href="http://jlongster.com/search?query=Backend%20Apps%20with%20Webpack" target="_blank" rel="external">Backend Apps with Webpack</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://segmentfault.com/a/1190000003888845" target="_blank" rel="external">Webpack 做 Node.js 代码热替换, 第一步</a></li>
<li><a href="https://github.com/rlidwka/node-hotswap" target="_blank" rel="external">node-hotswap</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，没错，我又来要放水了今天……这个周末停休了，没辙没辙的……&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(2)</title>
    <link href="http://brooch.me/2017/03/31/vue-source-notes-2/"/>
    <id>http://brooch.me/2017/03/31/vue-source-notes-2/</id>
    <published>2017-03-31T00:23:23.000Z</published>
    <updated>2017-03-31T07:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>啊，又到deadline了……话说因为之前一直在整理<a href="/2017/03/17/vue-source-notes-1/index.html">上一篇</a>笔记，所以过了这么长时间一直都没怎么读新的，真是惭愧啊……那么这次就读两个简单的模块吧，把简单的解决了，后续再啃硬骨头。</p>
<a id="more"></a>
<h2 id="解析单文件组件-sfc"><a href="#解析单文件组件-sfc" class="headerlink" title="解析单文件组件 sfc"></a>解析单文件组件 sfc</h2><p>之前在说目录结构的时候说过，sfc模块是用来解析.vue文件的，sfc貌似就是single file component的意思……(￣.￣;) 整个模块只有一个文件，但是逻辑却不简单呢……另外在官方文档中对单文件组件的描述也只有短短一个章节，所以感觉这部分通过源码能更充分的了解细节呢，那么先看下代码逻辑：</p>
<h3 id="parser-js"><a href="#parser-js" class="headerlink" title="parser.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/sfc/parser.js" target="_blank" rel="external">parser.js</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 用来匹配换行的正则表达式</span></div><div class="line"><span class="keyword">const</span> splitRE = <span class="regexp">/\r?\n/g</span></div><div class="line"><span class="comment">// 定义了一个判断标签是否是script、style、template标签的函数</span></div><div class="line"><span class="keyword">const</span> isSpecialTag = makeMap(<span class="string">'script,style,template'</span>, <span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="comment">// 解析单个.vue文件的函数</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parseComponent</span> (<span class="params"></span></span></div><div class="line">    <span class="regexp">//</span> 这里特意没有去掉flow的语法，顺便记录下flow的用法</div><div class="line">    <span class="regexp">//</span> 参数后面加（: 类型）表示参数的类型</div><div class="line">    content: string,</div><div class="line">    <span class="regexp">//</span> 参数后面加（?: 类型）表示可省略参数和类型， (= &#123;&#125;) 是<span class="title">es6</span>语法，表示参数的默认值……</div><div class="line">    <span class="title">options</span>?: <span class="title">Object</span> = &#123;&#125;</div><div class="line">    <span class="comment">// （function(): 类型）表示函数的返回值类型，</span></div><div class="line">    <span class="comment">// 这里的SFCDescriptor是一个自定义类型，定义在flow/complier.js里面</span></div><div class="line">    <span class="comment">// 感觉有点像结构体(struct)，另外flow还支持interface和class的定义</span></div><div class="line"> ): SFCDescriptor &#123;</div><div class="line">    <span class="comment">// 最后导出的sfc对象，分为template、script、style和自定义块四部分</span></div><div class="line">    <span class="comment">// 其中style和自定义块允许多个，template和script只允许一个</span></div><div class="line">    <span class="keyword">const</span> sfc: SFCDescriptor = &#123;</div><div class="line">        <span class="attr">template</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">script</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">styles</span>: [],</div><div class="line">        <span class="attr">customBlocks</span>: []</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 因为最后是使用compiler/parser/html-parser模块进行解析的，而html-parser模块会根据dom结构进行递归解析的，</span></div><div class="line">    <span class="comment">// 所以每个代码块都有自己的深度，这里的depth就是用来标记深度的，从后续的代码中可以看出，sfc/parser模块不会处理嵌套的块，只处理一层，这个变量被用来做锁了……</span></div><div class="line">    <span class="keyword">let</span> depth = <span class="number">0</span></div><div class="line">    <span class="comment">// 当前处理的代码块</span></div><div class="line">    <span class="keyword">let</span> currentBlock: ?(SFCBlock | SFCCustomBlock) = <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment">// 稍微调整了下代码的顺序，这个parseHTML的调用本来是放到最后的，这样其实也不会报错吧~</span></div><div class="line">    <span class="comment">// 这个调用也是整个parseComponent函数最核心的部分，使用compiler/parser/html-parser模块的能力来解析模板</span></div><div class="line">    <span class="comment">// parseHTML函数接收一个options参数（第二个），里面可以设置匹配到标签开始和结束时的钩子，通过钩子来获取自己写想要的内容，</span></div><div class="line">    <span class="comment">// 就是说，比如有个&lt;tag&gt;xxx&lt;/tag&gt;这样的内容，匹配到&lt;tag&gt;时，执行start，匹配到&lt;/tag&gt;时，执行end，</span></div><div class="line">    <span class="comment">// 如果匹配到&lt;tab/&gt;，就只执行start，貌似是这样吧，我只粗略的看了下parseHTML，后续详细看发现错了再纠正。</span></div><div class="line">    <span class="comment">// 其实直接运行parseHTML不加options也是可以的，只不过不会返回任何的内容，是完全无意义的操作呢……╮(￣▽￣)╭</span></div><div class="line">    parseHTML(content, &#123;</div><div class="line">        start,</div><div class="line">        end</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 匹配到标签开始时的钩子，主要是对标签的属性进行处理</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">start</span> (<span class="params"></span></span></div><div class="line">        tag: string,</div><div class="line">        attrs: Array&lt;Attribute&gt;,</div><div class="line">        unary: boolean,</div><div class="line">        start: number,</div><div class="line">        end: number</div><div class="line">    ) &#123;</div><div class="line">        <span class="comment">// 根据当前解析深度进行判断</span></div><div class="line">        <span class="keyword">if</span> (depth === <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 如果当前深度是0，也就是说不是嵌套的标签，则进行处理</span></div><div class="line">            <span class="comment">// 先缓存当前块的信息</span></div><div class="line">            currentBlock = &#123;</div><div class="line">                <span class="attr">type</span>: tag,</div><div class="line">                <span class="attr">content</span>: <span class="string">''</span>,</div><div class="line">                <span class="comment">// 这里的start是用来标记标签内的内容的起点的</span></div><div class="line">                start: end,</div><div class="line">                <span class="comment">// 设置属性列表这个地方有意思，通过函数定义的flow里面可以看到arrts是个数组，这里通过数组的reduce特性直接把一个[&#123;"key","value"&#125;...]形式的数组转换为&#123;"key":"value"...&#125;形式的对象了</span></div><div class="line">                attrs: attrs.reduce(<span class="function">(<span class="params">cumulated, &#123; name, value &#125;</span>) =&gt;</span> &#123;</div><div class="line">                    cumulated[name] = value || <span class="literal">true</span></div><div class="line">                    <span class="keyword">return</span> cumulated</div><div class="line">                &#125;, <span class="built_in">Object</span>.create(<span class="literal">null</span>))</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 判断是否是特殊标签</span></div><div class="line">            <span class="keyword">if</span> (isSpecialTag(tag)) &#123;</div><div class="line">                <span class="comment">// 是特殊标签，则检查标签属性，并对特殊属性进行处理</span></div><div class="line">                checkAttrs(currentBlock, attrs)</div><div class="line">                <span class="comment">// 检查是否是style标签</span></div><div class="line">                <span class="keyword">if</span> (tag === <span class="string">'style'</span>) &#123;</div><div class="line">                    <span class="comment">// 是style标签就推进队列</span></div><div class="line">                    sfc.styles.push(currentBlock)</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 不是就直接赋值</span></div><div class="line">                    sfc[tag] = currentBlock</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 不是特殊标签，则推进自定义标签的队列</span></div><div class="line">                sfc.customBlocks.push(currentBlock)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 这个属性是根据parseHTML接收的options.isUnaryTag返回的，因为在调用parseHTML时没传，所以unary总是false</span></div><div class="line">        <span class="keyword">if</span> (!unary) &#123;</div><div class="line">            <span class="comment">// 上锁</span></div><div class="line">            depth++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 检查标签的特殊属性，以便做特殊的处理，特殊属性的使用方法貌似文档中都没有写呢，</span></div><div class="line">    <span class="comment">// 貌似这些属性都是给style标签用的，我是从https://github.com/vuejs-templates/webpack 这个项目中看到的相关例子</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkAttrs</span> (<span class="params">block: SFCBlock, attrs: Array&lt;Attribute&gt;</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attrs.length; i++) &#123;</div><div class="line">            <span class="keyword">const</span> attr = attrs[i]</div><div class="line">            <span class="comment">// 可以用lang标签设置style标签内用的预处理语法，less，sass之类的</span></div><div class="line">            <span class="keyword">if</span> (attr.name === <span class="string">'lang'</span>) &#123;</div><div class="line">                block.lang = attr.value</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果设置了scoped属性，那么这个标签就只对当前组件有作用</span></div><div class="line">            <span class="keyword">if</span> (attr.name === <span class="string">'scoped'</span>) &#123;</div><div class="line">                block.scoped = <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 没找到这个属性是干嘛使的……╮(￣▽￣)╭有可能是为了配合src来用的，module作为src的前缀，</span></div><div class="line">            <span class="comment">// 具体参考 https://github.com/vuejs-templates/webpack/blob/17351f5e3b1306a117aaa80b7d575b9aa3144866/docs/static.md#asset-resolving-rules URLs prefixed with 这一小节的说明。</span></div><div class="line">            <span class="keyword">if</span> (attr.name === <span class="string">'module'</span>) &#123;</div><div class="line">                block.module = attr.value || <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 用src属性设置内容对应的文件</span></div><div class="line">            <span class="keyword">if</span> (attr.name === <span class="string">'src'</span>) &#123;</div><div class="line">                block.src = attr.value</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 匹配到标签结束时调用的钩子，主要是对标签里的内容进行处理</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">end</span> (<span class="params">tag: string, start: number, end: number</span>) </span>&#123;</div><div class="line">        <span class="comment">// 检查锁的状态，并且标签不是不对称标签(不是&lt;tag/&gt;这样的)</span></div><div class="line">        <span class="keyword">if</span> (depth === <span class="number">1</span> &amp;&amp; currentBlock) &#123;</div><div class="line">            <span class="comment">// end标记的是标签内的内容结束的位置</span></div><div class="line">            currentBlock.end = start</div><div class="line">            <span class="comment">// 去除标签内的缩进，deindent是尤大大专门为了去除缩进开发的模块……</span></div><div class="line">            <span class="keyword">let</span> text = deindent(content.slice(currentBlock.start, currentBlock.end))</div><div class="line">            <span class="comment">// 判断是不是template标签，不是统一都要加pad，目的是在lint报错时，报错信息行数能对应上……</span></div><div class="line">            <span class="keyword">if</span> (currentBlock.type !== <span class="string">'template'</span> &amp;&amp; options.pad) &#123;</div><div class="line">                text = padContent(currentBlock) + ext</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 给content属性赋值</span></div><div class="line">            currentBlock.content = text</div><div class="line">            <span class="comment">// 至空currentBlock的引用，currentBlock其实已经保存在sfc的属性的引用上了，currentBlock其实只是个临时变量，这里充分的运用了js对象都是引用类型的特性呢……</span></div><div class="line">            currentBlock = <span class="literal">null</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 解锁</span></div><div class="line">        depth--</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 用来生成能跟.vue文件行数对应上的内容用的……用来对应lint软件或者预编译软件的报错信息的行数……</span></div><div class="line">    <span class="comment">// 话说做框架可真不容易呢，不止要实现功能，连报错信息能不能对应上都要考虑……</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">padContent</span> (<span class="params">block: SFCBlock | SFCCustomBlock</span>) </span>&#123;</div><div class="line">        <span class="comment">// 获取当前这段代码到底在多少行</span></div><div class="line">        <span class="keyword">const</span> offset = content.slice(<span class="number">0</span>, block.start).split(splitRE).length</div><div class="line">        <span class="comment">// 根据不同的块使用不同的换行……</span></div><div class="line">        <span class="keyword">const</span> padChar = block.type === <span class="string">'script'</span> &amp;&amp; !block.lang</div><div class="line">        ? <span class="string">'//\n'</span></div><div class="line">        : <span class="string">'\n'</span></div><div class="line">        <span class="comment">// 最后返回对应行数的换行</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(offset).join(padChar)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 最后返回实例</span></div><div class="line">    <span class="keyword">return</span> sfc</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>怎么说呢，虽然sfc这个模块很短，但是详细分析起来还是挺费时间的……连读带写花了我4个小时啊……总的来说作用就是将文本解析成对象，话说如果要是自己也准备写dom类文件解析的，可以参考这部分的功能呢。看完这部分我觉得比较有趣的点有：</p>
<ul>
<li>flow真是好用啊，特别是看函数的时候，有了参数类型和返回类型的标注，一下就能理解用途了，连文档都省了，这么看来typescript也没那么那接受了的说……有机会一定要在项目中实践一下</li>
<li>使用reduce把数组转成对象。这个还真是开眼了以前没见过这种方法呢，以后可以借鉴到自己开发中</li>
<li>解析dom文本的方法，话说如果自己也要写解析dom操作的话（比如要写爬虫或者写要读xml、svg之类的？），可以借鉴这部分的代码呢，因为用了钩子的形式来扩展自定义操作，所以扩展性还挺强的</li>
<li>为了对应lint报错而使用pad这种方法……怎么说呢，为了良好的开发体验作者还挺下功夫的呢，如果以后自己也要开发框架，借鉴这类细节肯定会给自己的作品大大加分的~</li>
</ul>
<p>以上就是我的感悟，那么你的感悟又是什么呢？有想法就留言告诉我吧，欢迎各路灌水拍砖~(￣▽￣)</p>
<p>好的那么由于时间不足本次的博客就到这里，话说我发觉笔记这种东西就得每天读每天写效果才更好，所以我觉得要不要就改成日更算了~所以如果不出意外的话，大概可能maybe也许明天就会更新了呢~！能不能准时更新，就全看米娜桑点赞打赏转发安利发评论的热情啦~！</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊，又到deadline了……话说因为之前一直在整理&lt;a href=&quot;/2017/03/17/vue-source-notes-1/index.html&quot;&gt;上一篇&lt;/a&gt;笔记，所以过了这么长时间一直都没怎么读新的，真是惭愧啊……那么这次就读两个简单的模块吧，把简单的解决了，后续再啃硬骨头。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(1)</title>
    <link href="http://brooch.me/2017/03/17/vue-source-notes-1/"/>
    <id>http://brooch.me/2017/03/17/vue-source-notes-1/</id>
    <published>2017-03-17T08:37:50.000Z</published>
    <updated>2017-04-21T06:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实我早就开始读vue的源码了，那会儿还是1.x版本，但是因为懒没有坚持下来，现在都已经更新到2.x了……总之坚持读完吧。vue的源码还是比较好读的，因为注释清楚又有中文文档对照，所以作为读源码练手的对象非常合适。这次我读的2.20的release版本，我阅读的习惯是，不只看大概流程，会把每个函数都看一遍，学习借鉴细节。之后的笔记也会以这个思路来写，希望能给自己和看的人带来帮助吧。<br><a id="more"></a></p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>分支：master<br>commit id：2a19f911dc8631d44b7c7e63c4db57ef28ac5e69<br>版本：2.20 release</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>简单写下vue的目录结构，标注下他们都是干嘛用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">|</div><div class="line">|-- + benchmarks 基准测试，用来测性能的</div><div class="line">|-- + build 构建脚本主要都放这里</div><div class="line">|-- + dist 构建后的web端版本的输出目录</div><div class="line">|-- + examples 各种vue使用的例子</div><div class="line">|-- + flow flow的规则文件，flow是facebook出的一套检验js变量类型的框架</div><div class="line">|-- + packages 构建后server side render和weex版本的输出目录</div><div class="line">|-- + src 构建前的源码</div><div class="line">|-- + test 各种测试用例</div><div class="line">|-- + types 类型检查测试的部分，用typescript写的</div><div class="line">|-- .babelrc 转es5的配置，vue用的不是babel用的bubble</div><div class="line">|-- .eslintrc eslint的配置</div><div class="line">|-- .eslintignore eslint忽略的文件夹</div><div class="line">|-- .flowconfig flowtype的配置文件</div><div class="line">|-- BACKERS.md 捐款列表，二百五那栏还没人捐，想排前排的土豪赶紧行动吧</div><div class="line">|-- circle.yml CircleCI集成测试平台的配置文件</div><div class="line">|-- package.json 所有工作流的命令都定义在scripts里面</div><div class="line">|-- yarn.lock yarn生成的依赖文件，估计开发过程中用的yarn替换了npm</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>虽然这感觉很多余，但是对于小白来说应该很重要吧，我刚看的时候为了搞明白<a href="https://flowtype.org/" target="_blank" rel="external">flow</a>和<a href="http://www.blogjava.net/qileilove/archive/2012/07/05/382241.html" target="_blank" rel="external">benchmarks</a>是个啥多少浪费了写时间……</p>
<h2 id="打包构建"><a href="#打包构建" class="headerlink" title="打包构建"></a>打包构建</h2><p>vue是用npm的<a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="external">scripts</a>来定义工作流命令的，貌似用这种方式取代grunt、gulp已经越来越流行了呢……构建命令大体分为四类，dev、build、test、release，下面列出了所有的命令，并注释了是做啥的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="comment">//...</span></div><div class="line">    <span class="string">"scripts"</span>: &#123;</div><div class="line">        <span class="comment">/*------ develop ------*/</span></div><div class="line">        <span class="string">"dev"</span>: <span class="string">"TARGET=web-full-dev rollup -w -c build/config.js"</span>,</div><div class="line">        <span class="string">"dev:cjs"</span>: <span class="string">"TARGET=web-runtime-cjs rollup -w -c build/config.js"</span>,</div><div class="line">        <span class="string">"dev:ssr"</span>: <span class="string">"TARGET=web-server-renderer rollup -w -c build/config.js"</span>,</div><div class="line">        <span class="string">"dev:compiler"</span>: <span class="string">"TARGET=web-compiler rollup -w -c build/config.js"</span>,</div><div class="line">        <span class="string">"dev:weex"</span>: <span class="string">"TARGET=weex-framework rollup -w -c build/config.js"</span>,</div><div class="line">        <span class="string">"dev:weex:compiler"</span>: <span class="string">"TARGET=weex-compiler rollup -w -c build/config.js"</span>,</div><div class="line"></div><div class="line">        <span class="comment">/*------ build ------*/</span></div><div class="line">        <span class="string">"build"</span>: <span class="string">"node build/build.js"</span>,</div><div class="line">        <span class="string">"build:ssr"</span>: <span class="string">"npm run build -- vue.runtime.common.js,vue-server-renderer"</span>,</div><div class="line">        <span class="string">"build:weex"</span>: <span class="string">"npm run build -- weex-vue-framework,weex-template-compiler"</span>,</div><div class="line"></div><div class="line">        <span class="comment">/*------ test ------*/</span></div><div class="line">        <span class="string">"dev:test"</span>: <span class="string">"karma start build/karma.dev.config.js"</span>,</div><div class="line">        <span class="string">"test"</span>: <span class="string">"npm run lint &amp;&amp; flow check &amp;&amp; npm run test:types &amp;&amp; npm run test:cover &amp;&amp; npm run test:e2e -- --env phantomjs &amp;&amp; npm run test:ssr"</span>,</div><div class="line">        <span class="string">"test:unit"</span>: <span class="string">"karma start build/karma.unit.config.js"</span>,</div><div class="line">        <span class="comment">// 单元测试</span></div><div class="line">        <span class="string">"test:cover"</span>: <span class="string">"karma start build/karma.cover.config.js"</span>,</div><div class="line">        <span class="comment">// 覆盖率测试</span></div><div class="line">        <span class="string">"test:e2e"</span>: <span class="string">"npm run build -- vue.min.js &amp;&amp; node test/e2e/runner.js"</span>,</div><div class="line">        <span class="comment">// e2e(end to end，就是所谓的“用户真实场景”)测试</span></div><div class="line">        <span class="string">"test:weex"</span>: <span class="string">"npm run build:weex &amp;&amp; jasmine JASMINE_CONFIG_PATH=test/weex/jasmine.json"</span>,</div><div class="line">        <span class="comment">// weex 的单元测试</span></div><div class="line">        <span class="string">"test:ssr"</span>: <span class="string">"npm run build:ssr &amp;&amp; jasmine JASMINE_CONFIG_PATH=test/ssr/jasmine.json"</span>,</div><div class="line">        <span class="comment">// sever side render 的单元测试</span></div><div class="line">        <span class="string">"test:sauce"</span>: <span class="string">"npm run sauce -- 0 &amp;&amp; npm run sauce -- 1 &amp;&amp; npm run sauce -- 2"</span>,</div><div class="line">        <span class="string">"test:types"</span>: <span class="string">"tsc -p ./types/test/tsconfig.json"</span>,</div><div class="line">        <span class="comment">// 类型校验</span></div><div class="line">        <span class="string">"lint"</span>: <span class="string">"eslint src build test"</span>,</div><div class="line">        <span class="comment">// 规范校验</span></div><div class="line">        <span class="string">"flow"</span>: <span class="string">"flow check"</span>,</div><div class="line">        <span class="comment">// 类型校验</span></div><div class="line">        <span class="string">"sauce"</span>: <span class="string">"SAUCE=true karma start build/karma.sauce.config.js"</span>,</div><div class="line">        <span class="comment">// 兼容性测试</span></div><div class="line">        <span class="string">"bench:ssr"</span>: <span class="string">"npm run build:ssr &amp;&amp; NODE_ENV=production node benchmarks/ssr/renderToString.js &amp;&amp; NODE_ENV=production VUE_ENV=server node benchmarks/ssr/renderToStream.js"</span>,</div><div class="line">        <span class="comment">// 基准测试，用来测性能的</span></div><div class="line"></div><div class="line">        <span class="comment">/*------ release ------*/</span></div><div class="line">        <span class="string">"release"</span>: <span class="string">"bash build/release.sh"</span>,</div><div class="line">        <span class="string">"release:weex"</span>: <span class="string">"bash build/release-weex.sh"</span>,</div><div class="line">        <span class="string">"install:hooks"</span>: <span class="string">"ln -fs ../../build/git-hooks/pre-commit .git/hooks/pre-commit"</span></div><div class="line">    &#125;</div><div class="line"><span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>dev系列命令是开发框架的时候用的。看完所有命令之后知道了以下这些信息：</p>
<ul>
<li>dev系列命令都是 <code>TARGET=XXX rollup -w -c build/config.js</code> 的形式。可以看出vue打包用的是<a href="http://rollupjs.org/" target="_blank" rel="external">rollup</a></li>
<li>-w 是watch，-c 是指定config文件，build/config.js是rollup的配置文件。build/config.js 内部根据 TARGET 参数获取不同的构建配置。</li>
<li>话说使用自己的项目也是使用rollup打包的话，build/config.js 可以作为很好的参考或者模板呢。</li>
<li>使用的rollup插件：<ul>
<li>rollup-plugin-flow-no-whitespace<br>插件用来去掉flow使用的类型检查代码。有趣的是，插件是还是作者自己写的，只是为了想去掉打包后遗留的空格……还真是洁癖呢，噗噗……</li>
<li>rollup-plugin-buble<br>替代babel，用来转换es5用的。</li>
<li>rollup-plugin-alias<br>用来配置打包过程中各个模块的路径映射，具体的配置写在 build/alias.js 中。这样代码中就可以用src作为根目录引用模块了。值得注意的是，src/platforms 目录下的 web 模块和 weex 模块，也都做了映射，所以在看代码时有 import xxx from ‘web/xxx’的引用，就都是从 platforms 下引用的。貌似这是缩短引用路径、区分目录结构和代码逻辑的好方法呢，实际开发中也可以借鉴。</li>
</ul>
</li>
<li><p>简单查了一些rollup的资料，rollup的特性包括：</p>
<ul>
<li>打包后的代码没有 require，import的，而是直接插入到文件中</li>
<li>可以生成 AMD，CMD，UMD 甚至 ES6 模块文件</li>
<li><a href="http://www.2ality.com/2015/12/webpack-tree-shaking.html" target="_blank" rel="external">tree-shaking</a>，会移除未使用到的 ES6 exports模块，打包后的文件体积更小</li>
<li>配置简单</li>
<li>没有自带的模块机制，使用es6原生的模块依赖机制</li>
</ul>
<p>虽然webpack2也支持tree-shaking，但是从rollup的配置简单、功能单一、打包文件没有多余代码这些特点俩看，感觉很适合用来打包独立库或者框架这种都是js并且结构相对简单的项目呢。</p>
</li>
<li>相比之前，现在的dev纯粹是按照不同参数做打包并且watch了，我记得1.x版本还带webpack-dev的调试服务器来着，现在的这套比之前的轻了很多，估计打包速度也会快不少，这点和vue本身的理念也有相符吧？</li>
</ul>
<p>build系列命令用来打包所有配置。总结下看到的知识：</p>
<ul>
<li>build系列命令都是运行 build/build.js 这个文件。这个文件中的逻辑就是通过 build/config.js 获取所有的配置，然后串行用rollup打包。</li>
<li>后面的参数可以用来过滤要打包的配置，获取参数和过滤的逻辑也是写在 build/config.js 里面的。</li>
<li>如果想编写串行执行任务和获取参数做过滤一类的工作流脚本，又不想借助grunt、gulp之类的任务管理库，build/build.js 里部分的这两部分代码可以作为很好的参考。</li>
</ul>
<p>test系列命令是用来搞自动化测试的，具体的分析：</p>
<ul>
<li>测试这部分包含的内容很多，现在只是粗略的看了看。先读源码，后续再详细解读这部分的内容</li>
<li>大部分命令是做啥的我都标出来是干嘛的了，其他命令只是对其他命令的一个封装，话说包含的测试还真是全呢……</li>
<li>其实这些命令也都不是让你自己执行的，这些都是用来搞自动化测试的，自动自动化测试的命令配置在 build/ci.sh 这个脚本文件里面。这个脚本会在CircleCI的hook中被调用。话说想搞持续集成的可以参考这个配置呢。</li>
<li>同时使用了facebook的<a href="https://flowtype.org" target="_blank" rel="external">flow</a>和typescript做类型检查，在类型检查这方面真是费了牛劲了……</li>
</ul>
<p>release系列命令是用来发布rlease版本的：</p>
<ul>
<li>调用了build文件下对应的sh文件，对于windows用户还真是不友好呢哈哈哈</li>
<li>脚本里主要做了设置版本、自动化测试、构建、打tag、提交、npm推送这几件事</li>
<li>还提别为weex做了独立的发布脚本，看来还真是深度合作呢</li>
<li>其实如果团队都是用mac或者linux，或者都用开发机，可以用这套脚本作为工作流中的一个环节，自动发布提交。那句话怎么说的来着，“重复七次以上的工作都应该自动化”？大概吧……</li>
</ul>
<h2 id="源码-src"><a href="#源码-src" class="headerlink" title="源码 src"></a>源码 src</h2><p>接下来看具体源码，所有的源码都在src目录下，先看下src目录下文件的结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">|</div><div class="line">|-- + compiler 解析模板用的？</div><div class="line">|-- + core vue的核心，</div><div class="line">|-- + entries 各种入口的封装</div><div class="line">|-- + platforms 不同平台下自己独特的模块</div><div class="line">|-- + server server side render的</div><div class="line">|-- + sfc 用来将.vue文件转坏为sfc(可识别组件)对象的</div><div class="line">|-- + shared 共享的模块，一个工具集</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>刚才说到的 build/config.js 文件，里面标记了所有的打包配置，从打包配置中可以看出，所有的入口都在 src/entries 文件夹中，我阅读源码的习惯是从入口开始读。</p>
<h2 id="入口-src-entries"><a href="#入口-src-entries" class="headerlink" title="入口 src/entries"></a>入口 src/entries</h2><p>src/entries 的目录结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">|</div><div class="line">|-- web-compiler.js 只包含vue的模板解析器和.vue解析器</div><div class="line">|-- web-runtime.js 只包含vue的运行时部分的代码</div><div class="line">|-- web-runtime-with-compiler.js 这个模块既包含解析器又包含运行时</div><div class="line">|-- web-server-renderer.js server side render 用的模块，和客户端的不一样，不分解析器和运行时</div><div class="line">|-- weex-compiler.js weex的解析器</div><div class="line">|-- weex-factory.js weex的运行时</div><div class="line">|-- weex-framework.js 这个貌似是weex的框架？因为不了解weex，所以只能靠猜的了</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>具体每个文件的用途已经在上面简单的标注出来了，主要包含web端，server端，客户端(weex)三部分，下面详细解读各个文件，因为对server端和客户端并不熟悉，所以这部分只能粗浅的猜猜了……</p>
<h3 id="web-compiler-js"><a href="#web-compiler-js" class="headerlink" title="web-compiler.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/web-compiler.js" target="_blank" rel="external">web-compiler.js</a></h3><p>这个文件比较简单，就是导出了解析sfc模块和compiler模块的接口。compiler模块的作用是用来解析模板的，对应的是 src/compiler 模块，粗略的看了下是使用new Function将字符串转换为js代码，所以对于不支持或者认为这样不安全的环境，vue会给出错误提示。具体的源码后续再继续详细读。</p>
<h3 id="web-runtime-js"><a href="#web-runtime-js" class="headerlink" title="web-runtime.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/web-runtime.js" target="_blank" rel="external">web-runtime.js</a></h3><p>感觉web-runtime是对core的vue模块做了再加工</p>
<p>大概逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//...</span></div><div class="line"><span class="comment">// 添加不同平台下的功能函数，web平台下都有对应的的接口，weex平台下都是空函数</span></div><div class="line"><span class="comment">// 各函数的具体用途看到了再解释吧</span></div><div class="line">Vue.config.mustUseProp = mustUseProp</div><div class="line">Vue.config.isReservedTag = isReservedTag</div><div class="line">Vue.config.getTagNamespace = getTagNamespace</div><div class="line">Vue.config.isUnknownElement = isUnknownElement</div><div class="line"></div><div class="line"><span class="comment">// 添加不同平台下的组件和命令</span></div><div class="line">extend(Vue.options.directives, platformDirectives)</div><div class="line">extend(Vue.options.components, platformComponents)</div><div class="line"></div><div class="line"><span class="comment">// 安装虚拟dom的补丁函数，貌似只有在客户端下才会用到，服务端是没有的，另外weex也有自己的补丁函数，所以这里知识安装浏览器的patch函数</span></div><div class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</div><div class="line"></div><div class="line"><span class="comment">// 定义$mount函数，只是对核心的mountComponent方法进行了个简单的封装</span></div><div class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params">el, hydrating</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// core/instance/lifecycle模块下的mountComponent</span></div><div class="line">    <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义devtool的全局钩子(hook)</span></div><div class="line"><span class="comment">// vue有自己的chrome插件调试工具，下面这段代码就是启动调试工具的</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 判断是否配置了使用调试工具，其实就是看是不是生产版本……</span></div><div class="line">    <span class="keyword">if</span> (config.devtools) &#123;</div><div class="line">        <span class="comment">// 判断是否安装了调试工具，是通过检查全局变量window.__VUE_DEVTOOLS_GLOBAL_HOOK__来判断的</span></div><div class="line">        <span class="keyword">if</span> (devtools) &#123;</div><div class="line">            <span class="comment">// 如果有就触发调试工具的init事件，所以如果项目中使用了生产版本的vue或者没有使用vue，调试工具都不会启动的</span></div><div class="line">            devtools.emit(<span class="string">'init'</span>, Vue)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; isChrome) &#123;</div><div class="line">            <span class="comment">// 如果没有安装调试工具，并且使用的不是生产版本的vue，用的还是chrome浏览器，就提示用户下载调试工具</span></div><div class="line">            <span class="built_in">console</span>[<span class="built_in">console</span>.info ? <span class="string">'info'</span> : <span class="string">'log'</span>](</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            )</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果不是生产版本，提示用户现在使用的是开发版本，正式部署的时候用生产版本</span></div><div class="line">    <span class="comment">// config中的productionTip和devtools其实都是process.env.NODE_ENV，貌似在开发过程中应该可以配置的说</span></div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</div><div class="line">        config.productionTip !== <span class="literal">false</span> &amp;&amp;</div><div class="line">        inBrowser &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">console</span> !== <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>[<span class="built_in">console</span>.info ? <span class="string">'info'</span> : <span class="string">'log'</span>](</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment">// 最后导出Vue模块</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure>
<h3 id="web-runtime-with-compiler-js"><a href="#web-runtime-with-compiler-js" class="headerlink" title="web-runtime-with-compiler.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/web-runtime-with-compiler.js" target="_blank" rel="external">web-runtime-with-compiler.js</a></h3><p>这个文件作为一个入口，将已经整合好的compiler和runtime再一次整合封装，最终导出浏览器用的vue构造函数。</p>
<p>代码的大概逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 定义一个纯函数，之前我在mobx的文章中写过，纯函数的输入、输出都是固定的，所以可以用来做缓存</span></div><div class="line"><span class="comment">// cached函数虽然表面上看引用自core/util/index，实际是core/util/index引用了shared/util，cached定义在shared/util中</span></div><div class="line"><span class="comment">// 利用纯函数做缓存的技巧可以应用在自己的项目中，虽然定义个对象也能搞定，但是这么封装真的是很美观呀~</span></div><div class="line"><span class="keyword">const</span> idToTemplate = cached(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> el = query(id)</div><div class="line">    <span class="keyword">return</span> el &amp;&amp; el.innerHTML</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 定义了一个工具函数，看名字就知道是获取元素outerHTML的</span></div><div class="line"><span class="comment">// 之所以这么处理貌似是因为IE在取svg元素的outerHTML时有bug</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOuterHTML</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断元素是否有outerHTML属性</span></div><div class="line">    <span class="keyword">if</span> (el.outerHTML) &#123;</div><div class="line">        <span class="comment">// 有就直接使outerHTML</span></div><div class="line">        <span class="keyword">return</span> el.outerHTML</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 没有就建个空div把要获取的元素赋值进去，然后取innerHTML</span></div><div class="line">        <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</div><div class="line">        container.appendChild(el.cloneNode(<span class="literal">true</span>))</div><div class="line">        <span class="keyword">return</span> container.innerHTML</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// $mount方法是用来挂载实例的</span></div><div class="line"><span class="comment">// 这里定义的$mount是对之前在web-runtime.js里定义的$mount进行封装</span></div><div class="line"><span class="comment">// 先做个临时变量保存原来的$mount</span></div><div class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</div><div class="line"><span class="comment">// 然后定义新的</span></div><div class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params">el, hydrating</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// 判断el是否body或者html</span></div><div class="line">    <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// 如果是就中断，也就是说vue是无法在dom的根节点上挂载的</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// $options当前 Vue 实例的初始化选项</span></div><div class="line">    <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</div><div class="line">    <span class="comment">// 判断$options是否有render函数</span></div><div class="line">    <span class="keyword">if</span> (!options.render) &#123;</div><div class="line">        <span class="comment">// 没有就造个render函数出来</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// 判断$options是否有template属性</span></div><div class="line">        <span class="keyword">if</span> (template) &#123;</div><div class="line">            <span class="comment">// 如果有template属性</span></div><div class="line">            <span class="comment">// 判断template属性是否是字符串</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</div><div class="line">                <span class="comment">// 如果template是字符串，则把他当做selector使用</span></div><div class="line">                <span class="comment">// 判断selector是否是唯一的(是不是id)</span></div><div class="line">                <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</div><div class="line">                    <span class="comment">// 如果selector是唯一的，则使用selector的innerHTML作为模板</span></div><div class="line">                    <span class="comment">// 并且缓存模板内容</span></div><div class="line">                    template = idToTemplate(template)</div><div class="line">                    <span class="comment">// ...</span></div><div class="line">                &#125;</div><div class="line">            <span class="comment">// 判断template属性是否是dom节点</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</div><div class="line">                <span class="comment">// 如果是dom节点则用innerHTML作为template</span></div><div class="line">                template = template.innerHTML</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// ...</span></div><div class="line">                <span class="comment">// 如果template不符合要求，则中断程序</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</div><div class="line">            <span class="comment">// 如果没有template属性 </span></div><div class="line">            <span class="comment">// 则取挂载dom节点的outerHTML作为template</span></div><div class="line">            template = getOuterHTML(el)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果经过之前的过程获取到了template</span></div><div class="line">        <span class="comment">// 则根据获取到的template生成render函数</span></div><div class="line">        <span class="keyword">if</span> (template) &#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// 根据template生成render</span></div><div class="line">            <span class="comment">// 另外在开发版本中，还会利用window.performance统计生成render的时间，分析性能，因为这部分代码不是主要代码，所以我就删掉了</span></div><div class="line">            <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</div><div class="line">                <span class="comment">// 用来标记是否需要转换换行符的，为了兼容IE的，貌似IE和其他浏览器在处理换行符时的操作不一样啊</span></div><div class="line">                shouldDecodeNewlines: shouldDecodeNewlines,</div><div class="line">                <span class="comment">// 对应 https://cn.vuejs.org/v2/api/#delimiters ，纯文本插入分隔符，可在构建时修改</span></div><div class="line">                delimiters: options.delimiters</div><div class="line">            &#125;, <span class="keyword">this</span>)</div><div class="line">            options.render = render</div><div class="line">            options.staticRenderFns = staticRenderFns</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 调用 web-runtime.js 中定义的$mount</span></div><div class="line">    <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 将解析compile模块也绑定到Vue上</span></div><div class="line">Vue.compile = compileToFunctions</div><div class="line"><span class="comment">// 导出Vue类</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure>
<h3 id="web-server-renderer-js"><a href="#web-server-renderer-js" class="headerlink" title="web-server-renderer.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/web-server-renderer.js" target="_blank" rel="external">web-server-renderer.js</a></h3><p>这个是server side render的入口，所以与brower端用到的方法差别很大。server端只是做初步的渲染，所以只有一个生成render的函数，结构比较简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 定义一个生成render对象的函数</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _createRenderer(&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 定义一个生成render函数的工厂</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> createBundleRenderer = createBundleRendererCreator(createRenderer)</div></pre></td></tr></table></figure>
<p>这部分的功能划分的很细，做了好多的高阶函数，粗略的看了下看的段点儿晕，后续看到不同平台的代码时再详细看。</p>
<h3 id="weex-compiler-js"><a href="#weex-compiler-js" class="headerlink" title="weex-compiler.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/weex-compiler.js" target="_blank" rel="external">weex-compiler.js</a></h3><p>对应web-compiler.js，导出对应平台下的compiler模块</p>
<h3 id="weex-factory-js"><a href="#weex-factory-js" class="headerlink" title="weex-factory.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/weex-factory.js" target="_blank" rel="external">weex-factory.js</a></h3><p>对应web-runtime.js，只不过这里没有添加独特的函数，直接导出的对应平台下的runtime模块</p>
<h3 id="weex-framework-js"><a href="#weex-framework-js" class="headerlink" title="weex-framework.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/weex-framework.js" target="_blank" rel="external">weex-framework.js</a></h3><p>导出了weex/framework这个模块下的所有方法，貌似是给weex提供基础支持用的？具体的还没开始仔细看。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说这次记录了整个项目的入口部分的代码。通过这些入口，可以了解所有主要的模块的用途，项目的结构等等基础信息。当然，也能学习借鉴不少知识，我觉得以下这些点值得记录并应用到自己的项目中：</p>
<ul>
<li>npm script的定义规则和分类</li>
<li>flow和typescript做类型检查的方法</li>
<li>打包测试发布整套的工作流定义</li>
<li>通过封装重写的方式不断扩展接口</li>
<li>通过纯函数的特性做缓存</li>
<li>通过高阶函数拆分模块(具体模块的划分思想我还没看出来……)</li>
</ul>
<p>那么你又从这部分代码中悟到了什么呢？有想法就留言告诉我吧，咱们一起交流交流~(￣▽￣)</p>
<p>好的那么由于时间不足本次的博客就到这里，话说这次时间实在是太仓促了，而且解读源码的表达方法我也还没有探索好……我的感觉就是，虽然我都看懂了，但是却说不明白，下次会尝试着配上些流程图或者思维导图来记录，这样也更容易理解吧。</p>
<p>那么如果不出意外的话，大概可能maybe也许下周五会更新吧~！这次就不别安利了，毕竟我自己都觉得好坑啊……就这样了……</p>
<p>白了个白~！</p>
<h2 id="update-2017-03-30"><a href="#update-2017-03-30" class="headerlink" title="update 2017-03-30"></a>update 2017-03-30</h2><p>折腾了两个礼拜，终于想到一个自己比较满意的方式来做记录，把之前的文章大修了一遍，自我感觉还是不错，希望以后自己再看的时候不会觉得尴尬吧，哈哈哈……</p>
<p>另外我还发现了一个<a href="https://www.gitbook.com/book/114000/read-vue-code/details" target="_blank" rel="external">gitbook</a>，也在读vue的源码，不过他在几个月之前断更了……但是这种形式真心不错，后续我也打算用这种形式再整理一遍的说~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实我早就开始读vue的源码了，那会儿还是1.x版本，但是因为懒没有坚持下来，现在都已经更新到2.x了……总之坚持读完吧。vue的源码还是比较好读的，因为注释清楚又有中文文档对照，所以作为读源码练手的对象非常合适。这次我读的2.20的release版本，我阅读的习惯是，不只看大概流程，会把每个函数都看一遍，学习借鉴细节。之后的笔记也会以这个思路来写，希望能给自己和看的人带来帮助吧。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>fetch 能做哪些 XHR(XMLHttpRequest) 不能做的事</title>
    <link href="http://brooch.me/2017/03/10/difference-between-fetch-and-XHR/"/>
    <id>http://brooch.me/2017/03/10/difference-between-fetch-and-XHR/</id>
    <published>2017-03-10T11:59:29.000Z</published>
    <updated>2017-03-10T16:09:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天刷微博的时候刷到了<a href="http://weibo.com/1708684567/EyzaJpJtS" target="_blank" rel="external">紫云飞的一条微博</a>，遂决定好好整理下，方便以后面试别人或者别人面我的时候装逼用~ ╮(￣▽￣)╭</p>
<a id="more"></a>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>关于 Fetch API 和 XHR 的历史、概念、方法、属性等基础知识我就不回顾了，毕竟网上一搜一大片，文档也早就有了中文翻译，想详细了解细节的就仔细读文档吧。</p>
<ul>
<li><a href="https://fetch.spec.whatwg.org" target="_blank" rel="external">Fetch API的标准</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="external">MDN的Fetch API中文文档</a></li>
<li><a href="https://xhr.spec.whatwg.org/" target="_blank" rel="external">XHR的标准</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">MDN的XHR中文文档</a></li>
</ul>
<h2 id="直奔主题"><a href="#直奔主题" class="headerlink" title="直奔主题"></a>直奔主题</h2><p>总的来说，Fetch API 和 XHR 做的事情很相似，大部分情况我们通过 XHR 就已经能够完成开发任务了。那么为什么还需要新的 Fetch API呢？个人认为 相比 XHR， Fetch API 可以做到以下三点：</p>
<h3 id="Fetch-API更加现代"><a href="#Fetch-API更加现代" class="headerlink" title="Fetch API更加现代"></a>Fetch API更加现代</h3><p>XHR 和 Fetch API 最显著的区别就是调用方式不同。这一点大家应该都知道吧。</p>
<p>举个例子，下面两端代码完成的是同一功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用 XHR 发起一个GET请求</span></div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XHMHttpRequest();</div><div class="line">xhr.open(<span class="string">'GET'</span>, url);</div><div class="line">xhr.responseType = <span class="string">'json'</span>;</div><div class="line"></div><div class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(xhr.response);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'something wrong~ ╮(￣▽￣)╭'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xhr.send();</div><div class="line"></div><div class="line"><span class="comment">// 用 Fetch 完成同样的请求</span></div><div class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> response.json();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">jsonData</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(jsonData);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'something wrong~ ╮(￣▽￣)╭'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>相比 XHR ，Fetch 结合了现代的编码模式，使用起来更简洁 ，完成工作所需的实际代码量也更少。</p>
<h3 id="Fetch-API更底层"><a href="#Fetch-API更底层" class="headerlink" title="Fetch API更底层"></a>Fetch API更底层</h3><p>其实，刚才说到的 Fetch API 并不是指仅仅一个 fetch 方法，还包括 Request、 Response、Headers、Body都一系列原生对象。对于传统的XHR而言，你必须使用它的一个实例来发出请求和处理响应。 但是通过Fetch API，我们还能够通过刚才提到的原生对象，明确的配置请求和响应。这些底层的抽象让 Fetch API 比 XHR 更灵活。</p>
<p>举个例子，现在要下载一个很大的 utf-8 格式的 txt 文件，我们通过流式的响应体而不是文本的形式读取，最后显示在一个div中。(为什么使用流、使用流有什么好处我就不做过多解释了……)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> url = <span class="string">'Test.txt'</span>;</div><div class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> progress = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> contentLength = <span class="number">0</span>;</div><div class="line"></div><div class="line">    fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">        <span class="comment">// 通过响应头获取文件大小</span></div><div class="line">        contentLength = response.headers.get(<span class="string">'Content-Length'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> pump = <span class="function"><span class="keyword">function</span>(<span class="params">reader</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> reader.read().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">                <span class="comment">// 如果流中的内容读取完毕，result.done的值会变为true</span></div><div class="line">                <span class="keyword">if</span> (!result.done) &#123;</div><div class="line">                    <span class="comment">// 获取流中的数据</span></div><div class="line">                    <span class="keyword">var</span> chunk = result.value;</div><div class="line"></div><div class="line">                    <span class="keyword">var</span> text = <span class="string">''</span>;</div><div class="line">                    <span class="comment">// 流中的数据是一串字节码，需要做转码</span></div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">3</span>; i &lt; chunk.byteLength; i++) &#123;</div><div class="line">                        text += <span class="built_in">String</span>.fromCharCode(chunk[i]);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// 添加到页面的div中</span></div><div class="line">                    div.innerHTML += text;</div><div class="line"></div><div class="line">                    <span class="comment">// 还可以用流的长度显示当前进度</span></div><div class="line">                    progress += chunk.byteLength;</div><div class="line">                    <span class="built_in">console</span>.log(((progress / contentLength) * <span class="number">100</span>) + <span class="string">'%'</span>);</div><div class="line"></div><div class="line">                    <span class="comment">// 开始读取下一个流</span></div><div class="line">                    <span class="keyword">return</span> pump(reader);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 开始读取流中的信息</span></div><div class="line">        <span class="keyword">return</span> pump(response.body.getReader());</div><div class="line">    &#125;)</div><div class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(error);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在上面的例子中，我们不止使用了流来下载文件，还通过响应头获取了响应的具体信息，显示了下载的进度。虽然使用XHR也能做到使用流来读取文件，不过现在应该只有IE浏览器支持。但是 Fetch API 提供了访问数据的实际字节的方法，而 XHR 的 responseText 只有文本形式，这意味着在某些场景下它的作用可能非常有限。</p>
<h3 id="Fetch-API更接近未来"><a href="#Fetch-API更接近未来" class="headerlink" title="Fetch API更接近未来"></a>Fetch API更接近未来</h3><p>当我们在谈论 Fetch API 时，我们在谈论的不止是这些已经胜过 XHR 的地方，更是在谈论 Fetch API未来的可能性。比如未来基于 Fetch 和 Service Worker 的缓存和请求拦截技术。由于时间关系细节就不展开了，详细的内容可以参考一下链接。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="external">使用 Service Workers</a></li>
<li><a href="http://www.alloyteam.com/2016/01/9274/" target="_blank" rel="external">Service Worker初体验</a></li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然现在很多Fetch API 的功能还是实验性的，但是虽然现代浏览器的普及，以及诸如promise、async/await等异步语法的实现，相信不久的将来，Fetch 肯定会取代 XHR吧。到时候希望这篇文章能帮助你装逼成功，哈哈~ ╮(￣▽￣)╭</p>
<p>好的那么由于时间不足本次的博客就到这里，如果不出意外的话，大概可能maybe也许下周五会更新吧~！能不能准时更新，就全看米娜桑点赞打赏转发安利发评论的热情啦~！</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天刷微博的时候刷到了&lt;a href=&quot;http://weibo.com/1708684567/EyzaJpJtS&quot;&gt;紫云飞的一条微博&lt;/a&gt;，遂决定好好整理下，方便以后面试别人或者别人面我的时候装逼用~ ╮(￣▽￣)╭&lt;/p&gt;
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="Fetch API" scheme="http://brooch.me/tags/Fetch-API/"/>
    
      <category term="XHR" scheme="http://brooch.me/tags/XHR/"/>
    
      <category term="Service Worker" scheme="http://brooch.me/tags/Service-Worker/"/>
    
  </entry>
  
  <entry>
    <title>使用rem实现响应式布局的方法</title>
    <link href="http://brooch.me/2017/03/03/a-method-of-using-rem/"/>
    <id>http://brooch.me/2017/03/03/a-method-of-using-rem/</id>
    <published>2017-03-03T13:16:05.000Z</published>
    <updated>2017-03-03T15:52:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>前两天小徒弟问我，老看到有人说用rem实现响应式布局，具体要怎么做呢？这可问住我了，之前我只知道rem的概念却不知道要怎么用rem来实现响应式布局……赶紧忽悠她一顿，让她先去各大网站上学习下别人是怎么做的，看不懂了再来问我。自己则私底下恶补了rem实现响应式布局的知识来应付她的问题，这才算糊弄过去……</p>
<p>话说，临阵磨不能白磨了不是，总结下当时搜索到的资料供大家参考，以后真被问起来嘡嘡嘡一说，就准备接受萌新崇拜的目光吧，哈哈(￣▽￣)</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在说rem之前不得不先介绍下em，em这种单位最早源自印刷界，一个em表示一种特殊字体的大写字母M的高度。后来到了网页上，em作为一种相对长度单位，相对于当前对象内文本的字体大小。没有被css设置过的网页，一般页面字体的默认大小是16px，所以1em就等于16px。当然em除了可以作为font-size属性值得单位，还能作为width和height属性值的单位。于是前端工程师们就脑洞大开了，如果所有的宽高单位都用em，那么在做响应式布局的时候，只要改变页面上的字体大小不就能直接调整页面各个部分的大小了吗？</p>
<p>但是事与愿违，em是针对当前对象内文本的，就是说针对的是被设置过字体大小的元素的字体大小。有点绕是不是？举个例子好了，比如现在又这样一个结构，body&gt;div.A&gt;div.B，body的font-size是20px，div.B的width和height都是1em，所以当前页面上div.B的宽高就是20px，这时候如果div.A被设置了font-size为10px，div.B的宽高就是10px了，这个特性让em非常不好被应用，要用em就整个页面所有的font-size都要用em，这在没有node做自动化工具的年代简直是异常噩梦……你想写个页面，还得不停的换算px和em，想想就头疼……</p>
<p>后来rem出现了，其实rem就是root em，故名思意，rem单位就是相对于根节点（html元素）字体大小的单位。这个单位跟em不一样的区别也在这里，他是不受继承影响的，这样就可以各种单位混用，回避了不停换算的问题。当然要想使用换算的过程还是不能少，不过只是根据根节点的字体大小换算，列个换算表需要的时候查表就好了，当然这个问题在有了前端打包工具之后就彻底解决了，咱们后面再具体说。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>理解了rem的概念，揭下来说说利用rem实现响应式布局的方案。一般响应式布局分两种：</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>使用rem定义想要响应式的部分的宽高，使用媒体查询来修改html元素的font-size属性</p>
<p>简单举个例子：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>:<span class="number">16px</span>;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">480px</span>) &#123;</div><div class="line">    <span class="selector-tag">html</span> &#123;</div><div class="line">        <span class="attribute">font-size</span>:<span class="number">14px</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">960px</span>) &#123;</div><div class="line">    <span class="selector-tag">html</span> &#123;</div><div class="line">        <span class="attribute">font-size</span>:<span class="number">15px</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.some-class</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">10rem</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">10rem</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>使用rem定义想要响应式的部分的宽高，在页面resize时动态的改变html的font-size属性。</p>
<p>这个方案也是我觉得比较有趣的一个方案，他可以保证窗口大小在变化时，真个页面也等比例缩放。目前淘宝和饿了么使用的就是这个方案。</p>
<p>本来还想抄一段淘宝计算html元素font-size大小的代码，后来一搜发下阿里无线团队已经把脚本开源了，附上地址好了：<a href="https://github.com/amfe/lib-flexible/" target="_blank" rel="external">lib-flexible</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>除了以上两种方案，其他把root的font-size设死，又使用rem做单位的方案我就真不能理解了……貌似没什么意义吧？希望能白话的同学给我套靠谱的解释，这样以后别人喷我的时候我也好一嘟噜一串儿的喷回去……(￣▽￣)”</p>
<h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>刚才提到了，在使用rem的时候不得不对rem和px做转换。我个人是信奉“一切重复工作都应该交给电脑去做”这一理念的，所以我觉得转换的工作也应该交给电脑去做才对。其实前人早的轮子也已经很多了，这件事less、sass、postcss、stylus等预处理器都支持，也可以用<a href="https://www.npmjs.com/package/px2rem" target="_blank" rel="external">px2rem</a>这个npm模块，使用webpack的也有对应的loader可用<a href="https://www.npmjs.com/package/px2rem-loader" target="_blank" rel="external">px2rem-loader </a>。所以根本不用操心重复劳动的事，某种意义上来说，只要你够勤快，就根本累不着~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在查资料的过程中，也发现有人在说，字体大小自适应是一种错误的想法，因为就算是响应式布局，其实也没必要做到这一步……使用媒体查询、calc、vw单位、flex一样能够完成一个体验优秀的页面。在这件事上，我觉得还是仁者见仁吧，虽然rem实现响应式布局的感觉都有些hack，但是肯定还是有他存在的意义的，屠龙之技学会了，砍谁不是砍不是？何况有的时候，咱们程序员说了真不算，到底要不要做到完全等比例缩放这一步，还是得听产品经理的……毕竟产品小白分分钟就能让技术大牛加班啊~哈哈哈ｂ（￣▽￣）ｄ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;前两天小徒弟问我，老看到有人说用rem实现响应式布局，具体要怎么做呢？这可问住我了，之前我只知道rem的概念却不知道要怎么用rem来实现响应式布局……赶紧忽悠她一顿，让她先去各大网站上学习下别人是怎么做的，看不懂了再来问我。自己则私底下恶补了rem实现响应式布局的知识来应付她的问题，这才算糊弄过去……&lt;/p&gt;
&lt;p&gt;话说，临阵磨不能白磨了不是，总结下当时搜索到的资料供大家参考，以后真被问起来嘡嘡嘡一说，就准备接受萌新崇拜的目光吧，哈哈(￣▽￣)&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="css" scheme="http://brooch.me/tags/css/"/>
    
      <category term="rem" scheme="http://brooch.me/tags/rem/"/>
    
  </entry>
  
  <entry>
    <title>聊聊动态规划(2) -- 特征</title>
    <link href="http://brooch.me/2017/02/24/dynamic-programming-2/"/>
    <id>http://brooch.me/2017/02/24/dynamic-programming-2/</id>
    <published>2017-02-24T06:29:00.000Z</published>
    <updated>2017-02-24T15:26:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>书接前文，上回咱们说到要如何鉴别动态规划可解问题。我预告说要从计算机工作原理开始讲起……呃……貌似跟原本要讲的东西差的有点儿远呢……那么为啥非要从这么底层的问题开始讲起呢？怎么说呢……就好比我要讲西游记，如果只说一句“唐僧师徒四人去西天取经然后都修成正果了”，对于没看过西游记的人来说，唐僧是谁、师徒四人又是谁、为啥非得跑西天去取经等等一系列问题，不去翻翻原著搜搜资料是肯定不知道怎么回事的。所以还是尽量揉碎了讲吧，不然看完了还得一通翻查资料，怪麻烦的……</p>
<a id="more"></a>
<p>尽管计算机技术自20世纪40年代第一部电子通用计算机诞生以来一直飞速的发展，但是，现代计算机仍然采用冯诺依曼结构来实现。冯诺依曼结构将计算机描述为五部分：输入设备、控制器、运算器、存储器和输出设备。工作流程大概就是，输入设备传入数据，控制器发出指令，运算器根据指令做算数逻辑运算，最后存储或者输出结果。如果咱们只关注计算机的理论原理，在抽象一点的看计算机工作的整个过程，你会发现，刚才我们描述的工作过程可以用数学理论来概括。存储器可以看做一个列举了计算机存在的所有可能状态的<strong>集合</strong>，控制器指令可以看做一组<strong>状态转换函数</strong>，运算器使用状态转换函数，从输入的状态和集合的状态，推导出输出的状态。所以计算机的工作原理，可以简单的概括为，利用当前的状态计算出下一个状态（美错儿，我就是在说状态机……）。</p>
<p>我们平时编写程序，是在使用计算机帮我们解决问题。从计算机的本质是状态机这个角度来看，你思考如何编写程序来解决问题，其实就是在思考如何将这个问题表达成状态（用哪些变量，存储哪些数据）以及如何在状态之间中转换（怎样根据一些变量计算出另一些变量）。我们在看算法分析文章时，经常能看到的平时能看到的所谓<strong>空间复杂度</strong>，就是为了支持你的转换状态所必需存储的状态最多有多少；所谓<strong>时间复杂度</strong>，就是从初始状态到达最终状态中间需要做多少次状态转换。</p>
<p>还拿我们上一次说的斐波拉契数列做🌰 ：</p>
<p>我要计算第100项，之前的每一项就是这个问题的一个状态。每求新一项（新的一个状态）只需要之前的两个项（之前的两个状态）。所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；每求一个新状态，所需要的时间是常数，而之前的状态是线性递增的，所以时间复杂度就是线性的。</p>
<p>上面这种状态计算很直接，只需要依照固定的模式从旧状态计算出新状态就行（a[i]=a[i-1]+a[i-2]），不需要考虑是不是需要更多的状态，也不需要选择哪些旧状态来计算新状态。对于这样的解法，我们叫递推。</p>
<p>斐波拉契数列这个例子过于简单，以至于让人忽视了阶段的概念。所谓阶段是指随着问题的解决，在同一个时刻可能会得到的不同状态的集合。斐波拉契数列中，每一步会计算得到一个新数字，所以每个阶段只有一个状态。咱们来想象另外一个情景：假如把你放在一个围棋棋盘上的某一点，你每一步只能走一格，因为你可以东南西北随便走，所以你当你同样走四步可能会处于很多个不同的位置。从头开始走了几步就是第几个阶段，走了n步可能处于的位置称为一个状态，走了这n步所有可能到达的位置的集合就是这个阶段下所有可能的状态。</p>
<p>现在问题来了，有了阶段之后，计算新状态可能会遇到各种奇葩的情况，针对不同的情况，就需要不同的算法，下面就分情况来说明一下：</p>
<p>假如问题有n个阶段，每个阶段都有多个状态，不同阶段的状态数不必相同，一个阶段的一个状态可以得到下个阶段的所有状态中的几个。那我们要计算出最终阶段的状态数自然要经历之前每个阶段的某些状态。</p>
<p>好消息是，有时候我们并不需要真的计算所有状态。</p>
<p>比如拿这样一个的棋盘问题举例：</p>
<p>从棋盘的左上角到达右下角最短需要几步。答案很显然，用这样一个简单的问题是为了帮助我们理解阶段和状态。某个阶段确实可以有多个状态，正如这个问题中走n步可以走到很多位置一样。但是同样n步中，有哪些位置可以让我们在第n+1步中走的最远呢？没错，正是第n步中走的最远的位置。换成一句熟悉话叫做“<strong>下一步最优是从当前最优得到的</strong>”。所以为了计算最终的最优值，只需要存储每一步的最优值即可，解决符合这种性质的问题的算法就叫贪心算法。如果只看最优状态之间的计算过程是不是和斐波拉契数列的计算很像？所以计算的方法也是递推。</p>
<p>既然问题都是可以划分成阶段和状态的。这样一来我们一下子解决了一大类问题：一个阶段的最优可以由前一个阶段的最优得到。</p>
<p>如果一个阶段的最优无法用前一个阶段的最优得到呢？（需要前两个阶段得到当前最优，跟只用前一个阶段并没有本质区别）</p>
<p>最麻烦的情况在于你需要之前所有的情况才行。再举一个探索迷宫的🌰 ：</p>
<p>现在有一个迷宫，我们要计算从起点到终点的最短路线。这时你就不能只保存当前阶段的状态了，因为要求你计算最短路径，所以你必须知道之前走过的所有位置。因为即便你当前在的位置不变，之前的路线不同也会影响你之后走的路线。这时你需要保存的是之前每个阶段所经历的状态，根据之前所有的状态你才能计算出下一个状态！每个阶段的状态或许不多，但是每个状态都可以转移到下一阶段的多个状态，这种记录所有状态计算下一个状态的算法就叫搜索。所以搜索的空间复杂度就是指数级的，时间复杂度也是指数的。</p>
<p>刚才提到的那种令人不开心的情况，就叫做有后效性。</p>
<p>刚刚的情况实在太普遍，我们刚刚说到的解决方法也实在太暴力。那么，有没有哪些情况可以避免如此的暴力呢？契机就在于后效性。</p>
<p>有这么一类问题，看似需要之前所有的状态，其实不用。比如求<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97" target="_blank" rel="external">最长上升子序列（LIS）</a>长度问题：</p>
<p>在一个无序的数组里，找出一组尽可能长的由低到高排列的数，这组数就叫最长上升子序列。</p>
<p>比如，给出[5,4,1,2,3]，LIS 就是 [1,2,3]，长度是3；给出[4,2,4,5,3,7]，LIS 是 [2,4,5,7]，长度是 4。</p>
<p>看到这个问题，第一反应就是用遍历去解决。从头到尾依次枚举是否选择当前的数字，每选定一个数字就要去看看是不是满足“上升”的性质，这里第i个阶段就是去思考是否要选择第i个数，第i个阶段有两个状态，分别是选和不选。哈哈，依稀出现了刚刚搜索迷宫的影子！</p>
<p>但是当我们仔细思考之后会发现，每次当我决定要选择当前数字的时候，只需要和之前选定的一个数字比较，就能做出判断了！这是和之前迷宫问题的本质不同。这样我们就不需要记录之前所有的状态了。因为最后要求的是序列长度，所以我们只需要记录以某个元素结尾的LIS长度就好。</p>
<p>这种“每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到”的性质就叫做最优子结构；而“不管状态之前是如何得到的”的性质就叫做无后效性。</p>
<p>那么，终于可以说出动态规划问题的两个特点了，这两个特点就是<strong>最优子结构</strong>和<strong>无后效性</strong>！只要有这两个特点的问题，就可以用动态规划的方法来解决了。</p>
<p>通过之前的一系列描述我们也能看到，一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间的状态转移方式决定的！</p>
<ul>
<li>每个阶段只有一个状态 —— 用递推。</li>
<li>每个阶段的最优状态都是由上一个阶段的最优状态得到 —— 用贪心。</li>
<li>每个阶段的最优状态是由之前所有阶段的状态的组合得到 —— 用搜索。</li>
<li>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的 —— 用动态规划。</li>
</ul>
<p>另外需要注意的是，一个问题从不同的角度分析，各阶段状态的定义和状态转移方式可能都不相同，存在一个有后效性的定义，并不代表该问题不适用动态规划的方法来解。就像我最早说过的一样：寻找看问题的角度，才是动态规划的核心~</p>
<p>好的那么由于时间不足本次的博客就到这里，如果不出意外的话，大概可能maybe也许下周五会更新吧~！能不能准时更新，就全看米娜桑点赞打赏转发安利发评论的热情啦~！</p>
<p>白了个白~！</p>
<p><strong>相关资料</strong></p>
<ul>
<li><a href="https://www.zhihu.com/question/23995189" target="_blank" rel="external">什么是动态规划？动态规划的意义是什？</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书接前文，上回咱们说到要如何鉴别动态规划可解问题。我预告说要从计算机工作原理开始讲起……呃……貌似跟原本要讲的东西差的有点儿远呢……那么为啥非要从这么底层的问题开始讲起呢？怎么说呢……就好比我要讲西游记，如果只说一句“唐僧师徒四人去西天取经然后都修成正果了”，对于没看过西游记的人来说，唐僧是谁、师徒四人又是谁、为啥非得跑西天去取经等等一系列问题，不去翻翻原著搜搜资料是肯定不知道怎么回事的。所以还是尽量揉碎了讲吧，不然看完了还得一通翻查资料，怪麻烦的……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="动态规划" scheme="http://brooch.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>聊聊动态规划(1) -- 概念</title>
    <link href="http://brooch.me/2017/02/17/dynamic-programming-1/"/>
    <id>http://brooch.me/2017/02/17/dynamic-programming-1/</id>
    <published>2017-02-17T02:58:00.000Z</published>
    <updated>2017-02-24T06:43:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前某天面试了个年轻的工程师，习惯性的问了几个简单的算法题，冒泡排序二分查找之类的。他没有答上来，解释道这些平时开发中根本不会用到，就算需要，各种开源框架也都封装的烂大街了，根本不用自己写。</p>
<p>听他这么说着，仿佛看到了几年前的自己。当时我也觉得不用了解算法知识，知道冒泡快排能应付面试就得了。前端面向的是界面及交互实现，除非你填游戏或者富文本的坑，不然哪儿用的上什么算法。真需要了，上网搜呗。Max Howell 连个<a href="http://www.lintcode.com/zh-cn/problem/invert-binary-tree/" target="_blank" rel="external">翻转二叉树</a>都不会，不也照样把 Homebrew 做出来了吗。</p>
<a id="more"></a>
<p>直到我听了一次之前的领导的分享。他在分享中介绍，面试中考察算法知识，并不是想看你背了多少题，而是想考察你解决复杂问题的能力。算法能力体现的不只是知识储备，还能体现一个人的聪明才智。</p>
<p>听完之后我茅厕顿开。我的理解是，所谓的算法，其实就是你解决问题的方法。所以就算你不知道最佳答案，用你知道的知识解决问题，也算是一种算法。比如你要去个地方，可以坐公交坐地铁，你都不知道怎么坐，走过去也算是一种算法。算法题也并不是跟实际开发没有关联。就好比 “水池能装100L水，进水管每分钟进水10L，出水管每分钟出水5L，多长时间水池能满？” 这种傻逼的问题，如果改成 “一个驴牌的包包1万，你一个月挣5000，花2000，多长时间能买的起？” 不就有了实际的意义了吗……话说我还真是喜欢打比方的(￣▽￣)……</p>
<p>那么，怎么才算真正具备一定算法能力，入了算法的门儿了呢？显然只会个排序肯定是不行的……当然我并不是说排序算法就简单，各种排序算法优化啥的我觉得也挺难的……我个人觉得，在各种常见的算法中，动态规划应该算是一道坎儿，过去了就算入门儿了。winter大神也<a href="http://weibo.com/1196343093/EqtTv7Nlm" target="_blank" rel="external">说过</a>，写出动态规划，再谈算法。</p>
<p>那么动态规划到底是什么呢？</p>
<p>动态规划(dynamic programming)是求解多阶段决策过程(multistep decision process)最优化的数学方法。</p>
<p>第一次听到这个定义的时候我脑子里只有 “说人话” 这三个字……ok，让我们来仔细掰吃掰吃。</p>
<p>仔细观察发现，这个定义可以拆分成以下两部分：</p>
<ol>
<li>动态规划用来求解问题的最优化方案的</li>
<li>问题表现为多阶段决策过程</li>
</ol>
<p>最优化方案比较好理解。所谓多阶段决策，是将决策问题的全过程恰当地划分为若干个相互联系的子过程（每个子过程为一个阶段），以便按照一定的次序去求解。也就是说，一个大的问题可以被划分为若干个相互联系的子问题。这种相互联系的子问题，又叫交叠子问题。举个例子来说明交叠子问题，以<a href="http://baike.baidu.com/link?url=0EtGUr1kes840H550BpbqXbjVrUn1GmVu3HBIqrz1aFM6MI7p3NPNYNNvmYTb1nxA7LS3w9zeh5C6OcpLclmpvdg-RLJ5MIEKKe1vD3xgRAO9PE1HMkiJ2LjDGsLjxa7QiTj15vcw7yvUBpJOREm7K" target="_blank" rel="external">斐波拉契(Fibonacci)数列</a>为例，计算第100项的时候，需要计算第99项和98项；在计算第101项的时候，需要第100项和第99项，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。上述的需要再次计算的“第99项”，就叫交叠子问题。</p>
<p>在理解了上面每个学术名词的概念以后，可以得出一个结论，所谓动态规划，就是对于<b><i>某一类问题</i></b>的解决方法……呃……可能会有人觉得这是废话，但其实我们正在一步步接近问题的核心。个人觉得，动态规划的重点就在于如何鉴定“某一类问题”是动态规划可解的，而不是纠结用什么解决方法。因为用什么解决方法，取决于你从什么角度观察问题，拆分子问题。寻找看问题的角度，才是动态规划的核心。</p>
<p>那么，如何鉴定动态规划可解的问题呢？这会是一个 long long story……所以，咱们下期再讲~~(￣▽￣)~~！！！</p>
<p>好的那么由于时间不足本次的博客就到这里，简单预告一下，下期博客会从计算机是怎么工作的说起了……</p>
<p>如果不出意外的话，大概可能maybe也许下周五会更新吧~！能不能准时更新，就全看米娜桑点赞打赏转发安利发评论的热情啦~！</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前某天面试了个年轻的工程师，习惯性的问了几个简单的算法题，冒泡排序二分查找之类的。他没有答上来，解释道这些平时开发中根本不会用到，就算需要，各种开源框架也都封装的烂大街了，根本不用自己写。&lt;/p&gt;
&lt;p&gt;听他这么说着，仿佛看到了几年前的自己。当时我也觉得不用了解算法知识，知道冒泡快排能应付面试就得了。前端面向的是界面及交互实现，除非你填游戏或者富文本的坑，不然哪儿用的上什么算法。真需要了，上网搜呗。Max Howell 连个&lt;a href=&quot;http://www.lintcode.com/zh-cn/problem/invert-binary-tree/&quot;&gt;翻转二叉树&lt;/a&gt;都不会，不也照样把 Homebrew 做出来了吗。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="动态规划" scheme="http://brooch.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>年终奖避税程序优化</title>
    <link href="http://brooch.me/2017/02/03/javascript-year-bonus-evade-tax-2/"/>
    <id>http://brooch.me/2017/02/03/javascript-year-bonus-evade-tax-2/</id>
    <published>2017-02-03T06:10:25.000Z</published>
    <updated>2017-02-04T03:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>春节前写了个<a href="/2017/01/24/javascript-year-bonus-evade-tax/">年终奖避税的程序</a>。但是之前的实现上效率有点儿低，这次的博客就写一写如何优化这个程序好了（<s>其实是快到deadline才想起来要写博客临时抓的题目……</s>）</p>
<a id="more"></a>
<p>针对这个年终奖避税的程序，优化的主要方向是降低程序运行的速度。之前的实现，最耗时的是<code>getOneMonthBonus</code>和<code>getTwoMonthBonus</code>中的循环。这是在使用穷举搜索最低纳税点。针对穷举的优化，我了解的比较通用的优化方法，一种是增加缓存，一种是对穷举进行剪枝。</p>
<p>经过观察发现，拆分年终奖不可能把年终奖的50%以上拆到工资里，因为年终奖是用商数来确定交税比例的，确定比例所用的表相当于月薪减去起征点。这样我们就减少了一半的计算量。还有，我们还可以用一个对象来存储计算过的拆分方案，如果遇到相同的情况就直接使用对象里面的结果就可以了。</p>
<p>其实在编写其他程序的时候，这两种也是最简单有效的优化方法。概括的说，就是拿空间换时间和减少计算量……</p>
<p>ok，最后放上优化后的程序，这一期的瞎扯就这么愉快的结束了，咱们下期再见~！\（￣︶￣）/</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> baseQuota = <span class="number">3500</span>;</div><div class="line"><span class="keyword">var</span> taxQuota = [<span class="number">1500</span>, <span class="number">4500</span>, <span class="number">9000</span>, <span class="number">35000</span>, <span class="number">55000</span>, <span class="number">80000</span>];</div><div class="line"><span class="keyword">var</span> taxRat = [<span class="number">0.03</span>, <span class="number">0.10</span>, <span class="number">0.20</span>, <span class="number">0.25</span>, <span class="number">0.30</span>, <span class="number">0.35</span>, <span class="number">0.45</span>];</div><div class="line"><span class="keyword">var</span> taxQuick = [<span class="number">0</span>, <span class="number">105</span>, <span class="number">555</span>, <span class="number">1005</span>, <span class="number">2755</span>, <span class="number">5505</span>, <span class="number">13505</span>];</div><div class="line"><span class="keyword">var</span> cacheGetOnlyBonusTax = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> cacheGetOneMonthBonus = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> cacheGetTwoMonthBonus = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 获取不拆分年奖交税总额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOnlyBonusTax</span>(<span class="params">yearBonus, monthSalary</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> cached = cacheGetOnlyBonusTax[yearBonus + <span class="string">','</span> + monthSalary]</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> cached != <span class="string">'undefined'</span>) &#123;</div><div class="line">		<span class="keyword">return</span> cached;</div><div class="line">	&#125;</div><div class="line">    <span class="keyword">var</span> tax = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (monthSalary &gt; baseQuota) &#123;</div><div class="line">        perMonth = yearBonus / <span class="number">12</span>;</div><div class="line">        tax = round(yearBonus * getTaxRat(perMonth) - getTaxQuick(perMonth), <span class="number">2</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (yearBonus &lt; baseQuota - monthSalary) &#123;</div><div class="line">            tax = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            perMonth = (yearBonus - (baseQuota - monthSalary)) / <span class="number">10</span>;</div><div class="line">            tax = (yearBonus - (baseQuota - monthSalary)) * getTaxRat(perMonth) - getTaxQuick(perMonth);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	cacheGetOnlyBonusTax[yearBonus + <span class="string">','</span> + monthSalary] = tax</div><div class="line">    <span class="keyword">return</span> tax;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取税率等级</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaxNum</span>(<span class="params">money</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = taxQuota.length; i &lt; l; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (money &lt;= taxQuota[i]) &#123;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取税率</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaxRat</span>(<span class="params">money</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> taxRat[getTaxNum(money)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取速算扣除数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaxQuick</span>(<span class="params">money</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> taxQuick[getTaxNum(money)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取平常月交税金额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMonthTax</span>(<span class="params">money</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (money &gt; baseQuota) &#123;</div><div class="line">        <span class="keyword">return</span> getTax(money - baseQuota);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取年奖平均月交税金额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPerMonthTax</span>(<span class="params">money</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getTax(money);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算个人所得税金额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTax</span>(<span class="params">money</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> round(money * getTaxRat(money) - getTaxQuick(money), <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算增加的交税金额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMonthTaxAdd</span>(<span class="params">monthSalary, addNum</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> monthAddSalary = monthSalary + addNum;</div><div class="line">    monthTaxAdd = round(getMonthTax(monthAddSalary) - getMonthTax(monthSalary), <span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> monthTaxAdd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算金额小数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">round</span>(<span class="params">num, toFix</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">parseFloat</span>(num.toFixed(toFix), <span class="number">10</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取拆分为一个月交税总额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOneMonthBonus</span>(<span class="params">yearBonus, monthSalary</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> cached = cacheGetOneMonthBonus[yearBonus + <span class="string">','</span> + monthSalary]</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> cached != <span class="string">'undefined'</span>) &#123;</div><div class="line">		<span class="keyword">return</span> cached</div><div class="line">	&#125;</div><div class="line">    <span class="keyword">var</span> nowBonusTax = getOnlyBonusTax(yearBonus, monthSalary);</div><div class="line">	<span class="keyword">var</span> halfBonus = round(yearBonus/<span class="number">2</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; halfBonus; i++) &#123;</div><div class="line">        <span class="keyword">var</span> bonusRemain = yearBonus - i;</div><div class="line">        <span class="keyword">var</span> monthTaxAdd = getMonthTaxAdd(monthSalary, i);</div><div class="line">        <span class="keyword">var</span> bonusTax = round(getOnlyBonusTax(bonusRemain, monthSalary) + monthTaxAdd, <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (bonusTax &lt; nowBonusTax) &#123;</div><div class="line">            nowBonusTax = bonusTax;</div><div class="line">            oneMonth = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="keyword">var</span> result = &#123;</div><div class="line">		<span class="attr">tax</span>: nowBonusTax,</div><div class="line">		<span class="attr">bonus</span>: i</div><div class="line">	&#125;;</div><div class="line">	cacheGetOneMonthBonus[yearBonus + <span class="string">','</span> + monthSalary] = result;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取拆分为两个月交税总额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTwoMonthBonus</span>(<span class="params">yearBonus, monthSalary</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> cached = cacheGetTwoMonthBonus[yearBonus + <span class="string">','</span> + monthSalary]</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> cached != <span class="string">'undefined'</span>) &#123;</div><div class="line">		<span class="keyword">return</span> cached</div><div class="line">	&#125;</div><div class="line">    <span class="keyword">var</span> nowBonusTax = getOnlyBonusTax(yearBonus, monthSalary);</div><div class="line">	<span class="keyword">var</span> halfBonus = round(yearBonus/<span class="number">2</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; halfBonus; i++) &#123;</div><div class="line">        <span class="keyword">var</span> bonusRemain = yearBonus - i;</div><div class="line">        <span class="keyword">var</span> monthTaxAdd = getMonthTaxAdd(monthSalary, (i / <span class="number">2</span>)) * <span class="number">2</span>;</div><div class="line">        <span class="keyword">var</span> bonusTax = round(getOnlyBonusTax(bonusRemain, monthSalary) + monthTaxAdd, <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (bonusTax &lt; nowBonusTax) &#123;</div><div class="line">            nowBonusTax = bonusTax;</div><div class="line">            twoMonth = i / <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="keyword">var</span> result = &#123;</div><div class="line">		<span class="attr">tax</span>: nowBonusTax,</div><div class="line">		<span class="attr">bonus</span>: i</div><div class="line">	&#125;;</div><div class="line">	cacheGetTwoMonthBonus[yearBonus + <span class="string">','</span> + monthSalary] = result</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">yearBonus, monthSalary</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> startTime = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</div><div class="line">    <span class="keyword">var</span> yearBonusTax = getOnlyBonusTax(yearBonus, monthSalary);</div><div class="line">    <span class="keyword">var</span> oneMonthTax = getOneMonthBonus(yearBonus, monthSalary);</div><div class="line">    <span class="keyword">var</span> twoMonthTax = getTwoMonthBonus(yearBonus, monthSalary);</div><div class="line">    <span class="keyword">var</span> minTax = <span class="built_in">Math</span>.min(yearBonusTax, oneMonthTax.tax, twoMonthTax.tax);</div><div class="line">    <span class="keyword">var</span> bonusRemain = yearBonus - minTax;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (minTax == yearBonusTax) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'年终奖发放：'</span> + yearBonus, <span class="string">'第一个月发放：'</span> + <span class="number">0</span>, <span class="string">'第二个月发放：'</span> + <span class="number">0</span>, <span class="string">'实际收入：'</span> + bonusRemain);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minTax == oneMonthTax.tax) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'年终奖发放：'</span> + (yearBonus - oneMonthTax.bonus), <span class="string">'第一个月发放：'</span> + oneMonthTax.bonus, <span class="string">'第二个月发放：'</span> + <span class="number">0</span>, <span class="string">'实际收入：'</span> + bonusRemain);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minTax == twoMonthTax.tax) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'年终奖发放：'</span> + (yearBonus - (twoMonthTax.bonus * <span class="number">2</span>)), <span class="string">'第一个月发放：'</span> + twoMonthTax.bonus, <span class="string">'第一个月发放：'</span> + twoMonthTax.bonus, <span class="string">'实际收入：'</span> + bonusRemain);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> endTime = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'耗时：'</span> + (endTime - startTime) + <span class="string">'ms'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">run(<span class="number">19000</span>, <span class="number">9500</span>);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;春节前写了个&lt;a href=&quot;/2017/01/24/javascript-year-bonus-evade-tax/&quot;&gt;年终奖避税的程序&lt;/a&gt;。但是之前的实现上效率有点儿低，这次的博客就写一写如何优化这个程序好了（&lt;s&gt;其实是快到deadline才想起来要写博客临时抓的题目……&lt;/s&gt;）&lt;/p&gt;
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="年终奖" scheme="http://brooch.me/tags/%E5%B9%B4%E7%BB%88%E5%A5%96/"/>
    
      <category term="避税" scheme="http://brooch.me/tags/%E9%81%BF%E7%A8%8E/"/>
    
  </entry>
  
  <entry>
    <title>javascript实现年终奖避税程序</title>
    <link href="http://brooch.me/2017/01/24/javascript-year-bonus-evade-tax/"/>
    <id>http://brooch.me/2017/01/24/javascript-year-bonus-evade-tax/</id>
    <published>2017-01-24T07:50:40.000Z</published>
    <updated>2017-02-03T06:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天公司发了年终奖，扣了我20%的税…我就操了，肉疼啊…T^T…话说年终奖避税不是没有办法啊，为毛不给整整呢，总觉得肯定有什么不可告人的秘密…</p>
<p>于是我决定写个年终奖避税的程序去去火，不然这口气憋在心里非憋坏了不可…</p>
<a id="more"></a>
<h2 id="政策调查"><a href="#政策调查" class="headerlink" title="政策调查"></a>政策调查</h2><p>调查了下相关的政策，根据现有个人所得税计税办法，个人薪酬计税有两种方式，一种为月工资（含月奖金）计税，一种为年终奖综合计税。在年终奖综合计税发放过程中，在某些区间会出现税前奖金增加，税后实际收入反而减少的情况。</p>
<p>具体的税收办法是这样的，</p>
<p>月工资计税公式：</p>
<ul>
<li>应纳税额 = 月工资应纳税所得额 * 适用税率 - 速算扣除数</li>
<li>月工资应纳税所得额 = 计税月工资额 - 个人所得税起征点</li>
<li>个人所得税起征点 = 3500</li>
</ul>
<p>解释两个概念：</p>
<ul>
<li><strong>个人所得税起征点</strong><br>既税法规定的费用扣除额。</li>
<li><strong>速算扣除数</strong><br>速算扣除数并非税法规定，而是根据税法推算出来的一个方便计算的系数。<br>税法中关于个税的计算应该是分阶段的。不超过1500元的收3%，超过1500元至4500元的部分收10%，超过4500元至9000元的部分20%… 如果某人扣保险后工资10000，怎么计算呢？10000 = 3500 + 1500 + 3000 + 2000。 其中3500免征；1500按3%，征税45元；3000按10%，征300元；2000按20%，征400元。整个算下来征税745元。这么算很麻烦，所以会计们发明了速算扣除数。税率3%对应速算扣除数为0；税率10%对应速算扣除数为 1500 * (10% - 3%) + 0 = 105；税率20%对应速算扣除数为 4500 * (20% - 10%) + 105 = 555；以此类推，得到级别的速算扣除数。</li>
</ul>
<p>放上汇总之后的个人所得税税率表，之后会用到：</p>
<table>
<thead>
<tr>
<th style="text-align:center">级数</th>
<th style="text-align:center">全月应纳税所得额（元）</th>
<th style="text-align:center">税率（%）</th>
<th style="text-align:center">速算扣除数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0 ~ 1500</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1500.01 ~ 4500</td>
<td style="text-align:center">10</td>
<td style="text-align:center">105</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">4500.01 ~ 9000</td>
<td style="text-align:center">20</td>
<td style="text-align:center">555</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">9000.01 ~ 35000</td>
<td style="text-align:center">25</td>
<td style="text-align:center">1005</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">35000.01 ~ 55000</td>
<td style="text-align:center">30</td>
<td style="text-align:center">2755</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">55000.01 ~ 80000</td>
<td style="text-align:center">35</td>
<td style="text-align:center">5505</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">80000.01 ~ ∞</td>
<td style="text-align:center">45</td>
<td style="text-align:center">13505</td>
</tr>
</tbody>
</table>
<p>年终奖综合计税办法：</p>
<p>纳税人取得全年一次性奖金，单独作为一个月工资、薪金所得计算纳税，并按以下办法计税。</p>
<ul>
<li><p>(一) 先将雇员当月内取得的全年一次性奖金，除以12个月，按其商数确定适用税率和速算扣除数。 如果在发放年终一次性奖金的当月，雇员当月计税工资额低于税法规定的费用扣除额（个人所得税起征点3500元），应将全年一次性奖金减除”雇员当月计税工资额与费用扣除额的差额”后的余额，按上述办法确定全年一次性奖金的适用税率和速算扣除数。</p>
</li>
<li><p>(二) 将雇员个人当月内取得的全年一次性奖金，按第(一)项确定的适用税率和速算扣除数计算征税，计算公式如下：</p>
<ol>
<li>如果雇员当月工资薪金所得高于(或等于)税法规定的费用扣除额的，适用公式为： 应纳税额 ＝ 雇员当月取得全年一次性奖金 * 适用税率 - 速算扣除数</li>
<li>如果雇员当月计税工资额低于税法规定的费用扣除额的，适用公式为： 应纳税额 ＝ (雇员当月取得全年一次性奖金 - 雇员当月计税工资额与费用扣除额的差额) * 适用税率 - 速算扣除数</li>
</ol>
</li>
<li><p>(三) 在一个纳税年度内，对每一个纳税人，该计税办法只允许采用一次。</p>
</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>看过刚才的政策，咱们再来看三个例子：</p>
<ul>
<li><p>员工A，月薪2500，年终奖为5000，应缴个税为150，计算过程如下： 先算计税基础，(5000 - (3500 - 2500)) / 12 = 333.33，查税率表，适用3%的税率。 再算应纳所得税，5000 * 3% - 0 = 150，税后所得为 5000 - 150 = 4850。</p>
</li>
<li><p>员工B，月薪9000，年终奖18000，应缴个税为540，计算过程如下： 先算计税基础，18000 / 12 = 1500，查税率表，适用3%的税率。 再算应纳所得税，18000 * 3% - 0 = 540，税后所得为 18000 - 540 = 17460。</p>
</li>
<li><p>员工C，月薪9500，年终奖19000，应缴个税为1795，计算过程更上面一样，计算过程如下： 先算计税基础，19000 / 12 = 1583.3，查税率表，适用10%的税率。 再算应纳所得税，19000 * 10% - 105 = 1795，税后所得为 19000 - 1795 = 17205。</p>
</li>
</ul>
<p>看过之前三个例子你发现了吗？员工C虽然账面上比员工B多拿了1000的年终奖，但是实际所得却比员工B还少…这就是之前咱们说到的那个问题…也是年终奖需要避税的主要原因…</p>
<p>造成这个问题的主要原因，是由于税率虽然按照年终奖的12分之1计算了，但是速算扣除数却没有对应的扩大12倍。</p>
<p>假如速算扣除数也相应扩大12倍，那么年终奖19000的应缴个税为19000 * 10% - 105 * 12 = 640，这样和年终奖18000纳所得税540是不是差异就很小了？</p>
<p>据说之所以没有执行这样的政策，是因为年终奖一般都会超过一个月工资，直接按照个人所得税的税率纳税，肯定是要多缴税的。除以12个月作为计税基础，已经是税务局给予纳税人很大的优惠了，所以速算扣除数不能再给予优惠…</p>
<h2 id="避税"><a href="#避税" class="headerlink" title="避税"></a>避税</h2><p>常见的年终奖避税方式是将年终奖拆分，一部分按年终奖综合计税发放，一部分随月工资发放，一般1到2个月发完。</p>
<p>比如，月薪9500，年终奖19000，如果不做拆分直接纳税，应缴个税1795。如果拆分为年终发18000，之后月工资多发1000奖金，年终奖部分应缴个税应为18000 * 3% = 540，工资部分应缴个税(9500 + 1000 - 3500) * 20% - 555 = 845，比按月薪9500缴纳个税多缴了 200，所以总共少缴纳个税1795 - (540 + 200) = 1055</p>
<p>按照这个思路就来设计一个程序，来自动计算怎么拆分最好，能让收入最多。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>首先考虑下这个程序的输入输出，输入月工资和年终奖，然后打印出年终奖发多少，剩余的怎么拆分。</p>
<p>然后考虑具体的功能，缴税额计算都有现成的公式，封装成独立的函数就行了。年终奖的拆分应该会出现三种情况：不拆分最优，拆分入一个月最优，拆分入两个月最优。</p>
<p>因为暂时还没想到什么好算法，所以就不考虑性能，先实现了功能再说，用遍历把所有可能的拆分都试一遍，以后在考虑做剪枝。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> baseQuota = <span class="number">3500</span>;</div><div class="line"><span class="keyword">var</span> taxQuota = [<span class="number">1500</span>, <span class="number">4500</span>, <span class="number">9000</span>, <span class="number">35000</span>, <span class="number">55000</span>, <span class="number">80000</span>];</div><div class="line"><span class="keyword">var</span> taxRat = [<span class="number">0.03</span>, <span class="number">0.10</span>, <span class="number">0.20</span>, <span class="number">0.25</span>, <span class="number">0.30</span>, <span class="number">0.35</span>, <span class="number">0.45</span>];</div><div class="line"><span class="keyword">var</span> taxQuick = [<span class="number">0</span>, <span class="number">105</span>, <span class="number">555</span>, <span class="number">1005</span>, <span class="number">2755</span>, <span class="number">5505</span>, <span class="number">13505</span>];</div><div class="line"></div><div class="line"><span class="comment">// 获取不拆分年奖交税总额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOnlyBonusTax</span>(<span class="params">yearBonus, monthSalary</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> tax = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (monthSalary &gt; baseQuota) &#123;</div><div class="line">        perMonth = yearBonus / <span class="number">12</span>;</div><div class="line">        tax = round(yearBonus * getTaxRat(perMonth) - getTaxQuick(perMonth), <span class="number">2</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (yearBonus &lt; baseQuota - monthSalary) &#123;</div><div class="line">            tax = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            perMonth = (yearBonus - (baseQuota - monthSalary)) / <span class="number">10</span>;</div><div class="line">            tax = (yearBonus - (baseQuota - monthSalary)) * getTaxRat(perMonth) - getTaxQuick(perMonth);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tax;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取税率等级</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaxNum</span>(<span class="params">money</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = taxQuota.length; i &lt; l; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (money &lt;= taxQuota[i]) &#123;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取税率</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaxRat</span>(<span class="params">money</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> taxRat[getTaxNum(money)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取速算扣除数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaxQuick</span>(<span class="params">money</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> taxQuick[getTaxNum(money)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取平常月交税金额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMonthTax</span>(<span class="params">money</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (money &gt; baseQuota) &#123;</div><div class="line">        <span class="keyword">return</span> getTax(money - baseQuota);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取年奖平均月交税金额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPerMonthTax</span>(<span class="params">money</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getTax(money);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算个人所得税金额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTax</span>(<span class="params">money</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> round(money * getTaxRat(money) - getTaxQuick(money), <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算增加的交税金额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMonthTaxAdd</span>(<span class="params">monthSalary, addNum</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> monthAddSalary = monthSalary + addNum;</div><div class="line">    monthTaxAdd = round(getMonthTax(monthAddSalary) - getMonthTax(monthSalary), <span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> monthTaxAdd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算金额小数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">round</span>(<span class="params">num, toFix</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">parseFloat</span>(num.toFixed(toFix), <span class="number">10</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取拆分为一个月交税总额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOneMonthBonus</span>(<span class="params">yearBonus, monthSalary</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> nowBonusTax = getOnlyBonusTax(yearBonus, monthSalary);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; yearBonus; i++) &#123;</div><div class="line">        <span class="keyword">var</span> bonusRemain = yearBonus - i;</div><div class="line">        <span class="keyword">var</span> monthTaxAdd = getMonthTaxAdd(monthSalary, i);</div><div class="line">        <span class="keyword">var</span> bonusTax = round(getOnlyBonusTax(bonusRemain, monthSalary) + monthTaxAdd, <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (bonusTax &lt; nowBonusTax) &#123;</div><div class="line">            nowBonusTax = bonusTax;</div><div class="line">            oneMonth = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">tax</span>: nowBonusTax,</div><div class="line">		<span class="attr">bonus</span>: i</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取拆分为两个月交税总额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTwoMonthBonus</span>(<span class="params">yearBonus, monthSalary</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> nowBonusTax = getOnlyBonusTax(yearBonus, monthSalary);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; yearBonus; i++) &#123;</div><div class="line">        <span class="keyword">var</span> bonusRemain = yearBonus - i;</div><div class="line">        <span class="keyword">var</span> monthTaxAdd = getMonthTaxAdd(monthSalary, (i / <span class="number">2</span>)) * <span class="number">2</span>;</div><div class="line">        <span class="keyword">var</span> bonusTax = round(getOnlyBonusTax(bonusRemain, monthSalary) + monthTaxAdd, <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (bonusTax &lt; nowBonusTax) &#123;</div><div class="line">            nowBonusTax = bonusTax;</div><div class="line">            twoMonth = i / <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">tax</span>: nowBonusTax,</div><div class="line">		<span class="attr">bonus</span>: i</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">yearBonus, monthSalary</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> startTime = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</div><div class="line">    <span class="keyword">var</span> yearBonusTax = getOnlyBonusTax(yearBonus, monthSalary);</div><div class="line">    <span class="keyword">var</span> oneMonthTax = getOneMonthBonus(yearBonus, monthSalary);</div><div class="line">    <span class="keyword">var</span> twoMonthTax = getTwoMonthBonus(yearBonus, monthSalary);</div><div class="line">    <span class="keyword">var</span> minTax = <span class="built_in">Math</span>.min(yearBonusTax, oneMonthTax.tax, twoMonthTax.tax);</div><div class="line">    <span class="keyword">var</span> bonusRemain = yearBonus - minTax;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (minTax == yearBonusTax) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'年终奖发放：'</span> + yearBonus, <span class="string">'第一个月发放：'</span> + <span class="number">0</span>, <span class="string">'第二个月发放：'</span> + <span class="number">0</span>, <span class="string">'实际收入：'</span> + bonusRemain);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minTax == oneMonthTax.tax) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'年终奖发放：'</span> + (yearBonus - oneMonthTax.bonus), <span class="string">'第一个月发放：'</span> + oneMonthTax.bonus, <span class="string">'第二个月发放：'</span> + <span class="number">0</span>, <span class="string">'实际收入：'</span> + bonusRemain);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minTax == twoMonthTax.tax) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'年终奖发放：'</span> + (yearBonus - (twoMonthTax.bonus * <span class="number">2</span>)), <span class="string">'第一个月发放：'</span> + twoMonthTax.bonus, <span class="string">'第一个月发放：'</span> + twoMonthTax.bonus, <span class="string">'实际收入：'</span> + bonusRemain);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> endTime = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'耗时：'</span> + (endTime - startTime) + <span class="string">'ms'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">run(<span class="number">19000</span>, <span class="number">9500</span>);</div></pre></td></tr></table></figure>
<p>ok，这次就先到这里，下次再更新这个程序的优化方案吧。如果不出意外的话，maybe可能大概下周五会更新吧~马上要过年了，这里先祝米娜桑鸡年大吉咯~！\（￣︶￣）/</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天公司发了年终奖，扣了我20%的税…我就操了，肉疼啊…T^T…话说年终奖避税不是没有办法啊，为毛不给整整呢，总觉得肯定有什么不可告人的秘密…&lt;/p&gt;
&lt;p&gt;于是我决定写个年终奖避税的程序去去火，不然这口气憋在心里非憋坏了不可…&lt;/p&gt;
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="年终奖" scheme="http://brooch.me/tags/%E5%B9%B4%E7%BB%88%E5%A5%96/"/>
    
      <category term="避税" scheme="http://brooch.me/tags/%E9%81%BF%E7%A8%8E/"/>
    
  </entry>
  
  <entry>
    <title>一场抽奖引发的扯淡</title>
    <link href="http://brooch.me/2017/01/19/gab-draw/"/>
    <id>http://brooch.me/2017/01/19/gab-draw/</id>
    <published>2017-01-19T01:57:38.000Z</published>
    <updated>2017-01-20T10:26:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今年年会的抽奖算法写的实在是太烂。整个整个抽奖流程大概是这样的：每次抽奖是抽奖人先说开始，于是开始播放动画遍历队列，然后过一段时间，抽奖人说停，遍历结束，停在哪儿谁就中奖。可是不用看代码我都知道，每次抽奖时没有对队列进行随机排序。因为有动画效果，遍历的速度不可能很快，抽奖人又不会等很久才说停，所以排在后面的怎么可能中奖（我就是排在后面的）……于是我开始思考，如果是我，我会怎么写这个抽奖的程序呢。</p>
<a id="more"></a>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>抽奖可以概括的描述为：从一个指定的集合中，随机选出若干个元素。</p>
<p>ok，用编程语言翻译翻译：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">list = [], number = <span class="number">0</span></span>) </span>&#123;</div><div class="line">	list = list.concat()</div><div class="line">	<span class="keyword">let</span> result = []</div><div class="line">	<span class="keyword">while</span> (number--) &#123;</div><div class="line">		result.push(list.splice(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*list.length), <span class="number">1</span>)[<span class="number">0</span>])</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> drawResult = draw([<span class="string">'刘能'</span>, <span class="string">'谢大脚'</span>, <span class="string">'王长贵'</span>, <span class="string">'赵四'</span>, <span class="string">'刘英'</span>, <span class="string">'李大国'</span>, <span class="string">'赵玉田'</span>, <span class="string">'刘大脑袋'</span>, <span class="string">'王天来'</span>, <span class="string">'王大拿'</span>, <span class="string">'李秋歌'</span>], <span class="number">3</span>)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`中奖者为：<span class="subst">$&#123;drawResult.join(<span class="string">'，'</span>)&#125;</span>`</span>)</div></pre></td></tr></table></figure>
<h2 id="质疑"><a href="#质疑" class="headerlink" title="质疑"></a>质疑</h2><p>程序是写好了，但是这个程序真的能保证公平公正的抽奖吗？从上面的程序中一眼就能看出来，我们的抽奖程序是依赖于Math.random生成的随机数的。</p>
<p>但是，可能会有人质疑，Math.random生成的随机数真的是随机的，没有规律的吗？有没有可能通过预测出规律从而控制中奖结果？</p>
<h2 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random"></a>Math.random</h2><p>说到javascript的Math.random，ECMAScript是这么规定的：</p>
<blockquote>
<p>‘20.2.2.27Math.random ( )’</p>
<p>Returns a Number value with positive sign, greater than or equal to 0 but less than 1, chosen randomly or pseudo randomly with approximately uniform distribution over that range, using an implementation-dependent algorithm or strategy. This function takes no arguments.</p>
<p>Each ‘Math.random’ function created for distinct realms must produce a distinct sequence of values from successive calls.</p>
</blockquote>
<p>并没有提到是如何实现的。所以各家浏览器实现的方法也都不一样。</p>
<p>比如，V8是这样实现的<a href="https://github.com/v8/v8/blob/fab14341f508c2260d5640608d6d035e335e5ca4/src/builtins/builtins-math.cc#409" target="_blank" rel="external">MathRandom</a>，SpiderMonkey是这样实现的<a href="http://hg.mozilla.org/mozilla-central/file/tip/js/src/jsmath.cpp#713" target="_blank" rel="external">ensureRandomNumberGenerator</a>，webkit是这样实现的<a href="https://github.com/WebKit/webkit/blob/c595dc9b3993d095e25311b0ec1797bd665447e8/Source/WTF/wtf/WeakRandom.h" target="_blank" rel="external">WeakRandom</a>。</p>
<p>但是，不管是什么方法生成，基本规则都是基于一个种子（seed），经过一系列计算，最终生成一个值。也就是说，如果种子是确定的，那么最终生成的值也一定是确定的……</p>
<p>那么种子又是根据什么确定的呢？一般是使用函数调用时的当前时间作为种子的。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>既然上面说到了，所有的结果都是计算的结果，那么是不是说明抽奖结果并不是随机的是可预测的呢？其实也不是，因为在抽奖的过程中引入了随机的外部输入。没错，抽奖函数的执行时机是由人掌控的，而人的思想是不可掌控的，所以可以把抽奖的时机当做随机事件，这样抽奖的结果也肯定是随机的了……大概吧……</p>
<p>但是，如果提前确定下了抽奖的时间了，理论上，抽奖的结果就是可预测的了。</p>
<p>那么有没有办法不依赖用户输入来产生随机的结果呢？只要引入一些无法认为控制的元素就可以了，比如使用一些无法预测和控制的物理信息或者自然现象来生成随机数。</p>
<p>例如，Linux中的接口/dev/random就是引入了物理噪音作为输入来产生随机数的。</p>
<p>还有<a href="http://RANDOM.ORG" target="_blank" rel="external">RANDOM.ORG</a>，这个网站使用大气噪音来生成随机数。（他们提供的服务还是免费的，可以再<a href="https://www.random.org/clients/http/" target="_blank" rel="external">这里</a>查看他们提供的服务列表）</p>
<h2 id="P-S"><a href="#P-S" class="headerlink" title="P.S."></a>P.S.</h2><p>其实所有的伪随机数生成器都长周期相关现象，不过只要这个周期足够长，短时间内是不会出现问题的。之前V8就爆出过乱度不足的<a href="https://stackoverflow.com/questions/9550796/why-is-google-chromes-math-random-number-generator-not-that-random" target="_blank" rel="external">问题</a>，后来在49版本改用xorshift128+算法解决了这个问题。<br><img src="http://oin1wqn2f.bkt.clouddn.com/gab-draw-1.png" alt="gab-draw-1"><br><a href="http://vigna.di.unimi.it/ftp/papers/xorshiftplus.pdf" target="_blank" rel="external">xorshift128+</a>算法拥有极长的周期长度：</p>
<blockquote>
<p>This has been pointed out to us, and having understood the problem and after some research, we decided to reimplement Math.random based on an algorithm called xorshift128+. It uses 128 bits of internal state, has a period length of 2<sup>128</sup> - 1, and passes all tests from the TestU01 suite.</p>
</blockquote>
<p>应付年会抽奖这种小范围的活动肯定是绰绰有余的了。但是如果要在密码或者安全领域使用伪随机数，最好还是使用CSPRNG（密码学安全伪随机数生成器）来生成。浏览器环境可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues" target="_blank" rel="external">crypto.getRandomValues</a>，nodejs环境可以使用<a href="https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback" target="_blank" rel="external">crypto.randomBytes</a>。</p>
<p>需要注意的是crypto.getRandomValues函数接收的是一个TypedArray（Int8Array，Uint8Array……）而不是普通的数组，然后返回一个随机数队列。crypto.randomBytes函数接受一个字符指定返回值得长度，然后返回一个buffer而不是数字。要想转换为数字的话需要先用toString(‘hex’)转换为16进制字符串，再用parseInt将其转化为数字。</p>
<p>ok，那么这次的扯淡就到这里，感谢您的收看，咱们下次再扯，完结撒花~\（￣︶￣）/</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/19930815" target="_blank" rel="external">伪随机的上位和真随机的逆袭</a></li>
<li><a href="https://blog.gslin.org/archives/2015/11/25/6159/v8-%E7%9A%84-math-random-%E4%BA%82%E5%BA%A6%E4%B8%8D%E8%B6%B3%E7%9A%84%E5%95%8F%E9%A1%8C/" target="_blank" rel="external">V8 的 Math.random() 亂度不足的問題</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_15da22ed10102wpl6.html" target="_blank" rel="external">Math.random()</a></li>
<li><a href="http://cyukang.com/2014/03/06/random-number.html" target="_blank" rel="external">关于随机数</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;今年年会的抽奖算法写的实在是太烂。整个整个抽奖流程大概是这样的：每次抽奖是抽奖人先说开始，于是开始播放动画遍历队列，然后过一段时间，抽奖人说停，遍历结束，停在哪儿谁就中奖。可是不用看代码我都知道，每次抽奖时没有对队列进行随机排序。因为有动画效果，遍历的速度不可能很快，抽奖人又不会等很久才说停，所以排在后面的怎么可能中奖（我就是排在后面的）……于是我开始思考，如果是我，我会怎么写这个抽奖的程序呢。&lt;/p&gt;
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>深入mobx原理</title>
    <link href="http://brooch.me/2017/01/13/an-in-depthexplanation-of-mobx/"/>
    <id>http://brooch.me/2017/01/13/an-in-depthexplanation-of-mobx/</id>
    <published>2017-01-13T13:53:00.000Z</published>
    <updated>2017-01-13T14:26:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章翻译自mobx作者 Michel Weststrate 的一篇博客，虽然我也想做到信达雅，奈何英语水平有限……所以其中掺杂了很多我自己的理解。想了解细节的话可移步<a href="https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.2lcdbiz5f" target="_blank" rel="external">原文</a></p>
</blockquote>
<p>看过我之前的博客的看官都知道，mobx的除了能实现响应式的功能，它的运行速度还很快，那么，他是如何做到的呢？我们一起来看看mobx的内部运行机制。</p>
<a id="more"></a>
<p>首先，让我们来回顾一下mobx的核心概念：</p>
<ol>
<li><p><strong>可观测状态</strong></p>
<p>状态是指任何可以改变并且会引发计算属性变化的值。mobx可以把大多数类型的值(基础类型、数组、各种对象)，都转化成可观测的。而且针对，数组或对象等的结构化的数据类型，这种转化是递归的，数组或对象的所有子节点都会被转化。</p>
</li>
<li><p><strong>计算属性</strong></p>
<p>计算属性是一个函数。这个函数不接收参数，只单纯的依赖的其他可观测状态。依赖的可观测状态发生变化，它的运行结果才会发生变化。</p>
<p>虽然和定义有一定出入，但是从输入输出保持一致这点来看，计算属性应该算是一种纯函数。</p>
<p>很多场景都能用到计算属性，比如字符串的连接，或者生成复杂结构的对象。因为计算属性自身也是可观测的，所以甚至可以使用它从可观测状态导出完整的用户界面。计算属性还可以在惰性和活跃两种状态之间切换。</p>
</li>
<li><p><strong>反应</strong></p>
<p>反应和计算属性有点类似，不同点在于，计算属性的函数是产生一个新的值，而反应是产生一个副作用。所谓副作用，就是指一些跟计算无关的动作，比如打印日志，网络请求，更新界面之类的。总之使用反应可以把数据变化和其他流程关联起来。</p>
</li>
<li><p><strong>动作</strong></p>
<p>动作是修改状态的主要方法。动作本身并不对状态更改做响应，而是修改可观测状态。（如用户触发的事件、web-socket传入消息、或直接对可观测状态的修改）</p>
</li>
</ol>
<p>这四个核心概念对应mobx中最常用的4个api，observable、computed、reaction（autorun）、action。</p>
<p>之后，我们把计算属性和反应都称为<strong>派生</strong>。</p>
<p>上面的解释可能有点儿不好理解，那我把它说的更形象一些：</p>
<p>execl都用过吧？<strong>可观测状态</strong> 就是里面的单元格。<strong>计算属性</strong> 就是里面的公式。<strong>动作</strong> 好比你双击了一个单元格改变了单元格的数据。把修改过后的数据反馈到屏幕上就是 <strong>反应</strong> 做的事。</p>
<p>这有个使用mobx和react的例子，例子中使用到了这四个概念：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  @observable firstName = <span class="string">"Michel"</span>;</div><div class="line">  @observable lastName = <span class="string">"Weststrate"</span>;</div><div class="line">  @observable nickName;</div><div class="line"></div><div class="line">  @computed get fullName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> michel = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="comment">// 这里就算是一个反应，用来打印可观测状态变化的日志</span></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(person.nickName ? person.nickName : person.fullName));</div><div class="line"></div><div class="line"><span class="comment">// 示例的react组件，根据状态变化发生改变，其中observer是来自react-mobx的api</span></div><div class="line"><span class="keyword">const</span> profileView = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">if</span> (props.person.nickName)</div><div class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;props.person.nickName&#125;&lt;/div&gt;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;props.person.fullName&#125;&lt;/div&gt;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 动作</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> michel.nickName = <span class="string">"mweststrate"</span>, <span class="number">5000</span>)</div><div class="line"></div><div class="line">React.render(React.createElement(profileView, &#123; <span class="attr">person</span>: michel &#125;), <span class="built_in">document</span>.body);</div></pre></td></tr></table></figure>
<p>例1:可观测状态、计算属性、反应渲染Reactjs组件和动作</p>
<p>基于上面的例子，我们可以整理出下图的依赖关系树:</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/an-in-depthexplanation-of-mobx-01.png" alt="Figure 1"></p>
<p>图1:profileView组件的依赖关系树。此时fullName处于活跃状态，它同时观察firstName和lastName</p>
<p>蓝色的是可观测状态。绿色的fullName是计算属性，可以通过观测firstName和lastName的状态自动计算。同理，nickName和fullName的变化都会传导到profileView。profileView 的状态变化会产生一个副作用，让react组件树更新。</p>
<p>在mobx中，依赖关系树会被限制在最小限度。例如,一旦person对象有nickName属性，则视图不再受fullName的影响，也不会受firstName和lastName的影响。这些值之间的所有观察者都会被清理，MobX会自动简化依赖关系树：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/an-in-depthexplanation-of-mobx-02.png" alt="Figure 2"></p>
<p>图 2: 当person对象有nickname属性时的profileView组件的依赖性树，与图1相反，fullName现在处于惰性状态，同事他也不会观测firstName和lastName</p>
<p>mobx将总是试图最小化产生一致状态所需的计算的数量。在这篇文章的其余部分,我将描述用来实现这一目标的一些策略。但在探索计算属性和反应保持同步的原理前，我们首先看下MobX背后的原则:</p>
<blockquote class="blockquote-center"> 响应状态变化永远比处理状态变化好。 </blockquote><br>在我们平时的工作中，应用程序在响应状态更改时所触发的操作，通常会创建或更新某些值。我们可以尝试从另一个角度理解，既可以把大多数的动作都理解为对本地缓存的操作。<br><br>触发用户界面更新?更新某些值?与后端通信?这些都可以认为是缓存失效，我们为了更新缓存所执行的动作。<br><br>为了让这些缓存保持同步，我们一般会使用观察者模式，订阅缓存的状态变化，缓存失效了，好通知你的动作再次被触发。<br><br>但是使用这种模式却有个根本的问题：随着你的应用的不断扩大，你要管理的订阅也越来越多，在这个管理过程中，或多或少都会犯一些错误。比如超额订阅(继续订阅一个值不再使用的值)或遗漏订阅(忘记监听数据更新而导致的数据过时的bug)。<br><br><blockquote class="blockquote-center"> 也就是说，手动维护订阅关系，应用程序早晚会出现数据和展示不一致的情况。</blockquote>

<p><img src="http://oin1wqn2f.bkt.clouddn.com/an-in-depthexplanation-of-mobx-03.png" alt="Figure 3"></p>
<p>图3:更新了个人信息之后，Twitter页面上的不一致现象，推文列表中作者的用户名和头像还是旧的值</p>
<p>Twitter用户界面不一致是一个很好的例子的。我在Reactive2015论坛上解释过造成这种情况的两种原因：要么是没有订阅通知推文列表用户信息已经改变，需要重新渲染。要么就是推文作者的数据和当前登陆用户之前没有关联，尽管这两部分的数据描述的是相同的属性相同的对象。</p>
<p>而像Flux那样的粗粒度的订阅很容易造成超额订阅。使用react时，可以使用react提供的开发工具打印调试信息查看是否有浪费的渲染，来简单的判断是否有超额订阅的情况。而MobX可以将这种情况降至零。mobx会自动帮你管理成千上万的订阅。</p>
<p>值得一提的是，超额订阅可能会很隐秘。如果你订阅的数据但并不是在所有情况下都会被使用，那它仍然是超额订阅的。例如例1中，profileView组件订阅了的fullName，但是person对象有nickName属性时，它还是超额订阅的。</p>
<p>所以设计mobx背后的一个重要的原则是:</p>
<blockquote class="blockquote-center">只有运行时确定下来的订阅，才是最小的订阅集合</blockquote>

<p>mbox背后的第二个重要思想是：尽量使用mobx去创建一个图结构的数据模型去管理你的应用，而不是平时常用的树状结构。</p>
<p>我们真正要开发的应用通常会比TodoList复杂很多。图结构可以有效的保证数据的一致性，并避免数据重复。</p>
<h2 id="mobx如何保持所有派生一致"><a href="#mobx如何保持所有派生一致" class="headerlink" title="mobx如何保持所有派生一致"></a>mobx如何保持所有派生一致</h2><p>解决方案：用计算代替缓存。有人会问：“那不是非常消耗资源的吗?”其实并没有，而且他效率还挺高的。</p>
<p>原因正如上面所解释的：mobx并不运行所有派生，只同步那些参与到反应中的计算属性和可观测状态。这些派生被称为活跃的。</p>
<h2 id="惰性和活跃"><a href="#惰性和活跃" class="headerlink" title="惰性和活跃"></a>惰性和活跃</h2><p>那么没有直接或间接被反应调用的派生咋办呢？当然，你仍然可以随时检查计算属性（如fullName）的值。</p>
<p>解决方法也很简单：如果一个计算值不是活跃的，那么它将在需要他的时候重新计算（就是惰性的），就跟一个正常的getter函数一样。如果惰性的派生(从来没有观察到任何东西)从作用域中移除，就会被垃圾收集。还记得计算属性是可观察状态的纯函数吧？这就是为啥他是纯函数的原因:不管什么状态下，相同的可观测状态，计算属性函数计算的结果也一定是相同的。</p>
<h2 id="运行计算"><a href="#运行计算" class="headerlink" title="运行计算"></a>运行计算</h2><p>mobx中反应和计算属性都是由以同样的方式运行的。当前运行的派生有个函数栈，当有计算触发了派生的函数，这个函数就会被推入栈中。只要计算正在运行，被访问的每个被观测状态都会将其自身注册为派生栈的最顶层函数的依赖。如果需要计算属性的值，并且计算属性已经处于活跃状态，则直接使用最后一次计算出的值。否则就将他推入派生函数栈，切换到活跃状态，并开始计算。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/an-in-depthexplanation-of-mobx-04.png" alt="Figure 4"></p>
<p>图4:在执行profileView响应函数期间的计算过程。</p>
<p>当计算完成时，派生将获得在执行期间访问的可观测列表。 例如，在profileView中，此列表将只包含nickName属性，或nickName和fullName属性。 每次获得的列表与之前的都可能不同。 任何被废弃的属性都将被忽略（计算属性可能从活跃模式转换到惰性模式），并且任何新添加的可观测状态都将被观测，直到下一次计算。 如果firstname的值以后更改了，观测它的派生就知道fullName需要重新计算。这反过来将导致界面重新渲染。 下一段更详细地解释这个过程。</p>
<h2 id="状态变化的传播"><a href="#状态变化的传播" class="headerlink" title="状态变化的传播"></a>状态变化的传播</h2><p><img src="http://oin1wqn2f.bkt.clouddn.com/an-in-depthexplanation-of-mobx-05.png" alt="Figure 5"></p>
<p>图5：在依赖关系树上更改’1’的值的效果。 虚线边框表示需要被更新的派生。 数字表示计算的顺序。</p>
<p>派生会自动响应状态的变化。所有反应函数都是同步执行的，而且是无干扰的。当一个可观测的值被修改，整个修改算法如下：</p>
<ol>
<li>被观测对象给所有观察它的派生发送一个过期通知，告诉它们自己需要更新了。任何受到影响的计算属性将递归的把消息传递给其他的观察者。结果，依赖树中的一部分被标记为过期。在图5的示例依赖关系树中，当值’1’改变时变为陈旧的观察者用橙色的虚线标记。这些都是受影响的派生。</li>
<li>发送失效通知并存储新值后，将发送就绪通知。 此消息还将标记值是否真的发生了改变。</li>
<li>一旦派生接收到针对步骤1的就绪通知，它就知道所有的观测值都已经稳定了，然后它会开始重新计算。就绪/失效消息的计数器会保证计算属性’4’将会在计算属性’3’变得稳定之后才重新计算。</li>
<li>如果没有接到就绪通知值，则派生将简单的告诉自己的观察者自己已经准备好了，但是值没变。否则，计算属性将重新计算并给自己的观察者发送就绪通知。在图5中我们可以看到，比如计算属性‘4’重新计算后没有产生新值，那么最后的响应（‘-’表示的那个）永远都不会被执行。</li>
</ol>
<p>前两段总结了如何在运行时跟踪可观测状态和派生之间的依赖关系，以及如何通过派生来传播变化。 现在，你可能还会意识到，反应其实就是一个总是处于活跃状态的计算属性。 此外，mobx还应用了许多其他优化，不过这超出了本文的范围，暂不讨论。</p>
<h2 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h2><p>人们经常惊讶与mobx所有的动作都是同步运行的（像RxJs和不像knockout）。 这有两大优点：首先，它变得根本不可能观察到过期的派生。 因此，在影响它的值修改之后，可以立即使用派生的值。 其次，它使栈跟踪和调试更容易，因为它避免了无用的栈跟踪。</p>
<p>但是，有些时候我们不得不引入批量操作。比如autocomplate之类的常见功能，会在短时间内连续多次改变值，我们需要在一系列改变之后再发送就绪通知。这就要用mobx中的另一个概念，事务（transaction）。</p>
<p>事务可以推迟就绪通知，整个事务完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">transaction(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  michel.firstName = <span class="string">"Mich"</span>;</div><div class="line">  michel.lastName = <span class="string">"W."</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>例 2: 事务示例。</p>
<p>至此，我们总结了mobx最基本的实现细节。我们还没有覆盖一切，但是剩下的也都很好理解，例如，你可以组合计算属性。 通过组合反应和计算属性，甚至可以自动将一个数据图转换为另一个数据图。通过这些特性，我们还能很容易的实现一些复杂的模式，如map-reduce，时间回溯，或者横向数据加载。</p>
<h2 id="重点概要："><a href="#重点概要：" class="headerlink" title="重点概要："></a>重点概要：</h2><ol>
<li>复杂应用程序的应用程序状态最好使用图表来表示，既能保证数据和视图的一致性，又直观好理解</li>
<li>不应该通过手动订阅来同步状态。这将不可避免地导致超额订阅和遗漏订阅</li>
<li>使用运行时分析来确定观察者→可观测状态关系的最小集合。 这样就能达到既保证基本功能，又保持最小计算量的效果。</li>
<li>没有被主动调用的派生都会被优化掉</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章翻译自mobx作者 Michel Weststrate 的一篇博客，虽然我也想做到信达雅，奈何英语水平有限……所以其中掺杂了很多我自己的理解。想了解细节的话可移步&lt;a href=&quot;https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.2lcdbiz5f&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看过我之前的博客的看官都知道，mobx的除了能实现响应式的功能，它的运行速度还很快，那么，他是如何做到的呢？我们一起来看看mobx的内部运行机制。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="中文渣翻" scheme="http://brooch.me/tags/%E4%B8%AD%E6%96%87%E6%B8%A3%E7%BF%BB/"/>
    
  </entry>
  
  <entry>
    <title>javascript中的进程、线程和协程</title>
    <link href="http://brooch.me/2016/12/30/process-thread-and-coroutine-in-javascript/"/>
    <id>http://brooch.me/2016/12/30/process-thread-and-coroutine-in-javascript/</id>
    <published>2016-12-30T15:26:28.000Z</published>
    <updated>2017-01-01T16:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周一直在编前端构建的脚本，用到了多进程去解决一个效率问题。期间差了很多进程、线程、协程的资料，在这里记录回顾一下。</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>关于进程、线程、协程的概念这里就不再赘述了，具体的可以参考wiki百科：</p>
<ul>
<li><p><a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B" target="_blank" rel="external">进程</a></p>
</li>
<li><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" target="_blank" rel="external">线程</a></p>
</li>
<li><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B" target="_blank" rel="external">协程</a></p>
</li>
</ul>
<h2 id="简单概括一下它们间的区别"><a href="#简单概括一下它们间的区别" class="headerlink" title="简单概括一下它们间的区别"></a>简单概括一下它们间的区别</h2><p>就是相对线程和协程，进程更独立，有自己的内存空间，所以进程间通信比较困难。线程比进程轻量级，属于同一进程的多个线程间可以共享全部资源。协程与线程类似，不同点在于，线程由系统控制切换，协程是由用户控制切换。</p>
<p>那么，控制切换，指的是控制什么的切换呢？</p>
<p>在一个进程中执行的程序，有时需要同时处理多个工作，这时我们可以创建多个线程，让每个线程处理一个工作。但是，进程只有一个。就好比一个人，你给他分配了多个工作，帮他把每个工作单独拉了一个列表，可还是他一个人干，他只能一会儿干干这一会儿干干那，来模拟多个工作同时进行的状态，这就是所谓的系统控制切换，系统不停的在多个线程间切换来达到并行的效果。你可能会说，那根一件一件干不是一样吗？没错，是一样的，在只有一个cpu的电脑上，用不用多线程程序执行的时间是一样的。但是，如果这个人长了两个脑袋呢？那么他就能同时处理两件工作了。多核cpu就是那个长了好多个脑地的人……而协程的切换是要由用户手动来控制的，所以协程并适合并行计算，而更多的用来优化程序结构。</p>
<h2 id="js都支持吗？"><a href="#js都支持吗？" class="headerlink" title="js都支持吗？"></a>js都支持吗？</h2><p>这要看js在什么环境运行。</p>
<p>在浏览器中，可以通过webworkers创建进程，可以通过async/await，yield/Generator/GeneratorFunction实现协程，控制程序切换。</p>
<p>在node中，除了可以使用上面浏览器中可以使用的方法，还可以通过cluster，child_process创建进程，通过libuv，tagg创建线程</p>
<h2 id="刚才提到的那些都是啥？怎么用？"><a href="#刚才提到的那些都是啥？怎么用？" class="headerlink" title="刚才提到的那些都是啥？怎么用？"></a>刚才提到的那些都是啥？怎么用？</h2><h3 id="webworkers"><a href="#webworkers" class="headerlink" title="webworkers"></a>webworkers</h3><p>简单点儿说就是使用webworkers你可以在全新的环境中运行一个你指定的js文件。这个全新的环境是独立的，既一个全新的进程，有点儿像一个新iframe还没有window.top，window.parent属性，哈哈……</p>
<p>webworkers创建的进程和主进程之间可以通过message事件传递消息，但是消息只能是字符串，所以想要传对象和数组就只能传json了……这也是他不方便的地方。</p>
<p>具体使用方法可以看MDN上的文章：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">使用 Web Workers</a></p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>async/await是es7中新加的两个关键字，async 可以声明一个异步函数，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果。</p>
<p>其实就是类似汇编的寄存器和跳转指令……呃，通俗的说就是可以根据状态跳转态另一个函数半中间。</p>
<p>由于es7还未在各个环境实现，想要使用的话还的用一些babel-polyfill之类的库做兼容……</p>
<p>更详细介绍请看阿阮的文章：<a href="http://es6.ruanyifeng.com/?search=async&amp;x=0&amp;y=0#docs/async" target="_blank" rel="external">异步操作和Async函数</a></p>
<h2 id="yield-Generator-GeneratorFunction"><a href="#yield-Generator-GeneratorFunction" class="headerlink" title="yield/Generator/GeneratorFunction"></a>yield/Generator/GeneratorFunction</h2><p>generator是es6中新增的函数，本质是可以将一个函数执行暂停，并保存上下文，再次调用时恢复当时的状态。但是用来解决协程切换的问题貌似有点儿滥用特性的感觉呢……</p>
<p>更详细介绍请看阿阮的文章：<a href="http://es6.ruanyifeng.com/?search=async&amp;x=0&amp;y=0#docs/generator" target="_blank" rel="external">Generator 函数</a></p>
<h3 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h3><p>cluster是node官方提供的一个多进程模块，效果和C语言的fork函数类似，当前文件完全重新执行一遍，通过cluster.isMaster判断是不是主进程，在区分不同的操作。进程间通过事件回调来通信，NodeJS 0.6.x 以上的版本开始支持。</p>
<p>示例代码就不放了，node官方文档上写的很详细：<a href="https://nodejs.org/api/cluster.html" target="_blank" rel="external">cluster</a></p>
<h3 id="child-process"><a href="#child-process" class="headerlink" title="child_process"></a>child_process</h3><p>node自带的child_process模块里的fork函数可以实现类似浏览器里webworkers的效果，使用方法和webworker一毛一样，都是通过读取新文件开启新进程，通过message通信。</p>
<p>具体介绍请看文档：<a href="https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options" target="_blank" rel="external">child_process.fork(modulePath[, args][, options])</a></p>
<p>官方文档没有示例，下面给出一个web服务接收参数计算斐波那契数组的例子：</p>
<h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</div><div class="line"><span class="keyword">var</span> app = express();</div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> worker = fork(<span class="string">'./work_fibo.js'</span>) <span class="comment">//创建一个工作进程</span></div><div class="line">	worker.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;<span class="comment">//接收工作进程计算结果</span></div><div class="line">		<span class="keyword">if</span>(<span class="string">'object'</span> === <span class="keyword">typeof</span> m &amp;&amp; m.type === <span class="string">'fibo'</span>)&#123;</div><div class="line">			worker.kill();<span class="comment">//发送杀死进程的信号</span></div><div class="line">			res.send(m.result.toString());<span class="comment">//将结果返回客户端</span></div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	worker.send(&#123;<span class="attr">type</span>:<span class="string">'fibo'</span>,<span class="attr">num</span>:~~req.query.n || <span class="number">1</span>&#125;);<span class="comment">//发送给工作进程计算fibo的数量</span></div><div class="line">&#125;);</div><div class="line">app.listen(<span class="number">8124</span>);</div></pre></td></tr></table></figure>
<h4 id="work-fibo-js"><a href="#work-fibo-js" class="headerlink" title="work_fibo.js"></a>work_fibo.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fibo = <span class="function"><span class="keyword">function</span> <span class="title">fibo</span> (<span class="params">n</span>) </span>&#123;<span class="comment">//定义算法</span></div><div class="line">	<span class="keyword">return</span> n &gt; <span class="number">1</span> ? fibo(n - <span class="number">1</span>) + fibo(n - <span class="number">2</span>) : <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</div><div class="line"><span class="comment">//接收主进程发送过来的消息</span></div><div class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> m === <span class="string">'object'</span> &amp;&amp; m.type === <span class="string">'fibo'</span>)&#123;</div><div class="line">		<span class="keyword">var</span> num = fibo(~~m.num);</div><div class="line">		<span class="comment">//计算jibo</span></div><div class="line">		process.send(&#123;<span class="attr">type</span>: <span class="string">'fibo'</span>,<span class="attr">result</span>:num&#125;)</div><div class="line">		<span class="comment">//计算完毕返回结果        </span></div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line">process.on(<span class="string">'SIGHUP'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	process.exit();<span class="comment">//收到kill信息，进程退出</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="libuv"><a href="#libuv" class="headerlink" title="libuv"></a>libuv</h3><p>libuv是node底层实现使用的c++库……呃，所以如果你想使用这个库来实现多线程，那么你就得编写c++的代码了，不得不说，要想真正理解程序的本质，不多掌握几门语言真是不行啊……</p>
<p>对c++不了解我就不瞎BB了，推荐两篇文章延伸阅读：</p>
<ul>
<li><a href="http://blog.csdn.net/limite_god/article/details/43668235" target="_blank" rel="external">libuv多线程处理的简单示例</a></li>
<li><a href="http://snoopyxdy.blog.163.com/blog/static/601174402013422103614385/" target="_blank" rel="external">利用libuv编写异步多线程的addon实例</a></li>
</ul>
<h3 id="tagg"><a href="#tagg" class="headerlink" title="tagg"></a>tagg</h3><p>tagg(Threads a gogo for Node.js)是Jorge Chamorro Bieling开发的一个node包。使用c语言phread库实现的多线程。</p>
<p>还是那刚才的斐波那契数组计算为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Threads = <span class="built_in">require</span>(<span class="string">'threads_a_gogo'</span>);<span class="comment">//加载tagg包</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibo</span>(<span class="params">n</span>) </span>&#123;<span class="comment">//定义斐波那契数组计算函数</span></div><div class="line">	<span class="keyword">return</span> n &gt; <span class="number">1</span> ? fibo(n - <span class="number">1</span>) + fibo(n - <span class="number">2</span>) : <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> t = Threads.create().eval(fibo);</div><div class="line">t.eval(<span class="string">'fibo(35)'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;<span class="comment">//将fibo(35)丢入子线程运行</span></div><div class="line">	<span class="keyword">if</span> (err) <span class="keyword">throw</span> err; <span class="comment">//线程创建失败</span></div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'fibo(35)='</span> + result);<span class="comment">//打印fibo执行35次的结果</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'not block'</span>);<span class="comment">//打印信息了，表示没有阻塞</span></div></pre></td></tr></table></figure>
<p>最后结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">not block</div><div class="line">fibo(<span class="number">35</span>)=<span class="number">14930352</span></div></pre></td></tr></table></figure></p>
<p>我们可以看到执行效果与webworker类似，不同的是通信使用了异步回调的方式。</p>
<p>值得一提的是tagg包目前只能在linux下安装运行，这里再推荐一个tagg2包，是跨平台的。</p>
<p>这里需要重点提一下的是，不论tagg还是tagg2包都是利用phtread库和v8的v8::Isolate Class类来实现js多线程功能的。</p>
<blockquote>
<p>Isolate代表着一个独立的v8引擎实例，v8的Isolate拥有完全分开的状态，在一个Isolate实例中的对象不能够在另外一个Isolate实例中使用。嵌入式开发者可以在其他线程创建一些额外的Isolate实例并行运行。在任何时刻，一个Isolate实例只能够被一个线程进行访问，可以利用加锁/解锁进行同步操作。</p>
</blockquote>
<p>换而言之，我们在进行v8的嵌入式开发时，无法在多线程中访问js变量，这条规则将直接导致我们之前的tagg2里面线程执行的函数无法使用Node.js的核心api，比如fs，crypto等模块。</p>
<p>延伸阅读：</p>
<ul>
<li><a href="https://github.com/xk/node-threads-a-gogo" target="_blank" rel="external">tagg</a></li>
<li><a href="https://github.com/DoubleSpout/node-threads-a-gogo2" target="_blank" rel="external">tagg2</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过以上的学习，我们大概应该了解到进程、线程、协程的使用场景了，进程、线程适合用来处理计算密集型操作，协程适合用来优化代码结构，解决回调函数嵌套问题。线程比进程更轻，更节省资源，但是由于上面提到的线程问题，针对一些可以使用js原生的大量计算或循环还可以用用，涉及到使用nodejs核心api的操作，比如文件处理之类的操作，就要用进程使用解决了。当然，也可以用libuv库写c++模块处理多线程的操作，但是还要学c++啊望天儿……</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="http://www.admin10000.com/document/4196.html" target="_blank" rel="external">Node.js的线程和进程</a></li>
<li><a href="https://cnodejs.org/topic/518b679763e9f8a5424406e9" target="_blank" rel="external">nodejs多线程，真正的非阻塞</a></li>
<li><a href="https://www.zhihu.com/question/20511233" target="_blank" rel="external">协程的好处是什么?</a></li>
<li><a href="https://www.zhihu.com/question/32218874" target="_blank" rel="external">为什么觉得协程是趋势？</a></li>
</ul>
<h2 id="p-s-我的问题"><a href="#p-s-我的问题" class="headerlink" title="p.s. 我的问题"></a>p.s. 我的问题</h2><p>我在工作中使用的是fis配合grunt调用打包。由于要同时打包多个项目，grunt和fis都会定义全局变量，各个模块之间的配置可能会相互影响，各个模块在打包过程中又没有相互的通信，同时为了提高效率，非常时候适合使用多进程的方式来运行脚本。所以用cluster实现了多进程打包的。</p>
<p>最后，新年快乐，祝大家在2017年里，都能喝最烈的酒，日最野的狗~ ┑(￣Д ￣)┍</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周一直在编前端构建的脚本，用到了多进程去解决一个效率问题。期间差了很多进程、线程、协程的资料，在这里记录回顾一下。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://brooch.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="nodejs" scheme="http://brooch.me/tags/nodejs/"/>
    
      <category term="webworkers" scheme="http://brooch.me/tags/webworkers/"/>
    
      <category term="cluster" scheme="http://brooch.me/tags/cluster/"/>
    
      <category term="child_process" scheme="http://brooch.me/tags/child-process/"/>
    
      <category term="tagg2" scheme="http://brooch.me/tags/tagg2/"/>
    
      <category term="yield" scheme="http://brooch.me/tags/yield/"/>
    
      <category term="generator" scheme="http://brooch.me/tags/generator/"/>
    
      <category term="async" scheme="http://brooch.me/tags/async/"/>
    
      <category term="await" scheme="http://brooch.me/tags/await/"/>
    
  </entry>
  
  <entry>
    <title>响应式react：构建高效易用的react应用</title>
    <link href="http://brooch.me/2016/12/23/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/"/>
    <id>http://brooch.me/2016/12/23/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/</id>
    <published>2016-12-23T07:53:53.000Z</published>
    <updated>2016-12-23T13:59:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章翻译自mobx作者 Michel Weststrate 的一篇博客，虽然我也想做到信达雅，奈何英语水平有限……所以我写的内容自动屏蔽了一些前因后果没营养的话，只翻译我觉得重点的内容。我的原则是，捞干的说，不BB~<br>想了解细节的话可移步<a href="https://www.mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/" target="_blank" rel="external">原文</a></p>
</blockquote>
<p>使用react开发应用有啥好处，我想是个前端都能数出个十条八条来。但是如果你的项目需要在浏览器中绘制成千上万的对象，而且这些对象之前还有大量的耦合关系，那维护这些对象也够喝一壶的……mobx作者在发明mobx的时候就面临了这样一个项目，一个对象的值可能被其他对象引用，任何变化都可能引起大量的ui更新和重绘。在一些特殊场景，比如拖拽操作，这些动作还必须在40毫秒响应……</p>
<p>于是，mobx被开发出来了。简单来说，他使用了函数响应式编程的概念 Observables 来解决上述的问题，其实 mobx 并不是第一个使用这一概念的前端库，ember、knockout还有vue其实都使用了这一概念，我个人感觉，mobx就好像把vue和knockout的数据绑定那部分抽出来然后揉到一起一样……真的能发现很多有相似的地方……使用 Observables 的好处就在于，你可以很容易实现自动更新关联数据和sideways data loading，从而解放生产力，提升应用的性能。后面测试数据一章可以看到具体的对比结果。</p>
<a id="more"></a>
<p>下面我们以一个简单的购物应用为例：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-1.png?1" alt="shoping"></p>
<p>里面包含商品列表，购物车，结算等部分。完整的例子可以再<a href="https://jsfiddle.net/mweststrate/46vL0phw/embedded/result/" target="_blank" rel="external">jsfiddle</a>上看到（需要翻墙）。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>首先，我们先看下数据模型。商品列表（Articles）里的每个商品，有名称（name）和价格（price）属性，购物车（Cart）有已加入购物车列表（Entries）和总价（Total）属性。已加入购物车列表中的每个商品除了名字和价格属性以外，还有数量属性（amount）、根据数量和单价计算出的总价。数据之间的关系如下图所示。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-2.png?1" alt="data model"></p>
<p>从上图中我们可以看出，如果对一个数据进行修改，那么就会带动其他的数据修改，同时还得修改ui。<br>大概列一下数据联动的逻辑：</p>
<ul>
<li>如果商品列表里的商品价格发生改变，购物车里的商品价格也需要更新。</li>
<li>……购物车的总价也得更新。</li>
<li>如果购物车中商品数量变化，总价也得跟着更新。</li>
<li>如果商品列表里的商品被重命名了，商品列表的界面得更新。</li>
<li>……购物车里对应的商品也得更新。</li>
<li>如果添加新文章合计购物车……</li>
</ul>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-3.jpg?1" alt="(╯‵□′)╯︵┻━┻"></p>
<p>作为一个程序员，就是这么闹心……你不得不写大量的代码来处理各种可能的状态，处理速度还得快，让用户老爷等着急了你担待得起吗……</p>
<p>那么，让我们来看看怎么用mobx来日翻这些问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params">name, price</span>) </span>&#123;</div><div class="line">    mobx.extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">name</span>: name,</div><div class="line">        <span class="attr">price</span>: price</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ShoppingCartEntry</span>(<span class="params">article</span>) </span>&#123;</div><div class="line">    mobx.extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">article</span>: article,</div><div class="line">        <span class="attr">amount</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">price</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.article ? <span class="keyword">this</span>.article.price * <span class="keyword">this</span>.amount : <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ShoppingCart</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    mobx.extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">entries</span>: [],</div><div class="line">        <span class="attr">total</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.entries.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sum, entry</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> sum + entry.price;</div><div class="line">            &#125;, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用工具函数包装之后，通过构造函数创建的对象都是可观测的，就是说当对象的某一个属性改变，跟他跟他相关联的属性都会自动更新。这样状态变化就不用我们手动维护了，比如添加商品到购物车时总价的变化、物品的价格发生变化时其他关联项的变化等等。</p>
<h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>模型建好了，该搭界面了。下面的列了一段购物车组件的代码，包含了显示购物车里的商品列表和总价。其他组件请自行脑补，都差不离的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CartView = React.createClass(&#123;</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">renderEntry</span>(<span class="params">entry</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> (&lt;CartEntryView entry=&#123;entry&#125; cart=&#123;this.props.cart&#125; key=&#123;entry.id&#125; /&gt;);</div><div class="line">        &#125;</div><div class="line">        return (&lt;div&gt;</div><div class="line">            &lt;ul id="cart"&gt;&#123;this.props.cart.entries.map(renderEntry)&#125;&lt;/ul&gt;</div><div class="line">            &lt;div&gt;&lt;b&gt;Total: &lt;span id="total"&gt;&#123;this.props.cart.total&#125;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;</div><div class="line">        &lt;/div&gt;)</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var CartEntryView = React.createClass(&#123;</div><div class="line">    render: function() &#123;</div><div class="line">        return (&lt;li&gt;</div><div class="line">            &lt;button onClick=&#123;this.removeArticle&#125;&gt;&amp;laquo;&lt;/button&gt;</div><div class="line">            &lt;span&gt;&#123;this.props.entry.article.name&#125;&lt;/span&gt;</div><div class="line">            &lt;span&gt;&#123;this.props.entry.amount&#125;&lt;/span&gt;</div><div class="line">        &lt;/li&gt;);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    removeArticle: function() &#123;</div><div class="line">        if (--this.props.entry.amount &lt; 1)</div><div class="line">            this.props.cart.entries.splice(this.props.cart.entries.indexOf(this.props.entry), 1);      </div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>组件写完了，但是没跟模型关联还跑不起来，需要用mobx-react库里的 <code>mobxReact.observer</code> 方法把组件都包装装一下，这就算关联上了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CartEntryView = mobxReact.observer(React.createClass(&#123;</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> (&lt;li&gt;</div><div class="line">            // etc...</div></pre></td></tr></table></figure>
<p>然后，就没有然后……是的，这就算齐活了。让我们看下<a href="https://jsfiddle.net/mweststrate/46vL0phw/" target="_blank" rel="external">jsfiddle</a>上的演示。</p>
<p>这里 <code>observer</code> 函数为我们做了两件事。首先，它将组件的 <code>render</code> 函数变成一个可观察到的函数。然后，把组件注册到观察者函数，所以每次 <code>render</code> 需要更新了他都会自动更新。<code>mobxReact.observer</code>（如果你使用ES6的话是 <code>@observer</code>）确保每当数据改变，只更新UI的相关部分，就是刚才上面提到的sideways data loading。你可以自己点点试试，注意看下方的日志面板，看看UI更新的数据，你会发现，每次操作，组件的重绘数量都是最低的。</p>
<p>另外，由于每个组件都只跟踪自己的依赖，通常不需要重新渲染子组件。比如，如果购物车的总价重新渲染了，在不必要的情况下就不会重新渲染购物车里的商品列表。</p>
<h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>东西好不好,主要看疗效。<a href="https://jsfiddle.net/mweststrate/wr2hcdwL/" target="_blank" rel="external">这里</a>你可以找到一个一毛一样的应用，但没有使用mobx，而是简单的使用每次替换数据的方法构建的。只有几个商品，不会感觉到有任何区别，但一旦商品数量上升，就会提现出真正意义上的性能差异。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-4.png?1" alt="create"><br><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-5.png?1" alt="update"></p>
<p>创建大量的数据和组件的时候，基本没啥差别。但是在修改数据时，强弱立分高下力判。如果在有10000个元素的列表中更新其中10个元素的数据，速度大约快了十倍。2.5秒下降到250毫秒……那么这种差别是从哪里来的呢？让我们来瞅瞅不适用mobx时React的渲染报告：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-6.png?1" alt="without mobx render reports"></p>
<p>可以看到，ArticleViews 和 CartEntryViews一共渲染了20000次。2433毫秒的渲染时间中，2145毫秒的渲染时间是被浪费的（Wasted time）。Wasted time的意思是：花费在执行渲染函数上的时间，实际上并没有更新任何一个DOM元素。这有力地说明了，无脑更新是一件很浪费cup资源的，组件越多浪费的时间就越多。</p>
<p>相较之下，这是使用mobx的报告：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-7.png?1" alt="with mobx render reports"></p>
<p>重绘的只有31个组件，完全没有一点浪费。就是说每个重新渲染的组件都是确实需要修改的。这正是我们想要实现的效果！</p>
<p>然而，这样你就满足了吗？我们还可以再进一步优化！</p>
<p>从报告中我们还可以看出，267毫秒的总体渲染时间里，大部分剩余的渲染时间消耗在CartView的渲染上（243毫秒）。那是在更新购物车的总价属性。值得注意的是，要重新渲染CartView，也就意味着要检查购物车中一万个商品是否有修改，是否要更新CartEntryView。而这就浪费了大部分时间。我们可以把总价再单独做一个控件，CartTotalView。通过这个简单的处理，如果只是总价的变化，就可以跳过CartView的重新渲染。这使得渲染时间进一步下降到约60毫秒（见上图中的灰色那一条），这比没有使用Mobx的React应用大约快了40倍!</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好的，通过上面的例子我们看到了使用mobx和不使用mobx在性能上的区别。这里还需要强调的一点是，使用了mobx还有一个优势，就是不会影响代码的可维护性，对于程序员来说，这点很重要，就算有万般好处，如果代码写出来像屎一样难看，也不会有人想用对吧？在jsfiddle里面可以看到两个例子的完整程序。两段代码基本没啥太大的区别……┑(￣Д ￣)┍</p>
<p>那么，我们可以用其他技术达到相同的效果吗？也许吧。例如，使用ImmutableJS也能做到sideways data loading。然而，就像我刚才说的，有可能你会收获一坨是一样的代码……毕竟，恕我直言，相对于不可变对象，可变类使用起来会更方便一些。此外，不可变的数据结构不能帮助你保持计算属性。如果使用不可变数据，改变商品的名字ArticleView会重新渲染的很快，但是CartEntryView中引用的相同商品实例就会失效。</p>
<p>另一种优化React应用的方案是为每一个可能发生的操作创建事件，然后在管理这些事件，在恰当的时机恰当的地点（组件）触发（注销）它们。但这将导致编写大量的样板式代码，维护起来相当困难。我不知道人啊，反正我是懒得弄这些……（哥你是不是不会断句……这段看的好纠结啊……）</p>
<p>顺便说一下，我强烈建议使用action来抽象对模型的更新，这样能有效的做到表现和行为分离。</p>
<p>最后，在大型项目中使用mbox配合React是非常好用的。有时我看到数据变化时，界面上某个角落也跟着更新了，我自己都惊呆了……而且还没有任何性能问题，你说气人不……(￣▽￣)”……心动不如行动，让我们把繁重的维护工作都丢给React和Mobx，敬请享受更轻松有趣的coding吧~！</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="https://github.com/mobxjs/mobx" target="_blank" rel="external">MobX library</a></li>
<li><a href="https://facebook.github.io/react/docs/advanced-performance.html" target="_blank" rel="external">React performance guide</a></li>
<li><a href="https://jsfiddle.net/mweststrate/46vL0phw/" target="_blank" rel="external">Shopping cart demo, React with Observables</a></li>
<li><a href="https://jsfiddle.net/mweststrate/wr2hcdwL" target="_blank" rel="external">Shopping cart demo, React without Observables</a></li>
<li><a href="https://jsfiddle.net/mweststrate/vxn7qgdw/" target="_blank" rel="external">Shopping cart demo, JQuery with Observables</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章翻译自mobx作者 Michel Weststrate 的一篇博客，虽然我也想做到信达雅，奈何英语水平有限……所以我写的内容自动屏蔽了一些前因后果没营养的话，只翻译我觉得重点的内容。我的原则是，捞干的说，不BB~&lt;br&gt;想了解细节的话可移步&lt;a href=&quot;https://www.mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用react开发应用有啥好处，我想是个前端都能数出个十条八条来。但是如果你的项目需要在浏览器中绘制成千上万的对象，而且这些对象之前还有大量的耦合关系，那维护这些对象也够喝一壶的……mobx作者在发明mobx的时候就面临了这样一个项目，一个对象的值可能被其他对象引用，任何变化都可能引起大量的ui更新和重绘。在一些特殊场景，比如拖拽操作，这些动作还必须在40毫秒响应……&lt;/p&gt;
&lt;p&gt;于是，mobx被开发出来了。简单来说，他使用了函数响应式编程的概念 Observables 来解决上述的问题，其实 mobx 并不是第一个使用这一概念的前端库，ember、knockout还有vue其实都使用了这一概念，我个人感觉，mobx就好像把vue和knockout的数据绑定那部分抽出来然后揉到一起一样……真的能发现很多有相似的地方……使用 Observables 的好处就在于，你可以很容易实现自动更新关联数据和sideways data loading，从而解放生产力，提升应用的性能。后面测试数据一章可以看到具体的对比结果。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
      <category term="中文渣翻" scheme="http://brooch.me/tags/%E4%B8%AD%E6%96%87%E6%B8%A3%E7%BF%BB/"/>
    
  </entry>
  
  <entry>
    <title>MobX入坑指南(4) -- Utility functions</title>
    <link href="http://brooch.me/2016/12/16/MobX-simple-entry-4/"/>
    <id>http://brooch.me/2016/12/16/MobX-simple-entry-4/</id>
    <published>2016-12-16T05:11:29.000Z</published>
    <updated>2016-12-20T14:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前几篇大概介绍了mobx最常用的几个方法，这次准备把剩余的公共方法都介绍了。</p>
<h2 id="autorunAsync"><a href="#autorunAsync" class="headerlink" title="autorunAsync"></a>autorunAsync</h2><p><code>autorunAsync(debugName?: string, action: () =&gt; void, minimumDelay?: number, scope?): disposer</code></p>
<p><code>autorunAsync</code> 的功能与 <code>autorun</code> 相似，功能都是在观测对象发生变化时自动运行回调函数 <code>action</code>。不同点在于 <code>autorun</code> 是在观测对象发生变化时立即执行的，而 <code>autorunAsync</code>是异步的，可以通过 <code>minimumDelay</code> 参数来指定延迟的时间。<br><a id="more"></a><br>如果被观测对象的在延迟过程中发生多次变化，<code>action</code> 也只会在延迟结束时触发一次，所以它和后面要介绍到的 <code>transaction</code> 方法效果类似。在某些场景下这个方法很有用，比如他可以被用来防止频繁向服务端发起请求。</p>
<p>如果传了 <code>scope</code> 参数，那么 <code>scope</code> 将作为 <code>action</code> 运行时的this。</p>
<p>如果传了第一个参数 <code>debugName</code>，那么在调试工具中将使用 <code>debugName</code> 作为调试信息。</p>
<p>和 <code>autorun</code> 一样，<code>autorunAsync</code> 也会返回一个销毁函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">autorunAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 我们假设 searchBar.keyword 已经被观测, 是搜索输入框的值。当它发生变化时我们要把它发送到服务端请求搜索结果。</span></div><div class="line">	<span class="comment">// 如果这里使用autorun，那么每次变化都会向调用sendKeywordToServer。</span></div><div class="line">    <span class="comment">// 使用autorunAsync延迟300ms发送，当发送时，searchBar.keyword会是这300ms内变化的最终值。</span></div><div class="line">    <span class="comment">// 这样就可以有效的防止频繁请求造成服务抖动。</span></div><div class="line">    sendKeywordToServer(searchBar.keyword);</div><div class="line">&#125;, <span class="number">300</span>);</div></pre></td></tr></table></figure>
<h2 id="Atom类-和-Reaction类"><a href="#Atom类-和-Reaction类" class="headerlink" title="Atom类 和 Reaction类"></a>Atom类 和 Reaction类</h2><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><p>有些时候，你可能想要有更多的数据结构或其他的东西(比如streams)，也可以用于响应计算。可以使用 <code>Atom</code> 类简单快速的实现这一功能。<code>Atom</code> 实例可以通知mobx观测对象发生了变化，而mobx会在启用和停用观测对象的时候通知 <code>Atom</code> 实例。</p>
<p>下面的例子展示了 <code>Atom</code> 的全部功能，这个例子展示了如何创建一个时钟，这个时钟只有在被观测时才会运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;Atom, autorun&#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> </span>&#123;</div><div class="line">    atom;</div><div class="line">    intervalHandler = <span class="literal">null</span>;</div><div class="line">    currentDateTime;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="comment">// 创建一个Atom实例</span></div><div class="line">        <span class="keyword">this</span>.atom = <span class="keyword">new</span> Atom(</div><div class="line">            <span class="comment">// 第一个参数: Atom实例的名字, 调试用的</span></div><div class="line">            <span class="string">"Clock"</span>,</div><div class="line">            <span class="comment">// 第二个参数（可选）: 从不被监听到被监听时的回调函数.</span></div><div class="line">            () =&gt; <span class="keyword">this</span>.startTicking(),</div><div class="line">            <span class="comment">// 第三个参数（可选）: 从被监听到不被监听时的回调函数</span></div><div class="line">            <span class="comment">// 注意，atom实例会多次在这两种状态见转换</span></div><div class="line">            () =&gt; <span class="keyword">this</span>.stopTicking()</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getTime() &#123;</div><div class="line">        <span class="comment">// 如果Atom实例被响应函数调用，则reportObserved返回true。</span></div><div class="line">		<span class="comment">// 同时，reportObserved会通知mobx这个实例在响应回调中被使用了，它还会触发实例的第二个参数（startTicking）</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.atom.reportObserved()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.currentDateTime;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 当没有响应函数调用Atom实例的时候，就不会触发startTicking。</span></div><div class="line">            <span class="comment">// 根据不同的情况，这里也可以做不同的处理，比如抛出一个错误，返回一个默认值等等。</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tick() &#123;</div><div class="line">        <span class="keyword">this</span>.currentDateTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">		<span class="comment">// 通知mobx当前值发生了变化</span></div><div class="line">        <span class="keyword">this</span>.atom.reportChanged();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    startTicking() &#123;</div><div class="line">        <span class="keyword">this</span>.tick(); <span class="comment">// 初始化时钟</span></div><div class="line">        <span class="keyword">this</span>.intervalHandler = setInterval(</div><div class="line">            <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.tick(),</div><div class="line">            <span class="number">1000</span></div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    stopTicking() &#123;</div><div class="line">        clearInterval(<span class="keyword">this</span>.intervalHandler);</div><div class="line">        <span class="keyword">this</span>.intervalHandler = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> Clock();</div><div class="line"></div><div class="line"><span class="keyword">const</span> disposer = autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(clock.getTime()));</div><div class="line"></div><div class="line"><span class="comment">// ... 每秒打印时间</span></div><div class="line"></div><div class="line">disposer();</div><div class="line"></div><div class="line"><span class="comment">// 停止打印。如果没有响应函数调用当前clock实例，那么时钟将停止。会触发stopTicking函数。</span></div></pre></td></tr></table></figure>
<h3 id="Reaction"><a href="#Reaction" class="headerlink" title="Reaction"></a>Reaction</h3><p>使用 <code>Reaction</code> 可以创建一个自定义的监听器。<code>Reaction</code> 接受一个函数作为参数，他会分析这个函数所依赖的被观测对象，然后追踪他们，当他们发生变化时发出事件。</p>
<p>下面的例子展示了 <code>autorun</code> 是如何用 <code>Reaction</code> 实现的，其实这个例子我没看太懂，貌似必须调用 <code>Reaction</code> 的track方法才能追踪并发出信号，但是例子中是在 <code>Reaction</code> 接收的函数中调用，然后runReaction的时候开始，具体的得等我翻了源码之后才能知道了……</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">autorun</span>(<span class="params">view: Lambda, scope?: any</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (scope)</div><div class="line">        view = view.bind(scope);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> reaction = <span class="keyword">new</span> Reaction(view.name || <span class="string">"Autorun"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.track(view);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// 开始或者排入队列</span></div><div class="line">    <span class="keyword">if</span> (isComputingDerivation() || globalState.inTransaction &gt; <span class="number">0</span>)</div><div class="line">        globalState.pendingReactions.push(reaction);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        reaction.runReaction();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> reaction.getDisposer();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="createTransformer"><a href="#createTransformer" class="headerlink" title="createTransformer"></a>createTransformer</h2><p><code>createTransformer(transformation: (value: A) =&gt; B, onCleanup?: (result: B, value?: A) =&gt; void): (value: A) =&gt; B</code></p>
<p><code>createTransformer</code> 可以将一个转换函数（可以将一个值转换为另一个值得函数，比如数组的map方法接收的函数）包装成一个可缓存的响应函数。换句话说, 如果参数<code>transformation</code>接收到一个值A，然后把A转化为了B，那么以后再接收到A，它就会把缓存的B返回。如果A发生了变化，那么<code>transformation</code>会重新计算更新B。如果没有响应函数引用这个转换函数了，那么他将自动清除自己的缓存。</p>
<p>使用 <code>createTransformer</code> 可以方便的对一个完整的数据结构进行转换（原文：it is very easy to transform a complete data graph into another data graph，我个人理解是，作者想表达这种转换方式对图这种数据结构会特别有效……）。转换函数还可以进行嵌套，这样你就可以用很多小的转换函数碎片组成一个树状结构，描述更复杂的模型。最终组成的数据模型不会过期，他会一直与组成他的转换函数碎片保持同步。这个特性能让mobx很容易实现一些强大的功能，比如sideways data loading（react的一个概念，将数据直接推送给某些具体的组件，而非从父级层层传递，数据加载后基本上无需从底层刷新app，而是刷新若干组件中某个具体的部分）、map-reduce（仿佛说的是谷歌三宝之一的MapReduce架构……map-reduce与js相关的资料我没有查到，具体MapReduce的介绍可以看<a href="http://blog.csdn.net/opennaive/article/details/7514146" target="_blank" rel="external">这里</a>）、追踪不可变对象变更历史，等等。</p>
<p><code>onCleanup</code> 参数会在转换函数不再被使用时被调用，可以用来销毁资源。</p>
<p>转换函数需要用响应函数包装才能起作用，比如放在 <code>@observer</code> 或者 <code>autorun</code> 里。和其他的计算属性一样，如果不再有观察者调用，转换函数也将退好为惰性的，不会自动执行，以保证程序的性能。</p>
<p>上面说的各种概念可能会比较难理解，下面列出了两个例子来解释之前的概念:</p>
<h3 id="追踪数据变化，分享数据结构"><a href="#追踪数据变化，分享数据结构" class="headerlink" title="追踪数据变化，分享数据结构"></a>追踪数据变化，分享数据结构</h3><p>这个例子是从<a href="https://github.com/mobxjs/mobx-reactive2015-demo" target="_blank" rel="external">这里</a>来得（我能从中看出追踪数据状态来，但是分享数据结构没看出来……）:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">    store用来保存boxes和arrows</div><div class="line">*/</div><div class="line"><span class="keyword">const</span> store = observable(&#123;</div><div class="line">    <span class="attr">boxes</span>: [],</div><div class="line">    <span class="attr">arrows</span>: [],</div><div class="line">    <span class="attr">selection</span>: <span class="literal">null</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">    states列表用来保存序列化之后的store历史状态</div><div class="line">*/</div><div class="line"><span class="keyword">const</span> states = [];</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    states.push(serializeState(store));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">const</span> serializeState = createTransformer(<span class="function"><span class="params">store</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">boxes</span>: store.boxes.map(serializeBox),</div><div class="line">    <span class="attr">arrows</span>: store.arrows.map(serializeArrow),</div><div class="line">    <span class="attr">selection</span>: store.selection ? store.selection.id : <span class="literal">null</span></div><div class="line">&#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> serializeBox = createTransformer(<span class="function"><span class="params">box</span> =&gt;</span> (&#123;...box&#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> serializeArrow = createTransformer(<span class="function"><span class="params">arrow</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">id</span>: arrow.id,</div><div class="line">    <span class="attr">to</span>: arrow.to.id,</div><div class="line">    <span class="attr">from</span>: arrow.from.id</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>在这个例子中，states中的每个state的序列化，由三个不同的转化函数完成。autorun触发store的序列化，进而序列化所有的boxes和arrows。</p>
<p>让我们用一个假设的例子来看看执行的过程。假设我们往store.boxes中添加一个box，我们叫他box#3。</p>
<ol>
<li>首先box#3会被 <code>map</code> 方法传入 <code>serializeBox</code> 函数，<code>serializeBox</code> 函数执行将其序列化并将结果添加进自己的缓存列表。</li>
<li>当另一个box别添加进store.boxes，将导致 <code>serializeState</code> 函数重新计算结果，从而产生一个全新的boxes列表。在这个过程中，对于已存在的值，serializeBox都将从缓存列表返回旧值，这样转换函数就不需要再次运行了。</li>
<li>然后，如果有人更改box#3属性，这将导致 <code>serializeBox</code> 重新计算box#3的值。转换函数将产生一个新的box#3的Json对象，所有订阅了这个转换函数的观察者都将再次运行。这个例子中 <code>serializeState</code> 会自动执行。<code>serializeState</code>将产生新值，映射所有的box的。除了box#3，其他所有box的值都将会从缓存列表返回。</li>
<li>最后，如果box#3从 <code>store.boxes</code> 中移除，<code>serializeState</code> 也将重新计算。<code>serializeBox</code> 不再监听box#3，监听它的响应函数也将退化为非响应模式。<code>serializeBox</code> 的缓存列表中也将移除box#3的缓存。</li>
</ol>
<p>上面的例子中，我们使用不可变的状态跟踪有效的取得了状态变化列表,共享了数据结构。所有box和arrow都会被转化为简单状态树。每次计算的都会给<code>states</code> 中添加一条新的数据。不同的数据之间将共享box和arrow。</p>
<h3 id="将一个数据结构转换为一个可响应的数据结构"><a href="#将一个数据结构转换为一个可响应的数据结构" class="headerlink" title="将一个数据结构转换为一个可响应的数据结构"></a>将一个数据结构转换为一个可响应的数据结构</h3><blockquote>
<p>这段儿我都看懵逼了……纯凭感觉理解的……下面贴上原文对比着看吧</p>
</blockquote>
<p>Instead of returning plain values from a transformation function, it is also possible to return observable objects. This can be used to transform an observable data graph into a another observable data graph, which can be used to transform… you get the idea.</p>
<p>转换函数除了可以返回一般数据类型，还可以返回观测对象。所以也可以使用转换函数完成可观测对象间的转换。</p>
<p>Here is a small example that encodes a reactive file explorer that will update its representation upon each change. Data graphs that are built this way will in general react a lot faster and will consist of much more straight-forward code, compared to derived data graph that are updated using your own code. See the performance tests for some examples.</p>
<p>下面是个自动响应的文件管理器的例子。使用这种方式构建的数据结构，形式上更加简单直接，数据更新时响应速度也比一般的方式快的多。可以看一看这些例子的<a href="https://github.com/mobxjs/mobx/blob/master/test/perf/transform-perf.js#L10" target="_blank" rel="external">性能测试</a>。</p>
<p>Unlike the previous example, the transformFolder will only run once as long as a folder remains visible; the DisplayFolder objects track the associated Folder objects themselves.</p>
<p>不像之前的例子，如果文件夹一直可见，那么 <code>transformFolder</code> 只会运行一次；<code>DisplayFolder</code> 对象会追踪 <code>Folder</code> 对象的变化。</p>
<p>In the following example all mutations to the state graph will be processed automatically. Some examples:</p>
<p>下面的例子中，所有对 <code>state</code> 的改变都会自动处理。比如做如下操作：</p>
<ol>
<li><p>Changing the name of a folder will update it’s own path property and the path property of all its descendants.</p>
<p>改变文件夹的名字将更新它和它的子文件夹的文件路径，</p>
</li>
<li><p>Collapsing a folder will remove all descendant DisplayFolders from the tree.</p>
<p>折叠一个文件夹将会移除所有子文件夹的DisplayFolder实例</p>
</li>
<li><p>Expanding a folder will restore them again.</p>
<p>展开文件夹时，子文件夹再都恢复回来</p>
</li>
<li><p>Setting a search filter will remove all nodes that do not match the filter, unless they have a descendant that matches the filter.</p>
<p>如果设置了搜索过滤条件，将会只保留符合条件的子文件夹，其他的都会移除掉。<br>……</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;extendObservable, asFlat, observable, createTransformer, autorun&#125; <span class="keyword">from</span> mobx;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Folder</span>(<span class="params">parent, name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">    extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">name</span>: name,</div><div class="line">        <span class="attr">children</span>: asFlat([]),</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DisplayFolder</span>(<span class="params">folder, state</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.state = state;</div><div class="line">    <span class="keyword">this</span>.folder = folder;</div><div class="line">    extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">collapsed</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">name</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.folder.name;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">isVisible</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> !<span class="keyword">this</span>.state.filter || <span class="keyword">this</span>.name.indexOf(<span class="keyword">this</span>.state.filter) !== <span class="number">-1</span> || <span class="keyword">this</span>.children.some(<span class="function"><span class="params">child</span> =&gt;</span> child.isVisible);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">children</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.collapsed)</div><div class="line">                <span class="keyword">return</span> [];</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.folder.children.map(transformFolder).filter(<span class="function"><span class="keyword">function</span>(<span class="params">child</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> child.isVisible;</div><div class="line">            &#125;)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">path</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.folder.parent === <span class="literal">null</span> ? <span class="keyword">this</span>.name : transformFolder(<span class="keyword">this</span>.folder.parent).path + <span class="string">"/"</span> + <span class="keyword">this</span>.name;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> state = observable(&#123;</div><div class="line">    <span class="attr">root</span>: <span class="keyword">new</span> Folder(<span class="literal">null</span>, <span class="string">"root"</span>),</div><div class="line">    <span class="attr">filter</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">displayRoot</span>: <span class="literal">null</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> transformFolder = createTransformer(<span class="function"><span class="keyword">function</span> (<span class="params">folder</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DisplayFolder(folder, state);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    state.displayRoot = transformFolder(state.root);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h2><p><code>expr(worker: () =&gt; void)</code></p>
<p><code>expr</code> 可以在计算属性的函数中创建一个临时的计算属性，其实就是<code>computed(func).get()</code>。作者在文档中说设计这个api的意图是为了提升计算属性的性能，比如下面的例子，如果使用 <code>expr</code> 替代直接用比较运算，可以利用计算属性的缓存，减少运算次数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> TodoView = observer(<span class="function">(<span class="params">&#123;todo, editorState&#125;</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> isSelected = mobx.expr(<span class="function"><span class="params">()</span> =&gt;</span> editorState.selection === todo);</div><div class="line">    <span class="keyword">return</span> &lt;div className=&#123;isSelected ? "todo todo-selected" : "todo"&#125;&gt;&#123;todo.title&#125;&lt;/div&gt;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="extendObservable"><a href="#extendObservable" class="headerlink" title="extendObservable"></a>extendObservable</h2><p><code>extendObservable(target: object, ...properties: object)</code></p>
<p>在之前的几篇文章中，我们已经大概见过 <code>extendObservable</code> 应用的实例了。 <code>extendObservable</code>  和 <code>Object.assign</code> 类似，接受多个参数，将 <code>properties</code> 上所有的键值对，都合并到 <code>target</code> 上，同时把它们都转换成可观测的属性。</p>
<p>如果属性值是一个没有参数的函数，那 <code>extendObservable</code> 将用 <code>computed</code> 把它转化为一个计算属性。</p>
<p>所以，<code>observable(object)</code> 其实是 <code>extendObservable(object, object)</code>的别名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">firstName, lastName</span>) </span>&#123;</div><div class="line">    <span class="comment">// 在当前实例为观测对象</span></div><div class="line">    extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">firstName</span>: firstName,</div><div class="line">        <span class="attr">lastName</span>: lastName</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> matthew = <span class="keyword">new</span> Person(<span class="string">"Zheng"</span>, <span class="string">"Xingcheng"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 向观测对象上添加属性</span></div><div class="line">extendObservable(matthew, &#123;</div><div class="line">    <span class="attr">age</span>: <span class="number">30</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="isObservable"><a href="#isObservable" class="headerlink" title="isObservable"></a>isObservable</h2><p><code>isObservable(testValue:object, propertyName?: string)</code></p>
<p><code>isObservable</code> 是用来判断一个变量是不是用observable观测对象的，如果是就会返回true，如果想看变量的某个属性是否可观测，直接传入属性的引用是不行的，需要传第二个参数 <code>propertyName</code> 指定要判断哪个属性，如果属性可观测，就返回true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = observable(&#123;</div><div class="line">    <span class="attr">firstName</span>: <span class="string">"Zheng"</span>,</div><div class="line">    <span class="attr">lastName</span>: <span class="string">"Xingcheng"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">person.age = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(isObservable(person)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isObservable(person, <span class="string">"firstName"</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isObservable(person.firstName)); <span class="comment">// false (just a string)</span></div><div class="line"><span class="built_in">console</span>.log(isObservable(person, <span class="string">"age"</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>为了细化各种类型的判断，mobx还提供了map，array，object三种类型的判断，比起 <code>isObservable</code> ，他们的判断标准更严格，如果类型不符合就会返回false。</p>
<h3 id="isObservableMap"><a href="#isObservableMap" class="headerlink" title="isObservableMap"></a>isObservableMap</h3><p><code>isObservableMap(testValue:object)</code></p>
<p>如果<code>testValue</code>是用 <code>mobx.map</code> 创建的对象，则返回true。</p>
<h3 id="isObservableArray"><a href="#isObservableArray" class="headerlink" title="isObservableArray"></a>isObservableArray</h3><p><code>isObservableArray(testValue:object)</code></p>
<p>如果<code>testValue</code>是用 <code>mobx.observable(array)</code> 创建的对象，则返回true。</p>
<h3 id="isObservableObject"><a href="#isObservableObject" class="headerlink" title="isObservableObject"></a>isObservableObject</h3><p><code>isObservableObject(testValue:object)</code></p>
<p>如果<code>testValue</code>是用 <code>mobx.observable(object)</code> 创建的对象，则返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> testValue = observable(&#123;</div><div class="line">	<span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">    <span class="attr">obj</span>: &#123;</div><div class="line">    	<span class="attr">x</span>: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">map</span>: map([[<span class="string">'y'</span>,<span class="number">2</span>]])</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(isObservableMap(testValue.map)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isObservableArray(testValue.arr)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isObservableObject(testValue.obj)); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="modifiers"><a href="#modifiers" class="headerlink" title="modifiers"></a>modifiers</h2><h2 id="intercept-amp-observe"><a href="#intercept-amp-observe" class="headerlink" title="intercept &amp; observe"></a>intercept &amp; observe</h2><h2 id="reaction"><a href="#reaction" class="headerlink" title="reaction"></a>reaction</h2><h2 id="spy"><a href="#spy" class="headerlink" title="spy"></a>spy</h2><p><code>spy(listener)</code></p>
<p><code>spy</code> 可以注册一个全局的监听函数，监听所有的mobx发出的事件，通常是用来做log或者做调试的。</p>
<p>比如以下例子，会打印所有的action：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">spy(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (event.type === <span class="string">'action'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.name&#125;</span> with args: <span class="subst">$&#123;event.<span class="built_in">arguments</span>&#125;</span>`</span>)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>不同的操作，event也会不一样，下面的表格是每种事件对应的参数：</p>
<table>
<thead>
<tr>
<th>event</th>
<th>event带的属性</th>
<th>是否可以嵌套发生</th>
</tr>
</thead>
<tbody>
<tr>
<td>action</td>
<td>name, target (scope), arguments, fn (source function of the action)</td>
<td>yes</td>
</tr>
<tr>
<td>transaction</td>
<td>name, target (scope)</td>
<td>yes</td>
</tr>
<tr>
<td>scheduled-reaction</td>
<td>object (Reaction instance)</td>
<td>no</td>
</tr>
<tr>
<td>reaction</td>
<td>object (Reaction instance), fn (source of the reaction)</td>
<td>yes</td>
</tr>
<tr>
<td>compute</td>
<td>object (ComputedValue instance), target (scope), fn (source)</td>
<td>no</td>
</tr>
<tr>
<td>error</td>
<td>message</td>
<td>no</td>
</tr>
<tr>
<td>update (array)</td>
<td>object (the array), index, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>update (map)</td>
<td>object (observable map instance), name, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>update (object)</td>
<td>object (instance), name, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>splice (array)</td>
<td>object (the array), index, added, removed, addedCount, removedCount</td>
<td>yes</td>
</tr>
<tr>
<td>add (map)</td>
<td>object, name, newValue</td>
<td>yes</td>
</tr>
<tr>
<td>add (object)</td>
<td>object, name, newValue</td>
<td>yes</td>
</tr>
<tr>
<td>delete (map)</td>
<td>object, name, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>create (boxed observable)</td>
<td>object (ObservableValue instance), newValue</td>
<td>yes</td>
</tr>
</tbody>
</table>
<h2 id="toJS"><a href="#toJS" class="headerlink" title="toJS"></a>toJS</h2><p><code>toJS(value: any, supportCycles?=true: boolean)</code></p>
<p>toJS可以将一个observableObject下的转化为javascript原生的对象。他会递归转换array，object，map和基础类型的值，但是不会转换计算属性和其他不可枚举的值。默认情况下，toJS会缓存下每次运行的值，貌似作者设计这个api就是为了输出log用的，可以设置 <code>supportCycles</code> 参数为false来提高toJS的性能。</p>
<p>对于更复杂的序列化反序列化场景，mobx的作者推荐使用他开发的<a href="https://github.com/mobxjs/serializr" target="_blank" rel="external">serializr</a>库。</p>
<h2 id="transaction"><a href="#transaction" class="headerlink" title="transaction"></a>transaction</h2><p><code>transaction(worker: () =&gt; void)</code></p>
<p>在之前的 <code>autorunAsync</code> 有提到过，除了 <code>autorunAsync</code> ，还可以使用 <code>transaction</code> 来做批量处理。</p>
<p><code>transaction</code> 用来批处理一系列的更新，而不会通知观测对象，当所有更新结束，才会发出通知。<code>transaction</code> 接收一个没有参数的worker函数作为参数，在这个函数执行完成之前，不会通知观察者。<code>transaction</code> 的返回值就是worker函数的返回值。另外 <code>transaction</code> 是同步的，可以被嵌套，只有最外层的 <code>transaction</code> 执行完，才会触发响应。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;observable, transaction, autorun&#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> numbers = observable([]);</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(numbers.length, <span class="string">"numbers!"</span>));</div><div class="line"><span class="comment">// Prints: '0 numbers!'</span></div><div class="line"></div><div class="line">transaction(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    transaction(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        numbers.push(<span class="number">1</span>);</div><div class="line">        numbers.push(<span class="number">2</span>);</div><div class="line">    &#125;);</div><div class="line">    numbers.push(<span class="number">3</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// Prints: '3 numbers!'</span></div></pre></td></tr></table></figure>
<h2 id="untracked"><a href="#untracked" class="headerlink" title="untracked"></a>untracked</h2><p><code>untracked(fn: () =&gt; void)</code></p>
<p>使用 <code>untracked</code> 可以创建一个不被观测的代码块，通常 <code>untracked</code> 需要放在 <code>(@)action</code> 里面才有意义，比如以下的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> person = observable(&#123;</div><div class="line">    <span class="attr">firstName</span>: <span class="string">"Michel"</span>,</div><div class="line">    <span class="attr">lastName</span>: <span class="string">"Weststrate"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(</div><div class="line">        person.lastName,</div><div class="line">        <span class="string">","</span>,</div><div class="line">        <span class="comment">// person.firstName放在了untracked的回调里面，所以不会跟这个autorun的监听函数绑定到一起</span></div><div class="line">		<span class="comment">// 在修改person.firstName时就不会触发这个监听函数</span></div><div class="line">        untracked(<span class="function"><span class="params">()</span> =&gt;</span> person.firstName)</div><div class="line">    );</div><div class="line">&#125;);</div><div class="line"><span class="comment">// prints: Weststrate, Michel</span></div><div class="line"></div><div class="line">person.firstName = <span class="string">"G.K."</span>;</div><div class="line"><span class="comment">// doesn't print!</span></div><div class="line"></div><div class="line">person.lastName = <span class="string">"Chesterton"</span>;</div><div class="line"><span class="comment">// prints: Chesterton, G.K.</span></div></pre></td></tr></table></figure>
<h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p><code>when(debugName?, predicate: () =&gt; boolean, effect: () =&gt; void, scope?)</code></p>
<p><code>when</code> 会感测并运行参数predicate，predicate有点类似一个计算属性，当predicate为true的时候，则自动运行effect，然后销毁自己。所以 <code>when</code> 是一个只运行一次的 <code>autorun</code>。</p>
<p>下面这个例子展示了用 <code>when</code> 来实现自动销毁组件的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        when(</div><div class="line">            <span class="comment">// 当断言为真...</span></div><div class="line">            () =&gt; !<span class="keyword">this</span>.isVisible,</div><div class="line">            <span class="comment">// ... 则运行一次然后销毁</span></div><div class="line">            () =&gt; <span class="keyword">this</span>.dispose()</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @computed get isVisible() &#123;</div><div class="line">        <span class="comment">// 返回组件是否可见</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dispose() &#123;</div><div class="line">        <span class="comment">// 销毁组件</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇整理了下mobx的公共方法和作用。就此，基础api算是都介绍完了。之后会再着重写些使用方法和介绍mobx原理的内容。</p>
<p>话说最近懒癌又开始发作了……_(:3 」∠)_……看着朋友们跟打了鸡血一样写那么多blog好着急的说……希望以后能迎头赶上吧……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前几篇大概介绍了mobx最常用的几个方法，这次准备把剩余的公共方法都介绍了。&lt;/p&gt;
&lt;h2 id=&quot;autorunAsync&quot;&gt;&lt;a href=&quot;#autorunAsync&quot; class=&quot;headerlink&quot; title=&quot;autorunAsync&quot;&gt;&lt;/a&gt;autorunAsync&lt;/h2&gt;&lt;p&gt;&lt;code&gt;autorunAsync(debugName?: string, action: () =&amp;gt; void, minimumDelay?: number, scope?): disposer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;autorunAsync&lt;/code&gt; 的功能与 &lt;code&gt;autorun&lt;/code&gt; 相似，功能都是在观测对象发生变化时自动运行回调函数 &lt;code&gt;action&lt;/code&gt;。不同点在于 &lt;code&gt;autorun&lt;/code&gt; 是在观测对象发生变化时立即执行的，而 &lt;code&gt;autorunAsync&lt;/code&gt;是异步的，可以通过 &lt;code&gt;minimumDelay&lt;/code&gt; 参数来指定延迟的时间。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
      <category term="中文渣翻" scheme="http://brooch.me/tags/%E4%B8%AD%E6%96%87%E6%B8%A3%E7%BF%BB/"/>
    
  </entry>
  
</feed>
