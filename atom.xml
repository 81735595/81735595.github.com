<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep Walking</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://brooch.me/"/>
  <updated>2017-07-07T16:03:05.000Z</updated>
  <id>http://brooch.me/</id>
  
  <author>
    <name>投身烈火</name>
    <email>81735595@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一种用实现弹窗组件的方法</title>
    <link href="http://brooch.me/2017/07/07/how-to-make-vue-dialog-component/"/>
    <id>http://brooch.me/2017/07/07/how-to-make-vue-dialog-component/</id>
    <published>2017-07-07T14:44:39.000Z</published>
    <updated>2017-07-07T16:03:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到标题就应该知道，我又来水了……话说最近真是太忙，以至于读源码的事情被无限期搁置了（其实还不是你懒）……咳咳……言归正传，因为要做了个移动的项目，团队成员又大多是新手，所以选了vue作为基础框架。这周的工作中顺手封装了一些常用的组件，在这里记录下自己的想法，省的之后忘了，哈哈……</p>
<a id="more"></a>
<p>说到组件，最常用的应该就是弹窗组件了，而我们在使用vue或者react等框架渲染界面的时候，一般都需要事先将组件实例显示的写在render函数里面，而且需要配合一个标记组件是否显示的变量一起使用。</p>
<p>以vue为例，一般平时我们使用组件一般写成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;!-- ... --&gt;</div><div class="line">    &lt;dialog v-show="showDialog1"&gt;msg1&lt;/dialog&gt;</div><div class="line">    &lt;!-- ... --&gt;</div><div class="line">    &lt;dialog v-show="showDialog2"&gt;msg2&lt;/dialog&gt;</div><div class="line">    &lt;!-- ... --&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    data() &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">showDialog1</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">showDialog2</span>: <span class="literal">false</span>,</div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p>有些组件这样使用没问题，但是有些组件，比如dialog组件，这样使用起来虽然也说不上不方便，但是与我们平时使用组件的习惯，还是有一定差异的。一般我们都是这样调用组件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">let</span> dialog1 = <span class="keyword">new</span> Dialog(<span class="string">'msg1'</span>);</div><div class="line"><span class="keyword">let</span> dialog2 = <span class="keyword">new</span> Dialog(<span class="string">'msg2'</span>);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    methods: &#123;</div><div class="line">        fn1() &#123;</div><div class="line">            dialog1.show();</div><div class="line">        &#125;,</div><div class="line">        fn2() &#123;</div><div class="line">            dialog1.close();</div><div class="line">            dialog2.show();</div><div class="line">        &#125;,</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p>那么这样的调用方式是否能实现呢？答案是肯定的。以vue为例，需要用到Vue.extend方法创建子类来实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 首先简单定义一个组件选项</span></div><div class="line"><span class="keyword">let</span> dialogOptions = &#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">'&lt;div v-show="show"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;'</span>,</div><div class="line">    <span class="attr">props</span>: &#123;</div><div class="line">      <span class="attr">msg</span>: <span class="built_in">String</span>,</div><div class="line">    &#125;,</div><div class="line">    data() &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">show</span>: <span class="literal">false</span>,</div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 然后创建组件的构造函数</span></div><div class="line"><span class="keyword">const</span> DialogConstructor = Vue.extend(dialogOptions);</div><div class="line">DialogConstructor.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.show = <span class="literal">true</span>;</div><div class="line">&#125;;</div><div class="line">DialogConstructor.prototype.close = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.show = <span class="literal">false</span>;</div><div class="line">    <span class="built_in">document</span>.body.removeChild(<span class="keyword">this</span>.$el);</div><div class="line">    <span class="keyword">this</span>.$destroy();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 最后组织自己的调用方法</span></div><div class="line"><span class="keyword">const</span> Dialog = <span class="function">(<span class="params">msg = <span class="string">''</span></span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> ToastConstructor(&#123;</div><div class="line">        <span class="attr">el</span>: <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</div><div class="line">    &#125;);</div><div class="line">    instance.msg = msg;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(instance.$el);</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总的来说原则就是独立于当前应用，构建另一套数据结构。对于react，也应该是应该可以使用类似的方案来实现组件。虽然这与官方文档中推荐的，一个应用使用一套数据结构的实现方案有冲突，但是这样就能够使用我们熟悉的方式去开发应用了。具体如何使用还是看个人喜好吧~~</p>
<p>好的那么由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到标题就应该知道，我又来水了……话说最近真是太忙，以至于读源码的事情被无限期搁置了（其实还不是你懒）……咳咳……言归正传，因为要做了个移动的项目，团队成员又大多是新手，所以选了vue作为基础框架。这周的工作中顺手封装了一些常用的组件，在这里记录下自己的想法，省的之后忘了，哈哈……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
      <category term="弹窗组件" scheme="http://brooch.me/tags/%E5%BC%B9%E7%AA%97%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用webpack 2 tree-shaking机制时需要注意的细节</title>
    <link href="http://brooch.me/2017/06/30/webpack-tree-shaking/"/>
    <id>http://brooch.me/2017/06/30/webpack-tree-shaking/</id>
    <published>2017-06-30T14:49:44.000Z</published>
    <updated>2017-07-02T15:13:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前听朋友在群里说在使用webpack打包的时候，tree-shaking并没有起作用，询问是否需要做相应的配置才能启动机制。因为之前仔细阅读过webpack的文档，写tree-shaking的部分并没有提及需要做什么特殊的设置，所以问题应该不是出在webpack的设置上。</p>
<p>那么问题是出在哪儿呢？webpack的文档上有这样一段说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack 2 comes with a built-in support for ES2015 modules (alias harmony modules) as well as unused module export detection.</div></pre></td></tr></table></figure>
<p>大意是说，webpack 2 内部支持了es2015的模块机制。问题就出在这里，tree-shaking依赖于webpack的模块机制，而一般使用webpack时都会搭配babel使用，所以可能在webpack处理之前和babel就已经使用自己的模块机制处理完成了，所以才导致了tree-shaking没有成功。</p>
<p>当时他展示自己的babel配置是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">\\...</div><div class="line">    loader: <span class="string">'babel-loader'</span>,</div><div class="line">    <span class="attr">options</span>: &#123;</div><div class="line">        <span class="attr">presets</span>: [<span class="string">'es2015'</span>, <span class="string">'stage-0'</span>],</div><div class="line">    &#125;</div><div class="line">\\...</div></pre></td></tr></table></figure>
<p>测试之后发现，修改为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">\\...</div><div class="line">    loader: <span class="string">'babel-loader'</span>,</div><div class="line">    <span class="attr">options</span>: &#123;</div><div class="line">        <span class="attr">presets</span>: [</div><div class="line">            [<span class="string">"es2015"</span>, &#123; <span class="string">"modules"</span>: <span class="literal">false</span> &#125;],</div><div class="line">            <span class="string">"stage-2"</span></div><div class="line">        ],</div><div class="line">    &#125;</div><div class="line">\\...</div></pre></td></tr></table></figure></p>
<p>就可以了……</p>
<p>另外，如果想要保持与最新的标准同步，最好使用 babel-preset-env。</p>
<p>另外另外，在调查资料的过程中，还发了一个使用typescript时会遇到的问题，也在这里记录一下。</p>
<p>由于使用typescript时，需要先将先将代码转换到es5，所以也没法使用tree-shaking的机制。解决方法是使用babel为webpack提供的babili-webpack-plugin插件来处理压缩代码。</p>
<p>好的由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前听朋友在群里说在使用webpack打包的时候，tree-shaking并没有起作用，询问是否需要做相应的配置才能启动机制。因为之前仔细阅读过webpack的文档，写tree-shaking的部分并没有提及需要做什么特殊的设置，所以问题应该不是出在webpack的设置上。
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="http://brooch.me/tags/webpack/"/>
    
      <category term="tree-shaking" scheme="http://brooch.me/tags/tree-shaking/"/>
    
  </entry>
  
  <entry>
    <title>简单解决vim打开.vue文件没语法高亮的问题</title>
    <link href="http://brooch.me/2017/06/20/vim-vue-syntax-highlight/"/>
    <id>http://brooch.me/2017/06/20/vim-vue-syntax-highlight/</id>
    <published>2017-06-20T09:23:50.000Z</published>
    <updated>2017-06-20T10:28:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>看vue源码的时候随手写了些测试的代码，发现.vue文件在vim里没高亮，查了下发现vue作者说如果想简单处理直接使用html的高亮就行。so，直接在.vimrc文件里面加一句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">au BufRead,BufNewFile *.vue set filetype=html</div></pre></td></tr></table></figure>
<p>就ok了。</p>
<p>如果觉得html高亮还不够完美，也可以自定义高亮设置。</p>
<p>首先把之前.vimrc文件里的设置改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">au BufRead,BufNewFile *.vue set filetype=vue</div></pre></td></tr></table></figure>
<p>然后在 ~/.vim/syntax（没有自己新建一个）目录下新建文件vue.vim。让vue.vim继承html的高亮，在加上自定义的高亮就行了。</p>
<p>具体写法类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot; version那里要换成自己的vim版本</div><div class="line">runtime! /usr/share/vim/vim&lt;version&gt;/syntax/syntax/html.vim</div><div class="line"></div><div class="line">let b:current_syntax = &quot;vue&quot;</div><div class="line"></div><div class="line">&quot; custom...</div></pre></td></tr></table></figure>
<p>剩下的我就不嫌丑了，毕竟我vim还没玩儿到那么高阶……有兴趣的可以对比<a href="https://github.com/vuejs/vue-syntax-highlight/blob/master/vue.tmLanguage" target="_blank" rel="external">vue.tmLanguage</a>和sublime自带的html.tmLanguage，看看哪儿不一样，再补充到刚才的vue.vim文件里。就这样了~ ╮(￣▽￣)╭</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看vue源码的时候随手写了些测试的代码，发现.vue文件在vim里没高亮，查了下发现vue作者说如果想简单处理直接使用html的高亮就行。so，直接在.vimrc文件里面加一句：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
      <category term="vim" scheme="http://brooch.me/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(6)</title>
    <link href="http://brooch.me/2017/06/20/vue-source-notes-6/"/>
    <id>http://brooch.me/2017/06/20/vue-source-notes-6/</id>
    <published>2017-06-20T05:54:29.000Z</published>
    <updated>2017-06-23T15:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，距离上次读vue的源码已经过了一个月了，再次捡起来已经完全不认得了……啊……俗话说，一天不练手脚慢,两天不练丢一半,三天不练门外汉,四天不练瞪眼看，俗话诚不欺我……总之写到哪儿算哪儿吧，希望能跟之前写的接上……╮(￣▽￣)╭</p>
<h1 id="Vue构造函数和vue实例-instance"><a href="#Vue构造函数和vue实例-instance" class="headerlink" title="Vue构造函数和vue实例 instance"></a>Vue构造函数和vue实例 instance</h1><p>上次把global api和config都看了一遍，这次准备开始看instance这部分，这部分主要定义的是Vue构造函数和vue实例的各种方法。之前在global api中加工的Vue构造函数就出自这个模块。</p>
<h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/instance/index.js" target="_blank" rel="external">index.js</a></h2><p>这个文件是整个模块的入口，主要负责将各个子模块的功能挂载到Vue构造函数上。挂载的方法与global api一样，通过Mixin函数将方法和属性附到Vue.prototype上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></div><div class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">'./state'</span></div><div class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">'./render'</span></div><div class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">'./events'</span></div><div class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></div><div class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</div><div class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</div><div class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// _init就是Vue的起点</span></div><div class="line">  <span class="keyword">this</span>._init(options)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 挂载_init方法</span></div><div class="line">initMixin(Vue)</div><div class="line"><span class="comment">// 挂载$set、$delete方法和$data、$prop属性</span></div><div class="line">stateMixin(Vue)</div><div class="line"><span class="comment">// 挂载$on、$once、$off、$emit方法</span></div><div class="line">eventsMixin(Vue)</div><div class="line"><span class="comment">// 挂载_update、$forceUpdate、$destroy方法</span></div><div class="line">lifecycleMixin(Vue)</div><div class="line"><span class="comment">// 挂载$nextTick、_render方法</span></div><div class="line">renderMixin(Vue)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure>
<p>可以看到_init是构造vue对象的起点，下面我们顺着mixin的挂载顺序，逐个分析文件。</p>
<h2 id="init-js"><a href="#init-js" class="headerlink" title="init.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/instance/init.js" target="_blank" rel="external">init.js</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @flow */</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; perf &#125; <span class="keyword">from</span> <span class="string">'../util/perf'</span></div><div class="line"><span class="keyword">import</span> &#123; initProxy &#125; <span class="keyword">from</span> <span class="string">'./proxy'</span></div><div class="line"><span class="keyword">import</span> &#123; initState &#125; <span class="keyword">from</span> <span class="string">'./state'</span></div><div class="line"><span class="keyword">import</span> &#123; initRender &#125; <span class="keyword">from</span> <span class="string">'./render'</span></div><div class="line"><span class="keyword">import</span> &#123; initEvents &#125; <span class="keyword">from</span> <span class="string">'./events'</span></div><div class="line"><span class="keyword">import</span> &#123; initInjections &#125; <span class="keyword">from</span> <span class="string">'./inject'</span></div><div class="line"><span class="keyword">import</span> &#123; initLifecycle, callHook &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></div><div class="line"><span class="keyword">import</span> &#123; extend, mergeOptions, formatComponentName &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> uid = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</div><div class="line">  <span class="comment">// vue对象的初始化方法</span></div><div class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</div><div class="line">    <span class="comment">/* istanbul ignore if 覆盖率工具istanbul的注释语法，下面的if语句不会计入覆盖率*/</span></div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; perf) &#123;</div><div class="line">      perf.mark(<span class="string">'init'</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">    <span class="comment">// uid是用来作为vue对象的唯一标示用的</span></div><div class="line">    vm._uid = uid++</div><div class="line">    <span class="comment">// 避免vue对象被观测的标记</span></div><div class="line">    vm._isVue = <span class="literal">true</span></div><div class="line">    <span class="comment">// 合并options</span></div><div class="line">    <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</div><div class="line">      <span class="comment">// 如果是组件就走这个逻辑，initInternalComponent函数合并options的速度要比mergeOptions更快</span></div><div class="line">      initInternalComponent(vm, options)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 实例化vue类的时候会调到这里，就是直接 new Vue 或者用 Vue.extend 扩展的子类</span></div><div class="line">      <span class="comment">// 用之前也说过mergeOptions主要用于扩展和继承</span></div><div class="line">      <span class="comment">// 这里用来整理当前的options</span></div><div class="line">      vm.$options = mergeOptions(</div><div class="line">        <span class="comment">// 这里获取类的options</span></div><div class="line">        resolveConstructorOptions(vm.constructor),</div><div class="line">        options || &#123;&#125;,</div><div class="line">        vm</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* istanbul ignore else */</span></div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">      initProxy(vm)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      vm._renderProxy = vm</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 把vm暴露出来</span></div><div class="line">    vm._self = vm</div><div class="line">    <span class="comment">// 启动在index里面挂载的各个模块</span></div><div class="line">    initLifecycle(vm)</div><div class="line">    initEvents(vm)</div><div class="line">    initRender(vm)</div><div class="line">    callHook(vm, <span class="string">'beforeCreate'</span>)</div><div class="line">    initState(vm)</div><div class="line">    initInjections(vm)</div><div class="line">    callHook(vm, <span class="string">'created'</span>)</div><div class="line"></div><div class="line">    <span class="comment">/* istanbul ignore if */</span></div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; perf) &#123;</div><div class="line">      vm._name = formatComponentName(vm, <span class="literal">false</span>)</div><div class="line">      perf.mark(<span class="string">'init end'</span>)</div><div class="line">      perf.measure(<span class="string">`<span class="subst">$&#123;vm._name&#125;</span> init`</span>, <span class="string">'init'</span>, <span class="string">'init end'</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</div><div class="line">      <span class="comment">// options有el参数的时候会自动执行绑定函数</span></div><div class="line">      vm.$mount(vm.$options.el)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 组件的初始化使用的函数，效率比使用mergeOptions效率高</span></div><div class="line"><span class="comment">// 因为函数内只赋值了特定的属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initInternalComponent</span> (<span class="params">vm: Component, options: InternalComponentOptions</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> opts = vm.$options = <span class="built_in">Object</span>.create(vm.constructor.options)</div><div class="line">  opts.parent = options.parent</div><div class="line">  opts.propsData = options.propsData</div><div class="line">  opts._parentVnode = options._parentVnode</div><div class="line">  opts._parentListeners = options._parentListeners</div><div class="line">  opts._renderChildren = options._renderChildren</div><div class="line">  opts._componentTag = options._componentTag</div><div class="line">  opts._parentElm = options._parentElm</div><div class="line">  opts._refElm = options._refElm</div><div class="line">  <span class="keyword">if</span> (options.render) &#123;</div><div class="line">    opts.render = options.render</div><div class="line">    opts.staticRenderFns = options.staticRenderFns</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 整理获取类的options</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span> (<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> options = Ctor.options</div><div class="line">  <span class="keyword">if</span> (Ctor.super) &#123;</div><div class="line">    <span class="comment">// 如果有父类，就整理父类的options</span></div><div class="line">    <span class="keyword">const</span> superOptions = resolveConstructorOptions(Ctor.super)</div><div class="line">    <span class="keyword">const</span> cachedSuperOptions = Ctor.superOptions</div><div class="line">    <span class="keyword">if</span> (superOptions !== cachedSuperOptions) &#123;</div><div class="line">      <span class="comment">// 如果父类的options有变化，需要重新获取父类的options</span></div><div class="line">      Ctor.superOptions = superOptions</div><div class="line">      <span class="comment">// resolveModifiedOptions可以检查options的更新</span></div><div class="line">      <span class="keyword">const</span> modifiedOptions = resolveModifiedOptions(Ctor)</div><div class="line">      <span class="comment">// 同步修改过的属性</span></div><div class="line">      <span class="keyword">if</span> (modifiedOptions) &#123;</div><div class="line">        extend(Ctor.extendOptions, modifiedOptions)</div><div class="line">      &#125;</div><div class="line">      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)</div><div class="line">      <span class="keyword">if</span> (options.name) &#123;</div><div class="line">        options.components[options.name] = Ctor</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> options</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 检查options的更新</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveModifiedOptions</span> (<span class="params">Ctor: Class&lt;Component&gt;</span>): ?<span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="keyword">let</span> modified</div><div class="line">  <span class="keyword">const</span> latest = Ctor.options</div><div class="line">  <span class="keyword">const</span> sealed = Ctor.sealedOptions</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> latest) &#123;</div><div class="line">    <span class="keyword">if</span> (latest[key] !== sealed[key]) &#123;</div><div class="line">      <span class="keyword">if</span> (!modified) modified = &#123;&#125;</div><div class="line">      modified[key] = dedupe(latest[key], sealed[key])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> modified</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 删除重复数据的函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span> (<span class="params">latest, sealed</span>) </span>&#123;</div><div class="line">  <span class="comment">// 主要是处理生命周期回调，让回调不会直接被替换赋值，而是被逐个添加</span></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(latest)) &#123;</div><div class="line">    <span class="keyword">const</span> res = []</div><div class="line">    sealed = <span class="built_in">Array</span>.isArray(sealed) ? sealed : [sealed]</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; latest.length; i++) &#123;</div><div class="line">      <span class="keyword">if</span> (sealed.indexOf(latest[i]) &lt; <span class="number">0</span>) &#123;</div><div class="line">        res.push(latest[i])</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> latest</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个模块对于 vue 实例的处理有很多都可以在官方文档的说明中找到，文档中没有描述的是 options 对象的继承。可以看到 options 对象的继承和并不是基于原型链的，而是基于合并赋值，我猜这么做的目的是为了让程序运行起来更快，毕竟省了一个遍历原型链的过程……</p>
<h2 id="proxy-js"><a href="#proxy-js" class="headerlink" title="proxy.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/instance/proxy.js" target="_blank" rel="external">proxy.js</a></h2><p>proxy 这部分的启动逻辑只有在非生产环境才能起作用，感觉不是很重要啊……主要的作用是用来检查vm添加的属性是不是系统变量，如果是系统变量就报警告，貌似是这样吧……Proxy方法是用来定义对象属性的基本操作的，感觉跟defineProperty有点像</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//flow无法检查原生对象Proxy，所有这个文件就没用flow</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'core/config'</span></div><div class="line"><span class="keyword">import</span> &#123; warn, makeMap &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> initProxy</div><div class="line"></div><div class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">  <span class="keyword">const</span> allowedGlobals = makeMap(</div><div class="line">    <span class="string">'Infinity,undefined,NaN,isFinite,isNaN,'</span> +</div><div class="line">    <span class="string">'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,'</span> +</div><div class="line">    <span class="string">'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,'</span> +</div><div class="line">    <span class="string">'require'</span> <span class="comment">// for Webpack/Browserify</span></div><div class="line">  )</div><div class="line"></div><div class="line">  <span class="keyword">const</span> warnNonPresent = <span class="function">(<span class="params">target, key</span>) =&gt;</span> &#123;</div><div class="line">    warn(</div><div class="line">      <span class="string">`Property or method "<span class="subst">$&#123;key&#125;</span>" is not defined on the instance but `</span> +</div><div class="line">      <span class="string">`referenced during render. Make sure to declare reactive data `</span> +</div><div class="line">      <span class="string">`properties in the data option.`</span>,</div><div class="line">      target</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> hasProxy =</div><div class="line">    <span class="keyword">typeof</span> <span class="built_in">Proxy</span> !== <span class="string">'undefined'</span> &amp;&amp;</div><div class="line">    <span class="built_in">Proxy</span>.toString().match(<span class="regexp">/native code/</span>)</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (hasProxy) &#123;</div><div class="line">    <span class="keyword">const</span> isBuiltInModifier = makeMap(<span class="string">'stop,prevent,self,ctrl,shift,alt,meta'</span>)</div><div class="line">    config.keyCodes = <span class="keyword">new</span> <span class="built_in">Proxy</span>(config.keyCodes, &#123;</div><div class="line">      set (target, key, value) &#123;</div><div class="line">        <span class="keyword">if</span> (isBuiltInModifier(key)) &#123;</div><div class="line">          warn(<span class="string">`Avoid overwriting built-in modifier in config.keyCodes: .<span class="subst">$&#123;key&#125;</span>`</span>)</div><div class="line">          <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          target[key] = value</div><div class="line">          <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> hasHandler = &#123;</div><div class="line">    has (target, key) &#123;</div><div class="line">      <span class="keyword">const</span> has = key <span class="keyword">in</span> target</div><div class="line">      <span class="keyword">const</span> isAllowed = allowedGlobals(key) || key.charAt(<span class="number">0</span>) === <span class="string">'_'</span></div><div class="line">      <span class="keyword">if</span> (!has &amp;&amp; !isAllowed) &#123;</div><div class="line">        warnNonPresent(target, key)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> has || !isAllowed</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> getHandler = &#123;</div><div class="line">    get (target, key) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'string'</span> &amp;&amp; !(key <span class="keyword">in</span> target)) &#123;</div><div class="line">        warnNonPresent(target, key)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> target[key]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  initProxy = <span class="function"><span class="keyword">function</span> <span class="title">initProxy</span> (<span class="params">vm</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (hasProxy) &#123;</div><div class="line">      <span class="comment">// determine which proxy handler to use</span></div><div class="line">      <span class="keyword">const</span> options = vm.$options</div><div class="line">      <span class="comment">// _withStripped这个属性如果被设为true，则不能给vm添加系统变量作为属性，貌似吧……具体的用法是在测试代码里找到的……</span></div><div class="line">      <span class="keyword">const</span> handlers = options.render &amp;&amp; options.render._withStripped</div><div class="line">        ? getHandler</div><div class="line">        : hasHandler</div><div class="line">      vm._renderProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(vm, handlers)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      vm._renderProxy = vm</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123; initProxy &#125;</div></pre></td></tr></table></figure>
<p>今天就到这儿吧，累了，话说下周开始我们也要007了……真是嘴贱某次跟领导吃饭的时候把007当笑话告诉了他，结果给他打开了新世界的大门……如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的力度了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，距离上次读vue的源码已经过了一个月了，再次捡起来已经完全不认得了……啊……俗话说，一天不练手脚慢,两天不练丢一半,三天不练门外汉,四天不练瞪眼看，俗话诚不欺我……总之写到哪儿算哪儿吧，希望能跟之前写的接上……╮(￣▽￣)╭&lt;/p&gt;
&lt;h1 id=&quot;Vue构造函数和vu
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Picodom中的diff算法补完</title>
    <link href="http://brooch.me/2017/06/16/picodom-introduce-additional/"/>
    <id>http://brooch.me/2017/06/16/picodom-introduce-additional/</id>
    <published>2017-06-16T05:13:27.000Z</published>
    <updated>2017-06-16T14:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2017/06/09/picodom-introduce/">上次</a>看 Picodom 代码的时候，patch 函数中有段代码没怎么看懂，所以就没分析，算是挖下了坑。经过这几天的思考，我终于把逻辑想明白了，今儿咱就来把这个坑给填上~（美错儿，我今天又要划水了，来打我呀打我呀打我呀~）</p>
<a id="more"></a>
<h2 id="逻辑梳理"><a href="#逻辑梳理" class="headerlink" title="逻辑梳理"></a>逻辑梳理</h2><p>上次看到 Picodom 中 的 patch 函数中，逻辑分为三个分支，分别是新增节点（没有oldNode），修改节点（newNode和oldNode标签名一样），替换节点（newNode和oldNode标签名不一样）。其中，新增节点和替换节点的操作比较简单。单修改节点的操作，除了要修改节点本身的属性外，还要对比更新节点的子节点，逻辑比较复杂，直接讲代码的话不太容易看出其中的逻辑，咱们先来梳理一下。</p>
<p>说到子节点变化，一般会分为以下这几种情况：</p>
<ol>
<li>增加新节点：有可能在旧列表的最开始，中间或者之后添加</li>
<li>复用旧节点：还记得之前看的代码中，Picodom 会把节点的 key 属性特殊对待吗？这里就是把 key 作为节点的唯一标识的，只要 key 对上了就认为是能复用，dom节点不用新建，不过位置有可能发生变化</li>
<li>删除旧节点：删除单个或者多个节点</li>
<li>把以上这些情况综合起来~</li>
</ol>
<p>如图，比如像下面这种情况：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/picodom-introduce-additional-01.jpg" alt="01"></p>
<p>其实这逻辑说起来感觉还挺简单，但是如何用代码实现呢？我们先说下 Picodom 的处理方法，以上图为例。</p>
<p>遍历新节点列表，新节点列表和旧节点列表里各取一个，作为当前新节点和当前旧节点，对比他们，这俩节点 key 不一样，而且在旧节点列表里也没有找到这个节点，于是在当前旧节点前添加新节点，当前新节点切换到下一节点。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/picodom-introduce-additional-02.jpg" alt="02"></p>
<p>当前新节点和当前旧节点 key 不一样，但是在旧节点列表里能找到，就把找到的旧节点插入到当前旧节点前面，当前新节点切换到下一节点。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/picodom-introduce-additional-03.jpg" alt="03"></p>
<p>对新节点列表中的 4 和 7 的处理和前面一样，就不再多说了。处理过他们之后，取到的当前新节点和当前旧节点的 key 是一样的。这时把新旧节点都传入 patch 函数，递归处理这两个节点。处理过之后，当前新节点和当前旧节点都切换到下一节点。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/picodom-introduce-additional-04.jpg" alt="04"></p>
<p>根据之前的步骤，把 2 也处理了，最后当前新节点是 8 ，当前旧节点是 3 ，8 是新增的，所以插入到 3 前面。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/picodom-introduce-additional-05.jpg" alt="05"></p>
<p>最后将未用到的旧节点删除掉，既把 3 删掉，得到最终结果。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>ok，让我们来看下 Picodom 是如何用代码来实现上述逻辑的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> len = node.children.length</div><div class="line"><span class="comment">// 新子节点vnode列表的长度</span></div><div class="line"><span class="keyword">var</span> oldLen = oldNode.children.length</div><div class="line"><span class="comment">// 旧子节点vnode列表的长度</span></div><div class="line"><span class="keyword">var</span> reusableChildren = &#123;&#125;</div><div class="line"><span class="comment">// 可复用节点列表</span></div><div class="line"><span class="keyword">var</span> oldElements = []</div><div class="line"><span class="comment">// 旧子节点dom列表</span></div><div class="line"><span class="keyword">var</span> newKeys = &#123;&#125;</div><div class="line"><span class="comment">// 这边变量用来标记新子节点列表中复用的节点</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oldLen; i++) &#123;</div><div class="line">    <span class="keyword">var</span> oldElement = element.childNodes[i]</div><div class="line">    oldElements[i] = oldElement</div><div class="line"></div><div class="line">    <span class="keyword">var</span> oldChild = oldNode.children[i]</div><div class="line">    <span class="keyword">var</span> oldKey = getKeyFrom(oldChild)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != oldKey) &#123;</div><div class="line">        reusableChildren[oldKey] = [oldElement, oldChil]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 上面这个循环是在遍历旧子节点vnode列表，把有key的挑出来，放到可复用节点列表里</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> j = <span class="number">0</span></div><div class="line"><span class="comment">// i是旧子节点vnode列表的索引，j是新子节点vnode列表的索引</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> (j &lt; len) &#123;</div><div class="line"><span class="comment">// 遍历新子节点vnode列表</span></div><div class="line">    <span class="keyword">var</span> oldElement = oldElements[i]</div><div class="line">    <span class="comment">// 取当前旧节点dom</span></div><div class="line">    <span class="keyword">var</span> oldChild = oldNode.children[i]</div><div class="line">    <span class="comment">// 取当前旧节点vnode</span></div><div class="line">    <span class="keyword">var</span> newChild = node.children[j]</div><div class="line">    <span class="comment">// 取当前新节点vnode</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> oldKey = getKeyFrom(oldChild)</div><div class="line">    <span class="comment">// 取当前旧节点的key</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (newKeys[oldKey]) &#123;</div><div class="line">        i++</div><div class="line">        <span class="keyword">continue</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 上面这个判断是为了跳过已经被使用过的旧子节点</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> newKey = getKeyFrom(newChild)</div><div class="line">    <span class="comment">// 取当前新节点的key</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> reusableChild = reusableChildren[newKey] || []</div><div class="line">    <span class="comment">// 取当前新节点key对应的可复用节点</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == newKey) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == oldKey) &#123;</div><div class="line">            patch(element, oldElement, oldChild, newChild)</div><div class="line">            j++</div><div class="line">            <span class="comment">// 如果新节点和旧节点都没有key则在当前旧节点对应的dom节点前插入新节点</span></div><div class="line">            <span class="comment">// 然后切换当前新节点</span></div><div class="line">        &#125;</div><div class="line">        i++</div><div class="line">        <span class="comment">// 这里的处理方式让人很难理解，为啥是新节点和旧节点都没有key的时候才插入？</span></div><div class="line">        <span class="comment">// 我感觉这样处理主要是为了处理文本节点……因为文本节点是肯定没有key的</span></div><div class="line">        <span class="comment">// 另外如果新节点里出现了一个没有key的节点，</span></div><div class="line">        <span class="comment">// 那么上面这段逻辑就会一直切换的当前旧节点，</span></div><div class="line">        <span class="comment">// 直到找到一个同样没有key的旧节点，再用patch对比两个节点，</span></div><div class="line">        <span class="comment">// 如果一直没有找到没有key的旧节点，最后oldElement和oldChild都是null，</span></div><div class="line">        <span class="comment">// 相当于在旧节点列表最后添加一个新的节点，</span></div><div class="line">        <span class="comment">// 此时当前旧节点已经切到旧节点列表最后了，</span></div><div class="line">        <span class="comment">// 所以后续的所有操作都是往旧节点列表最后添加新的节点</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (oldKey === newKey) &#123;</div><div class="line">            patch(element, reusableChild[<span class="number">0</span>], reusableChild[<span class="number">1</span>], newChild)</div><div class="line">            i++</div><div class="line">            <span class="comment">// 如果新节点和旧节点的key相同，则用patch再去对比这两个节点</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reusableChild[<span class="number">0</span>]) &#123;</div><div class="line">            element.insertBefore(reusableChild[<span class="number">0</span>], oldElement)</div><div class="line">            patch(element, reusableChild[<span class="number">0</span>], reusableChild[<span class="number">1</span>], newChild)</div><div class="line">            <span class="comment">// 如果key不相同但是存在可复用节点，则把可复用节点插入到当前旧节点前面</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            patch(element, oldElement, <span class="literal">null</span>, newChild)</div><div class="line">            <span class="comment">// 如果key不同而且不存在可复用节点，则在当前旧节点前面插入个新节点</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        j++</div><div class="line">        <span class="comment">// 切换当前新节点</span></div><div class="line">        newKeys[newKey] = newChild</div><div class="line">        <span class="comment">// 记录已经使用的节点的key，后续可以用来过滤出已经使用的可复用节点</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 根据key复用旧节点</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> (i &lt; oldLen) &#123;</div><div class="line">    <span class="keyword">var</span> oldChild = oldNode.children[i]</div><div class="line">    <span class="keyword">var</span> oldKey = getKeyFrom(oldChild)</div><div class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == oldKey) &#123;</div><div class="line">        removeElement(element, oldElements[i], oldChild)</div><div class="line">    &#125;</div><div class="line">    i++</div><div class="line">&#125;</div><div class="line"><span class="comment">// 移除没有key的旧节点</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> reusableChildren) &#123;</div><div class="line">    <span class="keyword">var</span> reusableChild = reusableChildren[i]</div><div class="line">    <span class="keyword">var</span> reusableNode = reusableChild[<span class="number">1</span>]</div><div class="line">    <span class="keyword">if</span> (!newKeys[reusableNode.data.key]) &#123;</div><div class="line">        removeElement(element, reusableChild[<span class="number">0</span>], reusableNode)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 根据新节点的key过滤并移除掉已经使用的可复用节点</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>看过代码之后我们会发现，如果出现没有key的节点那么之前那套算法的效率就会变差，因为有可能需要遍历整个旧节点列表之后才能对比，这也就是不难理解为啥之前版本的react会自动生成一个datareact-id了……从这个角度来看，感觉给节点加上唯一key做表示可以提升界面更新的效率，不知道react或者vue里这么搞是不是有效……</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/picodom-introduce-additional-06.jpg" alt="06"></p>
<p>好的那么由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2017/06/09/picodom-introduce/&quot;&gt;上次&lt;/a&gt;看 Picodom 代码的时候，patch 函数中有段代码没怎么看懂，所以就没分析，算是挖下了坑。经过这几天的思考，我终于把逻辑想明白了，今儿咱就来把这个坑给填上~（美错儿，我今天又要划水了，来打我呀打我呀打我呀~）&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="virtual dom" scheme="http://brooch.me/tags/virtual-dom/"/>
    
      <category term="picodom" scheme="http://brooch.me/tags/picodom/"/>
    
  </entry>
  
  <entry>
    <title>Picodom -- 1kb的Virtual DOM库</title>
    <link href="http://brooch.me/2017/06/09/picodom-introduce/"/>
    <id>http://brooch.me/2017/06/09/picodom-introduce/</id>
    <published>2017-06-09T12:10:23.000Z</published>
    <updated>2017-06-09T15:01:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>话说，对于Virtual DOM解析的文章不少。但是，要不就是浅尝辄止，说到把dom解析成树型数据结构就结束了，不讲补丁算法，要不就是补丁算法说的太深奥完全理解不了。今天发现个好货，<a href="https://github.com/picodom/" target="_blank" rel="external">Picodom</a>，这个库用了200多行代码就把 virtual dom 和 patch 算法实现了，这下好了，有了实际代码理论也好理解，废话少说，快来一起读代码吧~</p>
<a id="more"></a>
<p>咱们先看看咋使，官方给出了一个<a href="https://codepen.io/picodom/pen/BRbJpG" target="_blank" rel="external">小栗子</a>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; h, patch &#125; <span class="keyword">from</span> <span class="string">"picodom"</span></div><div class="line"></div><div class="line"><span class="comment">/** @jsx h */</span></div><div class="line"><span class="comment">// 加了这个之后babel就会用h作为jsx中的vnode构造函数</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> element, oldNode</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 重新刷新界面用的</div><div class="line"> * @param newNode 新的vnode</div><div class="line"> * @return 更新后的dom对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">newNode</span>) </span>&#123;</div><div class="line">    <span class="comment">// 为了方便理解我稍微修改了下这个函数</span></div><div class="line">    element = patch(</div><div class="line">        <span class="built_in">document</span>.body, <span class="comment">// 要更新的节点的父级</span></div><div class="line">        element, <span class="comment">// 要更新的节点对应的dom对象</span></div><div class="line">        oldNode, <span class="comment">// 根据旧状态构造的vnode</span></div><div class="line">        newNode <span class="comment">// 根据新状态构造的vnode</span></div><div class="line">    )</div><div class="line">    <span class="comment">// patch函数会更新界面，返回更新后的dom节点</span></div><div class="line">    oldNode = newNode</div><div class="line">    <span class="comment">// 更新后将传入的vnode标记为旧的</span></div><div class="line">    <span class="keyword">return</span> element</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据不同的state生成不同的vnode对象</div><div class="line"> * @param state 新的状态</div><div class="line"> * @return 构造好的vnode对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">view</span>(<span class="params">state</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        &lt;div&gt;</div><div class="line">        &lt;h1&gt;&#123;state&#125;&lt;/h1&gt;</div><div class="line">        &lt;input</div><div class="line">            oninput=&#123;e =&gt; render(view(e.target.value))&#125;</div><div class="line">            // 每次input框的值变化时都重新运行render，来刷新界面</div><div class="line">            value=&#123;state&#125;</div><div class="line">            type="text"</div><div class="line">        /&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    )</div><div class="line">&#125;</div><div class="line"></div><div class="line">render(view("Hello Picodom!"))</div><div class="line">// 启动~！</div></pre></td></tr></table></figure>
<p>picodom 的 核心的一共就俩文件，h.js 用来实现 virtual dom ，patch.js 用来实现补丁算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|</div><div class="line">|-- index.js <span class="comment">// 导出h和patch方法</span></div><div class="line">|-- h.js <span class="comment">// 实现 virtual dom </span></div><div class="line">|-- patch.js <span class="comment">// 实现 patch</span></div></pre></td></tr></table></figure>
<p>先看看 virtual dom 是怎么实现的吧。</p>
<p>平时写jsx没感觉，但是看babel转换后的代码就可以看到，比如这样的结构：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">    &lt;h1&gt;&#123;state&#125;&lt;/h1&gt;</div><div class="line">    &lt;input</div><div class="line">        oninput=&#123;e =&gt; <span class="built_in">console</span>.log(e.target.value)&#125;</div><div class="line">        value=&#123;state&#125;</div><div class="line">        type=<span class="string">"text"</span></div><div class="line">    /&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>转换后应该是类似这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假设fn是vnode构造函数</span></div><div class="line">fn(<span class="string">'div'</span>, <span class="literal">null</span>, </div><div class="line">    fn(<span class="string">'h1'</span>, <span class="literal">null</span>, state), </div><div class="line">    fn(<span class="string">'input'</span>, &#123;</div><div class="line">        <span class="attr">oninput</span>: <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e.target.value),</div><div class="line">        <span class="attr">value</span>: state,</div><div class="line">        <span class="attr">type</span>: <span class="string">"text"</span></div><div class="line">    &#125;)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>从上面的伪码可已看出，一般 virtual dom 的构造函数接收的参数中，第一个参数是标签名，第二个参数是属性，后面的参数是子节点。ok，那我们来看下 h.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * virtual dom 节点构造函数</div><div class="line"> * @param tag 标签名</div><div class="line"> * @param data 标签属性</div><div class="line"> * @return 构造好的vnode</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> node</div><div class="line">    <span class="keyword">var</span> stack = []</div><div class="line">    <span class="keyword">var</span> children = []</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="built_in">arguments</span>.length; i-- &gt; <span class="number">2</span>;) &#123;</div><div class="line">        stack[stack.length] = <span class="built_in">arguments</span>[i]</div><div class="line">        <span class="comment">// 除了前两个参数，其他的参数作为子节点的数据，都推入stack备用</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (stack.length) &#123;</div><div class="line">        <span class="comment">// 循环stack</span></div><div class="line">        node = stack.pop()</div><div class="line">        <span class="comment">// 逐个取出子节点的数据</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(node)) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = node.length; i--;) &#123;</div><div class="line">                stack[stack.length] = node[i]</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果子节点数据是个数组，就把他展开</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; node !== <span class="literal">true</span> &amp;&amp; node !== <span class="literal">false</span>) &#123;</div><div class="line">            <span class="comment">// 子节点数据是null、true、false时不做处理</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">"number"</span>) &#123;</div><div class="line">                node = node + <span class="string">""</span></div><div class="line">                <span class="comment">// 如果子节点数据是数字，则转换成字符串</span></div><div class="line">            &#125;</div><div class="line">            children[children.length] = node</div><div class="line">            <span class="comment">//把子节点数据存到children里</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 上面的循环结束后，所有的子节点数据都已经展开，并存到children中</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> tag === <span class="string">"string"</span> ?</div><div class="line">        &#123;</div><div class="line">            <span class="attr">tag</span>: tag,</div><div class="line">            <span class="attr">data</span>: data || &#123;&#125;,</div><div class="line">            <span class="attr">children</span>: children</div><div class="line">        &#125; :</div><div class="line">        tag(data, children)</div><div class="line">    <span class="comment">// 如果tag是字符串就返回一个节点的描述对象</span></div><div class="line">    <span class="comment">// 如果tag不是字符串就认为tag是组件构造函数，将节点的属性信息和子节点信息都传进去，让其创建节点描述对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看过上面的代码我们不难想象，最终构造出的 virtual dom，就是一个描述dom片段的树状结构的对象，每个节点有tag、data、children三个属性，tag、data描述当前节点，children描述子节点，最终描述出整个dom片段。</p>
<p>看过 virtual dom 的构造函数之后，是不是觉得比想象中简单？只要理清逻辑，其实你也能写出来对不对？</p>
<p>好的，那我们再来看看patch.js，代码中不重要的函数我先标注作用，想看具体实现就往后拉吧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 非重点函数的功能</div><div class="line"> * createElementFrom 根据vnode创建节点，里面会递归children创建子节点</div><div class="line"> * updateElementData 根据新的vnode更新当前dom对象的属性值</div><div class="line"> * getKeyFrom 获取vnode的key属性，key属性使用来标记元素唯一性的</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 补丁算法实现函数</div><div class="line"> * @param parent    要更新节点的父节点dom对象</div><div class="line"> * @param element   要更新节点的dom对象</div><div class="line"> * @param oldNode   要更新节点旧的vnode对象</div><div class="line"> * @param node      要更新节点新的vnode对象</div><div class="line"> * @return 刷新后的dom节点</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">parent, element, oldNode, node</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (oldNode == <span class="literal">null</span>) &#123;</div><div class="line">        element = parent.insertBefore(createElementFrom(node), element)</div><div class="line">        <span class="comment">// 如果没有旧的vnode对象则直接创建插入节点</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.tag &amp;&amp; node.tag === oldNode.tag) &#123;</div><div class="line">        updateElementData(element, oldNode.data, node.data)</div><div class="line">        <span class="comment">// 如果当前节点的标签名没有变化，则直接当前节点的属性</span></div><div class="line">        <span class="keyword">var</span> len = node.children.length</div><div class="line">        <span class="keyword">var</span> oldLen = oldNode.children.length</div><div class="line">        <span class="keyword">var</span> reusableChildren = &#123;&#125;</div><div class="line">        <span class="keyword">var</span> oldElements = []</div><div class="line">        <span class="keyword">var</span> newKeys = &#123;&#125;</div><div class="line"></div><div class="line">        <span class="comment">// 下面主要做的就是对比子节点</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oldLen; i++) &#123;</div><div class="line">            <span class="keyword">var</span> oldElement = element.childNodes[i]</div><div class="line">            oldElements[i] = oldElement</div><div class="line"></div><div class="line">            <span class="keyword">var</span> oldChild = oldNode.children[i]</div><div class="line">            <span class="keyword">var</span> oldKey = getKeyFrom(oldChild)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != oldKey) &#123;</div><div class="line">                reusableChildren[oldKey] = [oldElement, oldChil]</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 用旧vnode的子节点构造一个可复用的列表</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">        <span class="keyword">var</span> j = <span class="number">0</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (j &lt; len) &#123;</div><div class="line">            <span class="keyword">var</span> oldElement = oldElements[i]</div><div class="line">            <span class="keyword">var</span> oldChild = oldNode.children[i]</div><div class="line">            <span class="keyword">var</span> newChild = node.children[j]</div><div class="line"></div><div class="line">            <span class="keyword">var</span> oldKey = getKeyFrom(oldChild)</div><div class="line">            <span class="keyword">if</span> (newKeys[oldKey]) &#123;</div><div class="line">                i++</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">var</span> newKey = getKeyFrom(newChild)</div><div class="line"></div><div class="line">            <span class="keyword">var</span> reusableChild = reusableChildren[newKey] || []</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == newKey) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == oldKey) &#123;</div><div class="line">                    patch(element, oldElement, oldChild, newChild)</div><div class="line">                    j++</div><div class="line">                &#125;</div><div class="line">                i++</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (oldKey === newKey) &#123;</div><div class="line">                    patch(element, reusableChild[<span class="number">0</span>], reusableChild[<span class="number">1</span>], newChild)</div><div class="line">                    i++</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reusableChild[<span class="number">0</span>]) &#123;</div><div class="line">                    element.insertBefore(reusableChild[<span class="number">0</span>], oldElement)</div><div class="line">                    patch(element, reusableChild[<span class="number">0</span>], reusableChild[<span class="number">1</span>], newChild)</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    patch(element, oldElement, <span class="literal">null</span>, newChild)</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                j++</div><div class="line">                newKeys[newKey] = newChild</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 根据key复用旧节点</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (i &lt; oldLen) &#123;</div><div class="line">            <span class="keyword">var</span> oldChild = oldNode.children[i]</div><div class="line">            <span class="keyword">var</span> oldKey = getKeyFrom(oldChild)</div><div class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == oldKey) &#123;</div><div class="line">                removeElement(element, oldElements[i], oldChild)</div><div class="line">            &#125;</div><div class="line">            i++</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 移除没有key的旧节点</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> reusableChildren) &#123;</div><div class="line">            <span class="keyword">var</span> reusableChild = reusableChildren[i]</div><div class="line">            <span class="keyword">var</span> reusableNode = reusableChild[<span class="number">1</span>]</div><div class="line">            <span class="keyword">if</span> (!newKeys[reusableNode.data.key]) &#123;</div><div class="line">                removeElement(element, reusableChild[<span class="number">0</span>], reusableNode)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 根据新的key过滤掉无用的节点</span></div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node !== oldNode) &#123;</div><div class="line">        <span class="keyword">var</span> i = element</div><div class="line">        parent.replaceChild((element = createElementFrom(node)), i)</div><div class="line">        <span class="comment">// 如果标签名变了就创建新节点替换当前节点，replaceChild是dom的api</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> element</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>嗯，根据key更换节点的逻辑我也看得比较模糊，坑先挖下，后续再填吧。总的来说 picodom 非常适合用来做研究，从中可以大概了解到virtual dom 和 patch 的基本原理，至于实用性的话……拿来做jsx解析的模板语言没准儿能行吧……</p>
<p>好的那么由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话说，对于Virtual DOM解析的文章不少。但是，要不就是浅尝辄止，说到把dom解析成树型数据结构就结束了，不讲补丁算法，要不就是补丁算法说的太深奥完全理解不了。今天发现个好货，&lt;a href=&quot;https://github.com/picodom/&quot;&gt;Picodom&lt;/a&gt;，这个库用了200多行代码就把 virtual dom 和 patch 算法实现了，这下好了，有了实际代码理论也好理解，废话少说，快来一起读代码吧~&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="virtual dom" scheme="http://brooch.me/tags/virtual-dom/"/>
    
      <category term="picodom" scheme="http://brooch.me/tags/picodom/"/>
    
  </entry>
  
  <entry>
    <title>新版Create React App里的新鲜玩意儿</title>
    <link href="http://brooch.me/2017/06/02/whats-new-in-create-react-app/"/>
    <id>http://brooch.me/2017/06/02/whats-new-in-create-react-app/</id>
    <published>2017-06-02T09:19:43.000Z</published>
    <updated>2017-06-02T12:47:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>话说玩儿react的同学可能都知道<a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">Create React App</a>这个项目吧（不知道的戳<a href="http://www.jianshu.com/p/dd4cee273bed" target="_blank" rel="external">这里</a>了解，这是来自Facebook官方的零配置命令行工具，能够帮你自动创建基于Webpack的最简易的React项目模板）。话说今天看期刊的时候发现了一篇react的官方blog更新了一篇叫<a href="https://facebook.github.io/react/blog/2017/05/18/whats-new-in-create-react-app.html" target="_blank" rel="external">What’s New in Create React App</a>的博客，随手翻了下发现 Create React App 这个项目居然也更新新版本了？！而且还添加进来很多有趣的功能。我半翻译半解读一下这篇文章，咱们看看有哪些有趣的新功能吧。</p>
<a id="more"></a>
<p>Create React App 这个项目推出大概有一年了，作为一个官方推荐的快速搭建react项目的脚手架，这个项目吸引了大量的开发者。而这个项目在沉寂了几个月之后，于5月18号发布了1.0.0版本（最近这十四天有release了七次，真是猛啊……），添加了好多新的特性。如果你当前正在开发的应用是使用 Create React App 创建的，想体验新版本的特性，并且你的项目并没有执行弹出操作（Create React App 有个 eject命令），可以参考官方的<a href="https://github.com/facebookincubator/create-react-app/releases/tag/v1.0.0" target="_blank" rel="external">升级说明</a>来升级 Create React App。</p>
<h2 id="webpack-2"><a href="#webpack-2" class="headerlink" title="webpack 2"></a>webpack 2</h2><p>虽然 webpack 2 相比 webpack 的改动很大，有可能存在很多问题，但是 webpack 2 已经正式发布几个月了，Create React App 团队经过了一段时间的测试，认为目前 webpack 2 已经足够稳定了，所以将模板中的构建工具也修改为 webpack 2。而且 Create React App 的用户并不需要担心 webpack 2 配置上的改动，Create React App 内部对 webpack 的配置进行了兼容。</p>
<p>如果你的项目已经执行过弹出操作了，则需要参考 webpack 提过的<a href="https://webpack.js.org/guides/migrating/" target="_blank" rel="external">升级指南</a>自己手动修改配置。</p>
<p>webpack 2 最引人注目的新特性就是其对 <a href="http://2ality.com/2014/09/es6-modules-final.html" target="_blank" rel="external">ES6 模块</a> 的支持，可以将将 ES6 模块 直接转化为 CommonJS 模块。虽然这对开发来说可能没啥影响，但是它可以在编译阶段捕获更多的错误，比如exports 的变量undefined之类的：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-01.gif" alt="whats-new-in-create-react-app-01"></p>
<p>webpack 2 还提供了 <a href="http://www.css88.com/archives/6946" target="_blank" rel="external">tree shaking</a> 特性，可以通过去除冗余代码，优化打包后脚本的尺寸。</p>
<h2 id="Runtime-Error-Overlay"><a href="#Runtime-Error-Overlay" class="headerlink" title="Runtime Error Overlay"></a>Runtime Error Overlay</h2><p>你有没有这种经历，代码中写错了一个地方，控制台里也报错了，但是死活找不到报错代码的位置……</p>
<p>为了解决这个问题，我们引入了一个专门捕获错误的弹窗，当程序报错的时候他会展示报错信息和引发错误的位置！当然，他只会出现在开发阶段，产出代码的时候会被去掉。</p>
<p>有图，有真相，就在这儿晒！</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-02.gif" alt="whats-new-in-create-react-app-02"></p>
<p>更牛逼的是，他还能跟你的编辑器结合到一起，惊不惊喜？意不意外？</p>
<p>未来 Creat React App 还准备支持更多错误捕获。比如在React 16 版本发布之后，Creat React App 计划支持 React 组件调用栈的展示。</p>
<h1 id="默认支持渐进式web应用"><a href="#默认支持渐进式web应用" class="headerlink" title="默认支持渐进式web应用"></a>默认支持渐进式web应用</h1><p>使用新版本 Creat React App 创建的项目默认就会支持 [渐进式web应用(PWA)] (<a href="https://developers.google.com/web/progressive-web-apps/)，会使用" target="_blank" rel="external">https://developers.google.com/web/progressive-web-apps/)，会使用</a> <a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers" target="_blank" rel="external">service workers</a> 实现 <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network" target="_blank" rel="external">缓存优先策略</a> 来优化用户再次访问应用的速度。当然，你也可以通过设置默认不开启这个特性，但是如果你在开发新的应用，我推荐你使用它，特别是在移动设备上运行的应用，会有惊喜哦~</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-03.png" alt="whats-new-in-create-react-app-03"></p>
<p>关于 Creat React App 中 PWA 的配置，更详细的说明请戳<a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#making-a-progressive-web-app" target="_blank" rel="external">这里</a>。</p>
<p>题外话，貌似最近 PWA 很火呢，前段时间看到 vue 官方也退出了基于自己框架的<a href="https://github.com/vuejs-templates/pwa" target="_blank" rel="external">pwa脚手架</a>，另外我还发现一个在线的 PWA 脚手架工具，有兴趣的可以玩儿玩儿，<a href="http://www.pwabuilder.com/" target="_blank" rel="external">www.pwabuilder.com</a>，回头有时间我也打算写一篇关于 PWA 的文章~</p>
<h2 id="Jest-20"><a href="#Jest-20" class="headerlink" title="Jest 20"></a>Jest 20</h2><p>先科普一下，<a href="http://facebook.github.io/jest/" target="_blank" rel="external">Jest</a> 是facebook出的一个自动化测试工具，用来跑单测的。</p>
<p>新版的 Creat React App 使用的也是新版的 Jest，20版本的 Jest 包含了许多改进，具体有哪些修改自己看<a href="http://facebook.github.io/jest/blog/2017/05/06/jest-20-delightful-testing-multi-project-runner.html" target="_blank" rel="external">文档</a>吧。</p>
<p>现在 Create React App 只需要做少量 Jest 的配置就可以生成覆盖率报告了。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-04.gif" alt="whats-new-in-create-react-app-04"></p>
<h2 id="动态import-代码分割"><a href="#动态import-代码分割" class="headerlink" title="动态import()代码分割"></a>动态import()代码分割</h2><p>保持应用初始化最小下载量和按需加载的重要性我就不说了哈，其实上个版本的 Create React App 也支持代码分割，不过是基于 webpack 的 require.ensure() 特性，这使得这部分代码没法通过 Jest 的测试。</p>
<p>在这个版本的 Create React App 中，我们加入了对未来web标准中 <a href="http://2ality.com/2017/01/import-operator.html#loading-code-on-demand" target="_blank" rel="external">动态 import()</a> 提案的支持，我建议你使用 import() 来延迟加载非常用组件。巧的是，上期的文章里也涉及到了这个问题，咱们来看看 Create React App 中的解决方案吧：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-05.gif" alt="whats-new-in-create-react-app-05"></p>
<h2 id="更好的控制台输出"><a href="#更好的控制台输出" class="headerlink" title="更好的控制台输出"></a>更好的控制台输出</h2><p>新版的 Create React App 改善了控制台的输出。举个例子，当你启动测试服务时，新版的 Create React App 除了会显示本地地址之外，还会显示局域网ip地址，这样你就能更快的用你的手机测试应用了，总之就是更注重细节了吧……╮(￣▽￣)╭</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/whats-new-in-create-react-app-06.png" alt="whats-new-in-create-react-app-06"></p>
<h2 id="更多的特性"><a href="#更多的特性" class="headerlink" title="更多的特性"></a>更多的特性</h2><p>上面描述的其实只是新特性中的一小部分，这个版本中还包含了更多的特性，有兴趣的可以看看这个版本的 <a href="https://github.com/facebookincubator/create-react-app/releases/tag/v1.0.0" target="_blank" rel="external">changelog</a></p>
<p>好的那么由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话说玩儿react的同学可能都知道&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;这个项目吧（不知道的戳&lt;a href=&quot;http://www.jianshu.com/p/dd4cee273bed&quot;&gt;这里&lt;/a&gt;了解，这是来自Facebook官方的零配置命令行工具，能够帮你自动创建基于Webpack的最简易的React项目模板）。话说今天看期刊的时候发现了一篇react的官方blog更新了一篇叫&lt;a href=&quot;https://facebook.github.io/react/blog/2017/05/18/whats-new-in-create-react-app.html&quot;&gt;What’s New in Create React App&lt;/a&gt;的博客，随手翻了下发现 Create React App 这个项目居然也更新新版本了？！而且还添加进来很多有趣的功能。我半翻译半解读一下这篇文章，咱们看看有哪些有趣的新功能吧。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>闲扯react组件动态加载机制 -- webpack打包方案</title>
    <link href="http://brooch.me/2017/05/26/react-component-dynamic-loading-2/"/>
    <id>http://brooch.me/2017/05/26/react-component-dynamic-loading-2/</id>
    <published>2017-05-26T06:42:00.000Z</published>
    <updated>2017-05-26T15:22:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次写的文章被朋友吐槽看不懂了……好吧，这次我们继续说说动态加载组件的打包方案，就算是狗尾续狗，他自己挖的坑填平吧。</p>
<a id="more"></a>
<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>先总结下上次的文章，其实我上次写的那些，归结起来就是一点：</p>
<p>在用react开发应用时，如果想要动态加载子组件，只需要在componentDidMount或者componentWillReceiveProps中加入异步获取组件的逻辑就可以实现了。再进一次，可以把这个功能单独抽成一个专门做加载的组件。</p>
<h2 id="webpack打包"><a href="#webpack打包" class="headerlink" title="webpack打包"></a>webpack打包</h2><p>上篇文章的最后我也说了，之前实现的只是代码逻辑，要想真正用到生产环境，还得过构建打包那一关……说到打包，虽然市面上打包工具不少，不过基本上现在都是用webpack了吧。</p>
<p>根据之前的预测，直接使用System.import()来替换里面的require就可以实现功能了。需要注意的是，根据webpack文档中的描述<a href="https://doc.webpack-china.org/guides/code-splitting-async/#-import-" target="_blank" rel="external">动态引入：import()</a>，import不能支持完全的动态语句，至少要给他一个范围。所以需要将原来使用变量的语句改为一个拼接的路径，类似下面这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "loader" */</span> <span class="string">`./<span class="subst">$&#123;componentName&#125;</span>`</span>)</div><div class="line">    .then(<span class="function"><span class="params">Component</span> =&gt;</span> &#123;</div><div class="line">        \\...</div><div class="line">    &#125;)</div><div class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">        \\...</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>这样webpack在打包时，会将这个路径下所有的文件都作为可能被异步加载chunk来打包。所以最好在目录上做规范，将需要异步加载的组件放到一个特定的目录下，避免打包的时候生成冗余文件。</p>
<h2 id="随之而来的问题"><a href="#随之而来的问题" class="headerlink" title="随之而来的问题"></a>随之而来的问题</h2><p>虽然打包的问题解决了，但是随之也暴露了问题。由于webpack打包是基于入口的，不同入口之间是独立的，而用import拆分出来的chunk是无入口的，所以webpack认为他们之间并没有联系，也就不会提取他们之间的公共内容。</p>
<p>比如我写的demo，具体的引用关系如下图</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/react-component-dynamic-loading-01.jpg" alt="01"></p>
<p>最后打包出来的动态加载的组件例会很多重复的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">chunk &#123;0&#125; page2.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/Page.css</div><div class="line">    css-loader/lib/css-base.js</div><div class="line">    style-loader/lib/addStyles.js</div><div class="line">    style-loader/lib/urls.js</div><div class="line">    containers/LoadComponent.js</div><div class="line">    pages/PageB.js</div><div class="line">    styles/Page.css</div><div class="line"></div><div class="line">chunk &#123;1&#125; page0.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/Page.css</div><div class="line">    css-loader/lib/css-base.js</div><div class="line">    style-loader/lib/addStyles.js</div><div class="line">    style-loader/lib/urls.js</div><div class="line">    containers/LoadComponent.js</div><div class="line">    pages/PageA.js</div><div class="line">    styles/Page.css</div><div class="line">    </div><div class="line">chunk &#123;2&#125; component4.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleB.css</div><div class="line">    components/ComponentC.js</div><div class="line">    lib/BaseComponent.js</div><div class="line">    styles/StyleB.css</div><div class="line"></div><div class="line">chunk &#123;3&#125; component2.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleA.css</div><div class="line">    components/ComponentB.js</div><div class="line">    lib/BaseComponent.js</div><div class="line">    styles/StyleA.css</div><div class="line">    </div><div class="line">chunk &#123;4&#125; component0.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleA.css</div><div class="line">    components/ComponentA.js</div><div class="line">    lib/BaseComponent.js</div><div class="line">    styles/StyleA.css</div><div class="line"></div><div class="line">chunk &#123;5&#125; index.entry.js</div><div class="line">    react-dom/index.js</div><div class="line">    react-hot-loader/patch.js</div><div class="line">    react/react.js</div><div class="line">    strip-ansi/index.js</div><div class="line">    url/url.js</div><div class="line">    containers/App.js</div><div class="line">    index.js</div><div class="line">    stores/dataStore.js</div></pre></td></tr></table></figure>
<p>这个时候就得用CommonsChunkPlugin来优化打包结果了。需要注意的是，由于page和comonpent都是异步加载的，没有入口，所以配置CommonsChunkPlugin的时候需要指定引用了异步加载chunk的入口，并加上<code>children:true</code>。另外异步加载chunk里面如果还有有异步加载的chunk需要优化，则需要把父级的chunk也设为入口，再用CommonsChunkPlugin优化。配置类似这样如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    entry: &#123;</div><div class="line">        <span class="attr">index</span>: <span class="string">'./index'</span>,</div><div class="line">        <span class="attr">pageA</span>: <span class="string">'./pages/PageA'</span>,</div><div class="line">        <span class="attr">pageB</span>: <span class="string">'./pages/PageB'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//...</span></div><div class="line">    plugins: [</div><div class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">'index'</span>,</div><div class="line">            <span class="attr">children</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">async</span>: <span class="literal">true</span></div><div class="line">        &#125;),</div><div class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">            <span class="attr">names</span>: [<span class="string">'pageA'</span>, <span class="string">'pageB'</span>],</div><div class="line">            <span class="attr">children</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">async</span>: <span class="literal">true</span></div><div class="line">        &#125;),</div><div class="line">    ]</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加上<code>async: true</code>的配置之后，生成的公共chunk也会用异步的方式加载进来，这样就能完全的实现动态加载了~</p>
<p>最后打包出来的文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">chunk &#123;0&#125; component4.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleB.css</div><div class="line">    components/ComponentC.js</div><div class="line">    styles/StyleB.css</div><div class="line"></div><div class="line">chunk &#123;1&#125; component2.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleA.css</div><div class="line">    components/ComponentB.js</div><div class="line">    styles/StyleA.css</div><div class="line"></div><div class="line">chunk &#123;2&#125; component0.bundle.js</div><div class="line">    css-loader/index.js?modules!./styles/StyleA.css</div><div class="line">    components/ComponentA.js</div><div class="line">    styles/StyleA.css</div><div class="line"></div><div class="line">chunk &#123;3&#125; 3.bundle .js</div><div class="line">    lib/BaseComponent.js</div><div class="line"></div><div class="line">chunk &#123;4&#125; 4.bundle .js</div><div class="line">    css-loader/index.js?modules!./styles/Page.css</div><div class="line">    css-loader/lib/css-base.js</div><div class="line">    style-loader/lib/addStyles.js</div><div class="line">    style-loader/lib/urls.js</div><div class="line">    components lazy recursive ^\.\/.*$</div><div class="line">    containers/LoadComponent.js</div><div class="line">    styles/Page.css</div><div class="line"></div><div class="line">chunk &#123;5&#125; page2.bundle.js</div><div class="line">    pages/PageB.js</div><div class="line"></div><div class="line">chunk &#123;6&#125; page0.bundle.js</div><div class="line">    pages/PageA.js</div><div class="line"></div><div class="line">chunk &#123;7&#125; index.entry.js</div><div class="line">    mobx-react/index.js</div><div class="line">    react-hot-loader/patch.js</div><div class="line">    react/react.js</div><div class="line">    strip-ansi/index.js</div><div class="line">    url/url.js</div><div class="line">    containers/App.js</div><div class="line">    index.js</div><div class="line">    stores/dataStore.js</div><div class="line"></div><div class="line">chunk &#123;8&#125; pageB.entry.js</div><div class="line">    mobx-react/index.js</div><div class="line">    react-dom/index.js</div><div class="line">    react/react.js</div><div class="line">    strip-ansi/index.js</div><div class="line">    url/url.js</div><div class="line">    containers/LoadComponent.js</div><div class="line">    pages/PageB.js</div><div class="line">    styles/Page.css</div><div class="line"></div><div class="line">chunk &#123;9&#125; pageA.entry.js</div><div class="line">    mobx-react/index.js</div><div class="line">    react-dom/index.js</div><div class="line">    react/react.js</div><div class="line">    strip-ansi/index.js</div><div class="line">    url/url.js</div><div class="line">    containers/LoadComponent.js</div><div class="line">    pages/PageA.js</div><div class="line">    styles/Page.css</div></pre></td></tr></table></figure>
<p>可以看到3号chunk是component的公共模块，4号chunk是page的公共模块，8号chunk和9号chunk是设置了入口后生成的冗余文件。</p>
<p>可能有人注意到component的里引用的css文件并没有提取出来，这是因为并不是所有的component chunk都引用了它造成的。如果想要把他也提出来，设置一下CommonsChunkPlugin的minChunks属性就行了。</p>
<p>具体的在项目中使用的时候，需要根据业务手动去调整入口配置和CommonsChunkPlugin里的参数了，要想做到完全自动化，CommonsChunkPlugin是支持不了，需要开发新的webpack插件才行。至于怎么开发webpack插件，这个不在本次文章的范畴里，以后有时间了在专门开新坑说明吧。</p>
<p>最后附上我自己做的<a href="https://github.com/81735595/react-component-dynamic-loading/tree/master/webpack" target="_blank" rel="external">demo</a>，clone下来之后 npm install &amp;&amp; npm start 就能跑起来了。这次算是有示例有真相了吧？就在这儿晒~(￣▽￣)~*</p>
<p>好的那么由于时间不足，本期的博客就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次写的文章被朋友吐槽看不懂了……好吧，这次我们继续说说动态加载组件的打包方案，就算是狗尾续狗，他自己挖的坑填平吧。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
      <category term="webpack" scheme="http://brooch.me/tags/webpack/"/>
    
      <category term="dynamic load" scheme="http://brooch.me/tags/dynamic-load/"/>
    
      <category term="CommonsChunkPlugin" scheme="http://brooch.me/tags/CommonsChunkPlugin/"/>
    
  </entry>
  
  <entry>
    <title>闲扯react组件动态加载机制</title>
    <link href="http://brooch.me/2017/05/19/react-component-dynamic-loading-1/"/>
    <id>http://brooch.me/2017/05/19/react-component-dynamic-loading-1/</id>
    <published>2017-05-19T08:33:12.000Z</published>
    <updated>2017-05-26T06:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>话说之前老写vue的源码有点乏味，今天咱们扯点儿别的。之前在微信群里看到大家聊起react组件动态加载，貌似都没有什么好的解决方案呢，正好最近一直忙着写java，好久没折腾react的代码了，借这个机会捡捡以前的技能，不然都要忘光了……</p>
<a id="more"></a>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>之前在群里聊的时候也没看到有人说起核心的痛点，所以究竟在实际应用中会有啥问题我也不知道 (;￢＿￢) ……所以关于问题的分析，其实都是我脑补出来的，所以大家不要当真，全当看热闹吧……</p>
<p>分析之前，先确定下目标，我的目标是简单实现react组件动态加载的机制。既然是要先串通机制，细节和环境配置就一切从简，后续再考虑实际使用和易用性。</p>
<p>接下来分析问题，说到react组件动态加载，从字面上看可以分为两部分“react组件”和“动态加载”。动态加载其实老早就有就解决方案了，之前打包工具还没流行起来的时候，就有各种五花八门的库来解这问题，requirejs、seajs、YUI Loader啥的，所以这个问题用第三方库应该就能搞定。</p>
<p>然后，跟react组件联系到一起，如何在加载完成后替换组件是个问题。其实这个问题也好解，因为react的组件可以返回新组件，所以做个透传参数的加载器应该就可以了。</p>
<p>另外，现在想开发react的程序，webpack+es6+jsx也算是标配了吧。如何用webpack配合打包也是个问题，要把需要异步加载的都生成chunk。还得搭建一套构建环境……毕竟我的目标是实现机制，所以打包这部分就先不考虑，环境配置也省略，直接写浏览器可执行的脚本。</p>
<p>好的，拉个list：</p>
<ul>
<li>动态加载问题 – 使用requirejs</li>
<li>react组件替换 – 做个加载器组件</li>
<li>webpack打包 – 后续考虑</li>
<li>环境问题 – 先不使用jsx，不写浏览器不能直接运行的代码，公共库用unpkg加载，使用creat-react-class模块创建react组件构造函数</li>
</ul>
<p>ok，可以开始了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>之前列出的四个问题，真正需要解决的只有第二个，所以设计一个加载器组件，其实就能实现react组件动态加载的机制了吧……</p>
<p>调用形式应该像下面这样，在标签上指定要加载的组件名，另外，被调用的组件也会需要设置属性，所以加载器也得接收。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">React.createElement(Loader, &#123;</div><div class="line">    <span class="attr">component</span>: <span class="string">'A'</span>,</div><div class="line">    <span class="attr">propA</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">propB</span>: <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 用jsx写应该是下面这样的</span></div><div class="line">&lt;Loader component=<span class="string">'A'</span> propA=&#123;<span class="number">1</span>&#125; propB=&#123;<span class="literal">true</span>&#125;/&gt;</div></pre></td></tr></table></figure>
<p>Loader内部，首先要有个地方记录已经加载了的组件，如果组件已经加载，就直接调用，如果没加载，就先显示loading并开始加载组件，加载完成后调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把记录已加载组件的变量设为公共变量，为了能在多个实例之间共享</span></div><div class="line"><span class="keyword">var</span> componentList = &#123;&#125;</div><div class="line">createReactClass(&#123;</div><div class="line">    <span class="attr">displayName</span>:<span class="string">'Loader'</span>,</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> component = <span class="keyword">this</span>.props.component</div><div class="line">        <span class="keyword">if</span> (componentList[component]) &#123;</div><div class="line">            <span class="keyword">return</span> React.createElement(componentList[component], <span class="keyword">this</span>.props);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            getComponent(component)</div><div class="line">            <span class="keyword">return</span> React.createElement(div, <span class="literal">null</span>, <span class="string">'loading……'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 用es6写应该是这样的，没错，我就是想证明我会写但是我懒…… (￣.￣)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loader</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props) &#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">    &#125;</div><div class="line">    render () &#123;</div><div class="line">        <span class="keyword">let</span> component = &#123;<span class="keyword">this</span>.props&#125;</div><div class="line">        <span class="keyword">if</span> (componentList[component]) &#123;</div><div class="line">            <span class="keyword">return</span> &lt;componentList[component] &#123;...this.props&#125;/&gt;;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 这个函数里面加载组件</div><div class="line">            getComponent(component)</div><div class="line">            return &lt;div&gt;loading……&lt;/div&gt;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大框架有了，继续细化。虽然上面写了加载组件的函数，但是在加载组件之后需要重新触发加载器的渲染，这就需要设置组件的state，所以必须要给加载器添加state属性，用来标记当前显示的组件，并且在getComponent对state进行设置，创建组件的地方也应该改成用state的属性创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">createReactClass(&#123;</div><div class="line">    <span class="attr">displayName</span>:<span class="string">'Loader'</span>,</div><div class="line">    <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">cur</span>: <span class="string">''</span></div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getComponent</span>: <span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</div><div class="line">        <span class="built_in">require</span>([component], (Component) =&gt; &#123;</div><div class="line">            componentList[component] = Component</div><div class="line">            <span class="keyword">this</span>.setState(&#123;</div><div class="line">                <span class="attr">cur</span>: Component</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> component = <span class="keyword">this</span>.props.component</div><div class="line">        <span class="keyword">if</span> (componentList[component]) &#123;</div><div class="line">            <span class="keyword">return</span> React.createElement(<span class="keyword">this</span>.state.cur, <span class="keyword">this</span>.props);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.getComponent(component)</div><div class="line">            <span class="keyword">return</span> React.createElement(div, <span class="literal">null</span>, <span class="string">'loading……'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>接着问题就来了，react里setState会触发render，而上面render里getComponent又会触发setState，会造成死循环，所以要给他换个地方，react的组件运行时一共四个，constructor、componentWillMount、render、componentDidMount，render不能写，文档上说componentWillMount对于web runtime没屌用，所以只能在constructor和componentDidMount里面选了，其实放到哪个里都行，但是constructor是用来初始化组件的，从含以上看，我觉得放componentDidMount里比较合适，官方文档上也说componentDidMount是用来加载异步数据的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">createReactClass(&#123;</div><div class="line">    <span class="attr">displayName</span>:<span class="string">'Loader'</span>,</div><div class="line">    <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">cur</span>: <span class="string">''</span></div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getComponent</span>: <span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</div><div class="line">        <span class="built_in">require</span>([component], (Component) =&gt; &#123;</div><div class="line">            componentList[component] = Component</div><div class="line">            <span class="keyword">this</span>.setState(&#123;</div><div class="line">                <span class="attr">cur</span>: Component</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">componentDidMount</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.getComponent(<span class="keyword">this</span>.props.component)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (componentList[<span class="keyword">this</span>.props.component]) &#123;</div><div class="line">            <span class="keyword">return</span> React.createElement(<span class="keyword">this</span>.state.cur, <span class="keyword">this</span>.props);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> React.createElement(div, <span class="literal">null</span>, <span class="string">'loading……'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>呃……貌似这样就行了呢……至少大体的机制应该就是这样的吧，还有些细节需要完善，比如props变化的时候也切加载控间，现在这个加载器只能加载一次控件，其实只要在属性变化的运行时里加上getComponent函数就行了。再比如减少控件渲染次数，控价加载失败的异常处理之类的，详细的就不说了，自己体会吧，我把我练习的代码传到github上了，可以看看吐吐槽</p>
<p><a href="https://github.com/81735595/react-component-dynamic-loading" target="_blank" rel="external">https://github.com/81735595/react-component-dynamic-loading</a></p>
<p>用npm start就能启动了。</p>
<h2 id="关于打包"><a href="#关于打包" class="headerlink" title="关于打包"></a>关于打包</h2><p>感觉在代码上直接用import替换require就能用webpack2打包了，但是我总觉得打包是个大头儿，有好多坑等着……所以等以后有时间了再补一次打包脚本联系好了。</p>
<p>好的那么由于时间不足，本期的流水账就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的热情了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话说之前老写vue的源码有点乏味，今天咱们扯点儿别的。之前在微信群里看到大家聊起react组件动态加载，貌似都没有什么好的解决方案呢，正好最近一直忙着写java，好久没折腾react的代码了，借这个机会捡捡以前的技能，不然都要忘光了……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(5)</title>
    <link href="http://brooch.me/2017/05/05/vue-source-notes-5/"/>
    <id>http://brooch.me/2017/05/05/vue-source-notes-5/</id>
    <published>2017-05-05T12:00:29.000Z</published>
    <updated>2017-05-05T13:45:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>五一好好给自己放了个假，去成都玩儿了几天。话说成都的生活可真是悠闲，搞得我都向去成都买房定居了~而且成都的吃的可真是，（¯﹃¯）…… 一想到猪肉锅盔和冒节子肥肠粉我口水就开始往外涌……咳咳……言归正传，上次说这次要读core的全部全局api和config，下面咱们就开始。</p>
<h2 id="use-js"><a href="#use-js" class="headerlink" title="use.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/use.js" target="_blank" rel="external">use.js</a></h2><p>这个文件是用来给构造函数Vue挂载use方法用的，逻辑很简单。use方法是用来安装插件用的，<a href="https://cn.vuejs.org/v2/api/?#Vue-use" target="_blank" rel="external">对应文档</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: Function | Object</span>) </span>&#123;</div><div class="line">    <span class="comment">// 安装过的控件不再安装</span></div><div class="line">    <span class="comment">/* istanbul ignore if */</span></div><div class="line">    <span class="keyword">if</span> (plugin.installed) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 组织要传给控件的参数，Vue构造函数作为第一个参数</span></div><div class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line">    args.unshift(<span class="keyword">this</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 根据plugin的类型使用不同调用方法，文档中只介绍了使用install属性来启动插件的方法，</span></div><div class="line">    <span class="comment">// 如果plugin本身就是个函数，则使用这个函数来安装插件</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">'function'</span>) &#123;</div><div class="line">      plugin.install.apply(plugin, args)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) &#123;</div><div class="line">      plugin.apply(<span class="literal">null</span>, args)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 给安装过的控件加锁</span></div><div class="line">    plugin.installed = <span class="literal">true</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="mixin-js"><a href="#mixin-js" class="headerlink" title="mixin.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/mixin.js" target="_blank" rel="external">mixin.js</a></h2><p>mixin的逻辑主要隐藏在mergeOptions函数里，之前咱么你说过，这个函数是组件实例化和继承的核心方法，其实就是根据不同的属性进行合并，有规定的属性按照规定的规则，没规定的属性直接覆盖。等到读到 src/core/util/options.js 时再详细解读 mergeOptions 函数。<a href="https://cn.vuejs.org/v2/api/?#Vue-mixin" target="_blank" rel="external">对应文档</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mergeOptions &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  <span class="comment">// 挂载mixin方法</span></div><div class="line">  Vue.mixin = <span class="function"><span class="keyword">function</span> (<span class="params">mixin: Object</span>) </span>&#123;</div><div class="line">    <span class="comment">// 使用 mergeOptions 函数合并 Vue.options</span></div><div class="line">    <span class="keyword">this</span>.options = mergeOptions(<span class="keyword">this</span>.options, mixin)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="extend-js"><a href="#extend-js" class="headerlink" title="extend.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/.js" target="_blank" rel="external">extend.js</a></h2><p>extend本身是用来创建子类的，内部使用mergeOptions来合并属性。<a href="https://cn.vuejs.org/v2/api/?#Vue-extend" target="_blank" rel="external">对应文档</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; warn, extend, mergeOptions &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"><span class="keyword">import</span> &#123; defineComputed, proxy &#125; <span class="keyword">from</span> <span class="string">'../instance/state'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initExtend</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 初始化Vue的cid，用来做Vue构造函数和其子类的缓存的索引，每个Vue构造函数的子类也都有cid</div><div class="line">   */</div><div class="line">  Vue.cid = <span class="number">0</span></div><div class="line">  <span class="keyword">let</span> cid = <span class="number">1</span></div><div class="line"></div><div class="line">  <span class="comment">// 挂载extend方法</span></div><div class="line">  Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: Object</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">    <span class="comment">// 子类的options的容错处理</span></div><div class="line">    extendOptions = extendOptions || &#123;&#125;</div><div class="line">    <span class="keyword">const</span> Super = <span class="keyword">this</span></div><div class="line">    <span class="keyword">const</span> SuperId = Super.cid</div><div class="line">    <span class="comment">// 取缓存，缓存是绑在options对象上的，就是说同样的父类、同样的配置，就会走缓存生成相同的子类。</span></div><div class="line">    <span class="keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</div><div class="line">    <span class="keyword">if</span> (cachedCtors[SuperId]) &#123;</div><div class="line">      <span class="keyword">return</span> cachedCtors[SuperId]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> name = extendOptions.name || Super.options.name</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (!<span class="regexp">/^[a-zA-Z][\w-]*$/</span>.test(name)) &#123;</div><div class="line">        warn(</div><div class="line">          <span class="string">'Invalid component name: "'</span> + name + <span class="string">'". Component names '</span> +</div><div class="line">          <span class="string">'can only contain alphanumeric characters and the hyphen, '</span> +</div><div class="line">          <span class="string">'and must start with a letter.'</span></div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 定义子类的构造函数</span></div><div class="line">    <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">      <span class="comment">// 后面会将父类的prototype接到子类的上，就可以调用Vue的_init方法了</span></div><div class="line">      <span class="keyword">this</span>._init(options)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 实现类的继承</span></div><div class="line">    Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</div><div class="line">    Sub.prototype.constructor = Sub</div><div class="line">    Sub.cid = cid++</div><div class="line">    Sub.options = mergeOptions(</div><div class="line">      Super.options,</div><div class="line">      extendOptions</div><div class="line">    )</div><div class="line">    Sub[<span class="string">'super'</span>] = Super</div><div class="line"></div><div class="line">    <span class="comment">// 初始化子类的props属性，这里使用了一个函数来封装遍历的过程</span></div><div class="line">    <span class="comment">// initProps里对options.props的每个属都进行了初始化</span></div><div class="line">    <span class="keyword">if</span> (Sub.options.props) &#123;</div><div class="line">      initProps(Sub)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 与initProps类似</span></div><div class="line">    <span class="keyword">if</span> (Sub.options.computed) &#123;</div><div class="line">      initComputed(Sub)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 让子类也能使用extend、mixin、use方法</span></div><div class="line">    Sub.extend = Super.extend</div><div class="line">    Sub.mixin = Super.mixin</div><div class="line">    Sub.use = Super.use</div><div class="line"></div><div class="line">    <span class="comment">// config._assetTypes里面是所有的控件类型，这些也都复制到子类上</span></div><div class="line">    config._assetTypes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">      Sub[type] = Super[type]</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// 允许递归查找自己</span></div><div class="line">    <span class="keyword">if</span> (name) &#123;</div><div class="line">      Sub.options.components[name] = Sub</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 保存对super和自己当前的options的引用，实例化的时候用于检查options是否更新了</span></div><div class="line">    Sub.superOptions = Super.options</div><div class="line">    Sub.extendOptions = extendOptions</div><div class="line">    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</div><div class="line"></div><div class="line">    <span class="comment">// 添加缓存</span></div><div class="line">    cachedCtors[SuperId] = Sub</div><div class="line">    <span class="keyword">return</span> Sub</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// initProps 和 initComputed 的操作类似，通过代理调用Object.defineProperty</span></div><div class="line"><span class="comment">// 简单看了下代理的逻辑，感觉并没有减少Object.defineProperty的调用次数</span></div><div class="line"><span class="comment">// 只是使用一个固定的对象来减少生成对象的数量</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">Comp</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> props = Comp.options.props</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</div><div class="line">    proxy(Comp.prototype, <span class="string">`_props`</span>, key)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">Comp</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> computed = Comp.options.computed</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</div><div class="line">    defineComputed(Comp.prototype, key, computed[key])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="assets-js"><a href="#assets-js" class="headerlink" title="assets.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/assets.js" target="_blank" rel="external">assets.js</a></h2><p>asset貌似应该翻译为资源，这个文件主要是用来初始化Vue的资源的，所谓的资源就是类似directive、filter、component之类的控件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; warn, isPlainObject &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initAssetRegisters</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  </div><div class="line">  <span class="comment">// 注册Vue默认支持的资源，就是注册了 Vue.directive、Vue.component、Vue.filter方法</span></div><div class="line">  config._assetTypes.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</div><div class="line">    Vue[type] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line">      id: string,</div><div class="line">      definition: Function | Object</div><div class="line">    ): <span class="title">Function</span> | <span class="title">Object</span> | <span class="title">void</span> &#123;</div><div class="line">      <span class="keyword">if</span> (!definition) &#123;</div><div class="line">        <span class="comment">// 获取资源</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.options[type + <span class="string">'s'</span>][id]</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 注册资源</span></div><div class="line">        <span class="comment">/* istanbul ignore if */</span></div><div class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">          <span class="keyword">if</span> (type === <span class="string">'component'</span> &amp;&amp; config.isReservedTag(id)) &#123;</div><div class="line">            warn(</div><div class="line">              <span class="string">'Do not use built-in or reserved HTML elements as component '</span> +</div><div class="line">              <span class="string">'id: '</span> + id</div><div class="line">            )</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 对不同资源进行不同处理</span></div><div class="line">        <span class="keyword">if</span> (type === <span class="string">'component'</span> &amp;&amp; isPlainObject(definition)) &#123;</div><div class="line">          definition.name = definition.name || id</div><div class="line">          definition = <span class="keyword">this</span>.options._base.extend(definition)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (type === <span class="string">'directive'</span> &amp;&amp; <span class="keyword">typeof</span> definition === <span class="string">'function'</span>) &#123;</div><div class="line">          definition = &#123; <span class="attr">bind</span>: definition, <span class="attr">update</span>: definition &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.options[type + <span class="string">'s'</span>][id] = definition</div><div class="line">        <span class="keyword">return</span> definition</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>全局api这部分就算是看完了，总的来说这部分逻辑都不复杂，主要学习的还是机制吧，插件的机制，继承的机制，资源注册获取的机制，基本上算是教科书式的了吧，自己开发中都可以借鉴到的。</p>
<h2 id="config-js"><a href="#config-js" class="headerlink" title="config.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/config.js" target="_blank" rel="external">config.js</a></h2><p>core/config.js 文件里面记录了所有Vue可使用的配置，有些在api文档上查的到，有的则查不到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @flow */</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; no, noop, identity &#125; <span class="keyword">from</span> <span class="string">'shared/util'</span></div><div class="line"></div><div class="line"><span class="comment">// 这部分是给flow检查Config中每个属性的类型用的，简单易懂，同事标注了属性是给哪部分用的</span></div><div class="line"><span class="keyword">export</span> type Config = &#123;</div><div class="line">  <span class="comment">// user(用户可配置的属性)</span></div><div class="line">  optionMergeStrategies: &#123; [key: string]: <span class="built_in">Function</span> &#125;;</div><div class="line">  silent: boolean;</div><div class="line">  productionTip: boolean;</div><div class="line">  performance: boolean;</div><div class="line">  devtools: boolean;</div><div class="line">  errorHandler: ?<span class="function">(<span class="params">err: <span class="built_in">Error</span>, vm: Component, info: string</span>) =&gt;</span> <span class="keyword">void</span>;</div><div class="line">  ignoredElements: <span class="built_in">Array</span>&lt;string&gt;;</div><div class="line">  keyCodes: &#123; [key: string]: number | <span class="built_in">Array</span>&lt;number&gt; &#125;;</div><div class="line">  <span class="comment">// platform(给不同平台用的属性)</span></div><div class="line">  isReservedTag: <span class="function">(<span class="params">x?: string</span>) =&gt;</span> boolean;</div><div class="line">  parsePlatformTagName: <span class="function">(<span class="params">x: string</span>) =&gt;</span> string;</div><div class="line">  isUnknownElement: <span class="function">(<span class="params">x?: string</span>) =&gt;</span> boolean;</div><div class="line">  getTagNamespace: <span class="function">(<span class="params">x?: string</span>) =&gt;</span> string | <span class="keyword">void</span>;</div><div class="line">  mustUseProp: <span class="function">(<span class="params">tag: string, type: ?string, name: string</span>) =&gt;</span> boolean;</div><div class="line">  <span class="comment">// internal(内部用的属性)</span></div><div class="line">  _assetTypes: <span class="built_in">Array</span>&lt;string&gt;;</div><div class="line">  _lifecycleHooks: <span class="built_in">Array</span>&lt;string&gt;;</div><div class="line">  _maxUpdateCount: number;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> config: Config = &#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 用户属性在官方文档中都有详细的说明，我就不做过多解释了，简单翻译一下</div><div class="line">   * 自定义合并策略 (used in core/util/options)</div><div class="line">   */</div><div class="line">  optionMergeStrategies: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 日志的控制开关</div><div class="line">   */</div><div class="line">  silent: <span class="literal">false</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 启东市是否显示生产模式的提示信息，这个是根据构造时测参数决定的</div><div class="line">   */</div><div class="line">  productionTip: process.env.NODE_ENV !== <span class="string">'production'</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 是否使用调试工具</div><div class="line">   */</div><div class="line">  devtools: process.env.NODE_ENV !== <span class="string">'production'</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 是否显示性能数据</div><div class="line">   */</div><div class="line">  performance: process.env.NODE_ENV !== <span class="string">'production'</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 异常处理接口，如果使用官方文档上有</div><div class="line">   */</div><div class="line">  errorHandler: <span class="literal">null</span>,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 忽略某些自定义元素</div><div class="line">   */</div><div class="line">  ignoredElements: [],</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 给 v-on 自定义键位别名</div><div class="line">   */</div><div class="line">  keyCodes: <span class="built_in">Object</span>.create(<span class="literal">null</span>),</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 检查标签是否是保留标签的方法，各个平台之间不一样，没错，需要是一个返回true、false的方法</div><div class="line">   * 具体检查方法可以在 src/platforms/ 里面找</div><div class="line">   */</div><div class="line">  isReservedTag: no,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 检查标签是否是未知标签</div><div class="line">   */</div><div class="line">  isUnknownElement: no,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 获取标签的命名空间，也可以理解为获取标签的类型吧，html、svg之类的</div><div class="line">   */</div><div class="line">  getTagNamespace: noop,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 解析标签在平台中的名字……貌似对标签名做映射的</div><div class="line">   */</div><div class="line">  parsePlatformTagName: identity,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 检查标签必须包含的属性，比如input标签必须有value属性之类的……</div><div class="line">   */</div><div class="line">  mustUseProp: no,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 所有支持的资源的列表</div><div class="line">   */</div><div class="line">  _assetTypes: [</div><div class="line">    <span class="string">'component'</span>,</div><div class="line">    <span class="string">'directive'</span>,</div><div class="line">    <span class="string">'filter'</span></div><div class="line">  ],</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 所有生命周期的列表</div><div class="line">   */</div><div class="line">  _lifecycleHooks: [</div><div class="line">    <span class="string">'beforeCreate'</span>,</div><div class="line">    <span class="string">'created'</span>,</div><div class="line">    <span class="string">'beforeMount'</span>,</div><div class="line">    <span class="string">'mounted'</span>,</div><div class="line">    <span class="string">'beforeUpdate'</span>,</div><div class="line">    <span class="string">'updated'</span>,</div><div class="line">    <span class="string">'beforeDestroy'</span>,</div><div class="line">    <span class="string">'destroyed'</span>,</div><div class="line">    <span class="string">'activated'</span>,</div><div class="line">    <span class="string">'deactivated'</span></div><div class="line">  ],</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 更新数据的最大循环次数</div><div class="line">   */</div><div class="line">  _maxUpdateCount: <span class="number">100</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> config</div></pre></td></tr></table></figure>
<p>这个文件本身是没有逻辑的，而且每个属性都有注释，我就简单翻一下注释。感觉flow只是挺好用的呢，作用和typescript类似，如果不用vscode做编辑器，用flow来代替typescript应该会更简单方便一些，如果用vscode，那么使用typescript应该会更方便。虽然不服，但是大微软只是不鸣则已一鸣惊人，vscode甩了atom不知道多少条街……跑题了跑题了，好的那么由于时间不足，本期笔记就先写到这里，如果不出意外的话，maybe可能也许大概下周五会更新吧，能不能准时更新，就全看米娜桑点赞转发安利留言的力度了~!</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;五一好好给自己放了个假，去成都玩儿了几天。话说成都的生活可真是悠闲，搞得我都向去成都买房定居了~而且成都的吃的可真是，（¯﹃¯）…… 一想到猪肉锅盔和冒节子肥肠粉我口水就开始往外涌……咳咳……言归正传，上次说这次要读core的全部全局api和config，下面咱们就开始。&lt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(4)</title>
    <link href="http://brooch.me/2017/04/21/vue-source-notes-4/"/>
    <id>http://brooch.me/2017/04/21/vue-source-notes-4/</id>
    <published>2017-04-21T05:37:29.000Z</published>
    <updated>2017-05-05T13:43:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，又到了一周一度的deadline……之前几次把杂七杂八的部分读完了，这次终于要开始读vue核心部分的代码了。从之前读过的 src/entries 模块中可以看到，vue核心的代码的大概可以分为 runtime 和 compiler 两部分。runtime 对应 src/core 模块，compiler 对应 src/compiler 模块，这次就从 src/core 模块开始读。</p>
<h2 id="Vue核心模块-core"><a href="#Vue核心模块-core" class="headerlink" title="Vue核心模块 core"></a>Vue核心模块 core</h2><p>这个模块最后输出的就是一个Vue的构造函数，里面包含了组件系统、全局API、vue实例、对象属性监测系统、公共方法、虚拟dom、配置，这些模块。因为各个模块之间都有联系，单拎出来一个个看感觉没法看到全貌呀。所以这次换个方式试试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">|- core</div><div class="line">  |- components</div><div class="line">  |- global-api</div><div class="line">  |- instance</div><div class="line">  |- observer</div><div class="line">  |- util</div><div class="line">  |- vdom</div><div class="line">  |- config.js</div><div class="line">  |- index.js</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>从 src/entries/web-runtime.js 文件中可以看出，Vue 这个构造函数是从 src/core/index.js 导出的，这个文件的代码如下：</p>
<h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/index.js" target="_blank" rel="external">index.js</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./instance/index'</span></div><div class="line"><span class="keyword">import</span> &#123; initGlobalAPI &#125; <span class="keyword">from</span> <span class="string">'./global-api/index'</span></div><div class="line"><span class="keyword">import</span> &#123; isServerRendering &#125; <span class="keyword">from</span> <span class="string">'core/util/env'</span></div><div class="line"></div><div class="line"><span class="comment">// Vue构造函数来自src/core/instance/index.js</span></div><div class="line"><span class="comment">// 通过initGlobalAPI这个函数添加全局api</span></div><div class="line">initGlobalAPI(Vue)</div><div class="line"></div><div class="line"><span class="comment">// 是否运行在服务端的标记，对应文档中的 https://cn.vuejs.org/v2/api/?#vm-isServer</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$isServer'</span>, &#123;</div><div class="line">  <span class="attr">get</span>: isServerRendering</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// __VERSION__ 是在 build/config.js 里面配置的，在构建的时候通过脚本替换为配置里的变量</span></div><div class="line">Vue.version = <span class="string">'__VERSION__'</span></div><div class="line"></div><div class="line"><span class="comment">// 导出Vue构造函数</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure>
<p>Vue.prototype.$isServer 和 Vue.version 比较简单就不展开了，Vue构造函数后面再看，先看全局api吧。</p>
<h3 id="index-js-1"><a href="#index-js-1" class="headerlink" title="index.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/core/global-api/index.js" target="_blank" rel="external">index.js</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; initUse &#125; <span class="keyword">from</span> <span class="string">'./use'</span></div><div class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./mixin'</span></div><div class="line"><span class="keyword">import</span> &#123; initExtend &#125; <span class="keyword">from</span> <span class="string">'./extend'</span></div><div class="line"><span class="keyword">import</span> &#123; initAssetRegisters &#125; <span class="keyword">from</span> <span class="string">'./assets'</span></div><div class="line"><span class="keyword">import</span> &#123; set, del &#125; <span class="keyword">from</span> <span class="string">'../observer/index'</span></div><div class="line"><span class="keyword">import</span> builtInComponents <span class="keyword">from</span> <span class="string">'../components/index'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  warn,</div><div class="line">  extend,</div><div class="line">  nextTick,</div><div class="line">  mergeOptions,</div><div class="line">  defineReactive</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initGlobalAPI</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  <span class="comment">// 首先配置 Vue.config ，在定义时使用了 Object.defineProperty</span></div><div class="line">  <span class="comment">// 所以在设置 Vue.config 的时候是不能直接 Vue.config = &#123;....&#125;这样的，不然会报错，得一项一项设</span></div><div class="line">  <span class="keyword">const</span> configDef = &#123;&#125;</div><div class="line">  configDef.get = <span class="function"><span class="params">()</span> =&gt;</span> config</div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">    configDef.set = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      warn(</div><div class="line">        <span class="string">'Do not replace the Vue.config object, set individual fields instead.'</span></div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(Vue, <span class="string">'config'</span>, configDef)</div><div class="line"></div><div class="line">  <span class="comment">// Vue.util虽然暴露出来了，但是并不是公共api的一部分，所以用的时候要小心点儿</span></div><div class="line">  Vue.util = &#123;</div><div class="line">    <span class="comment">// 下面这些方法都来自 core/util/这个模块，这里先简单说下每个函数的用途，后续展开</span></div><div class="line">    <span class="comment">// 输出错误信息用的，同事还能输出错误组件的名字和对应的vue文件地址</span></div><div class="line">    warn,</div><div class="line">    <span class="comment">// 顾名思义，浅拷贝</span></div><div class="line">    extend,</div><div class="line">    <span class="comment">// 用来合并实例option的，组件实例化和继承的核心方法</span></div><div class="line">    mergeOptions,</div><div class="line">    <span class="comment">// 用来给对象定义响应属性</span></div><div class="line">    defineReactive</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 给实例添加属性，对应 https://cn.vuejs.org/v2/api/?#Vue-set</span></div><div class="line">  Vue.set = set</div><div class="line">  <span class="comment">// 删除实例属性，对应 https://cn.vuejs.org/v2/api/?#Vue-delete</span></div><div class="line">  Vue.delete = del</div><div class="line">  <span class="comment">// 对应 https://cn.vuejs.org/v2/api/?#Vue-nextTick，一个打包执行延迟任务的方法，采用Promise =&gt; MutationObserver =&gt; setTimeout(0)的退化设计</span></div><div class="line">  <span class="comment">// 在读nextTick源码的时候发现几个有意思的点，本来想憋到写 src/core/util 的时候再写的，但是我实在是憋不住了哈哈</span></div><div class="line">  <span class="comment">// 1. 在使用promise的时候，ios里（其实就是safari和uiwebview）如果直接用promise.resolve()触发一个then的话，</span></div><div class="line">  <span class="comment">// 他不会立即执行，运行一个空的setTimeout之后，在就没问题了……相当神奇……</span></div><div class="line">  <span class="comment">// 另外，我发现他的ios判断里没有判断safari，但是safari里也有这个问题，不知道是不是bug……</span></div><div class="line">  <span class="comment">// 2. MutationObserver是通过观测dom元素的变化来触发事件回调，具体替代promise的方法等看到了再详细说吧</span></div><div class="line">  <span class="comment">// 3. 还有一个细节，在执行一批回调的时候，用的是[].length=0来清空数组，而不是空数组赋值的方法，感觉是为了省内存，不用频繁gc</span></div><div class="line">  Vue.nextTick = nextTick</div><div class="line">  <span class="comment">// options用来存定义过的组件的，支持component, directive, filter，支持的组件列表保存在_assetTypes里面</span></div><div class="line">  <span class="comment">// 具体还没有细看，但是感觉是支持扩展的</span></div><div class="line">  Vue.options = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">  config._assetTypes.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</div><div class="line">    Vue.options[type + <span class="string">'s'</span>] = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 用来给所有实例标记base构造函数用的属性</span></div><div class="line">  Vue.options._base = Vue</div><div class="line"></div><div class="line">  <span class="comment">// 挂载keep-alive组件，https://cn.vuejs.org/v2/api/?#keep-alive</span></div><div class="line">  extend(Vue.options.components, builtInComponents)</div><div class="line"></div><div class="line">  <span class="comment">// 挂载 Vue.use 方法</span></div><div class="line">  initUse(Vue)</div><div class="line">  <span class="comment">// 挂载 Vue.mixin 方法</span></div><div class="line">  initMixin(Vue)</div><div class="line">  <span class="comment">// 挂载 Vue.extend 方法</span></div><div class="line">  initExtend(Vue)</div><div class="line">  <span class="comment">// 挂载 Vue.component, Vue.directive, Vue.filter 方法</span></div><div class="line">  initAssetRegisters(Vue)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>全局api的挂载逻辑还算相对简单，Vue的方法挂载每部分都拆成了单独的函数，利用js中Function是对象、可以作为参数的特性、是引用类型等特性，用这种函数来加工Vue构造函数，不知道这算不算装饰模式呢……</p>
<p>另外我发现一个细节，源码中在生成空对象的时候，会用Object.create(null)来生成，具体原因不明，因为这两种方式，除了原型不一样，其他的没区别，因为也见到有使用字面量来生成空对象的，所以会不会是因为是开源项目，开源项目中大量人员参与其中，每个人的编码习惯有差异造成的呢……</p>
<p>好的那么由于时间不足，本期笔记就先写到这里，话说每次只看这么一点儿，我还真是感觉惭愧呢，希望未来可以挤出更多的时间来读吧……如果不出意外的话，maybe可能也许大概下周五会更新吧，下周准备更新config和全部全局api，能不能准时更新，就全看米娜桑点赞转发安利留言的力度了~、</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，又到了一周一度的deadline……之前几次把杂七杂八的部分读完了，这次终于要开始读vue核心部分的代码了。从之前读过的 src/entries 模块中可以看到，vue核心的代码的大概可以分为 runtime 和 compiler 两部分。runtime 对应 src/
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(3)</title>
    <link href="http://brooch.me/2017/04/14/vue-source-notes-3/"/>
    <id>http://brooch.me/2017/04/14/vue-source-notes-3/</id>
    <published>2017-04-14T08:51:35.000Z</published>
    <updated>2017-04-14T08:46:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>啊……写这篇博客的时候我刚上了一宿的线……现在多一个字都不想说了……直接开始吧……</p>
<a id="more"></a>
<h2 id="公共方法模块-shared"><a href="#公共方法模块-shared" class="headerlink" title="公共方法模块 shared"></a>公共方法模块 shared</h2><p>故名思议，shared模块是放所有公共方法的，里面只有 util.js 一个文件。</p>
<h3 id="util-js"><a href="#util-js" class="headerlink" title="util.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/shared/util.js" target="_blank" rel="external">util.js</a></h3><p>util.js一共暴露了23个方法，每个函数都非常基础，第一眼看上去感觉没啥可看的，但是仔细看每个函数会发现，这些函数都很实用，而且正是因为基础，很可能会成为以后面试的考题……</p>
<p>总之过一遍下这些方法吧，记录下我认为有用的知识点，当做事知识储备了：</p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="_toString"></a>_toString</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个函数可以将任意类型的值转为字符串</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_toString</span> (<span class="params">val: any</span>): <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> val == <span class="literal">null</span></div><div class="line">    <span class="comment">// 如果是null就返回空字符串</span></div><div class="line">    ? <span class="string">''</span></div><div class="line">    : <span class="keyword">typeof</span> val === <span class="string">'object'</span></div><div class="line">      <span class="comment">// 如果是object就转成json</span></div><div class="line">      <span class="comment">// 这里比较特殊的是在调用stringify时除了要转换的值，还多传了两个参数，其中第二个参数用来过滤数据，第三个参数用来控制内容的缩进</span></div><div class="line">      ? <span class="built_in">JSON</span>.stringify(val, <span class="literal">null</span>, <span class="number">2</span>)</div><div class="line">      <span class="comment">// 其他的都是用String来转换为字符串，其实跟调用对象的toString是一样的吧？</span></div><div class="line">      : <span class="built_in">String</span>(val)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="toNumber"><a href="#toNumber" class="headerlink" title="toNumber"></a>toNumber</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将传入的值转换为浮点数，如果转换失败就返回传入值</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toNumber</span> (<span class="params">val: string</span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="comment">// 浮点数没加 ",10" ，不知道是不是个隐藏的问题</span></div><div class="line">  <span class="keyword">const</span> n = <span class="built_in">parseFloat</span>(val)</div><div class="line">  <span class="keyword">return</span> <span class="built_in">isNaN</span>(n) ? val : n</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="makeMap"><a href="#makeMap" class="headerlink" title="makeMap"></a>makeMap</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个函数比较有意思，功能有点儿像集合（Set）对象，但是只能存储字符串，最后用来判断值是否已经存在</span></div><div class="line"><span class="comment">// 貌似是用来快速检索某个值是否存在用的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">makeMap</span> (<span class="params"></span></span></div><div class="line">  str: string,</div><div class="line">  expectsLowerCase?: boolean</div><div class="line">): (<span class="params">key: string</span>) =&gt; <span class="title">true</span> | <span class="title">void</span> &#123;</div><div class="line">  <span class="keyword">const</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">  <span class="keyword">const</span> list: <span class="built_in">Array</span>&lt;string&gt; = str.split(<span class="string">','</span>)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line">    map[list[i]] = <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> expectsLowerCase</div><div class="line">    ? <span class="function"><span class="params">val</span> =&gt;</span> map[val.toLowerCase()]</div><div class="line">    : <span class="function"><span class="params">val</span> =&gt;</span> map[val]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isBuiltInTag"><a href="#isBuiltInTag" class="headerlink" title="isBuiltInTag"></a>isBuiltInTag</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成一个用来检索是否是内置标签的函数，用到了之前的makeMap方法</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> isBuiltInTag = makeMap(<span class="string">'slot,component'</span>, <span class="literal">true</span>)</div></pre></td></tr></table></figure>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个工具方法，用来删除数组中匹配到的对象</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">arr: Array&lt;any&gt;, item: any</span>): <span class="title">Array</span>&lt;<span class="title">any</span>&gt; | <span class="title">void</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (arr.length) &#123;</div><div class="line">    <span class="keyword">const</span> index = arr.indexOf(item)</div><div class="line">    <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="hasOwn"><a href="#hasOwn" class="headerlink" title="hasOwn"></a>hasOwn</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对Object.prototype.hasOwnProperty的封装，用来判断对象的属性是否是继承自原型的</span></div><div class="line"><span class="comment">// 顺便复习下instanceof和typeof</span></div><div class="line"><span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof</span></div><div class="line"><span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof</span></div><div class="line"><span class="comment">// 除了三者作用的区别以外，需要注意的是，hasOwnProperty是函数，instanceof和typeof是运算符</span></div><div class="line"><span class="comment">// 其实MDN上写的instanceof是运算符，typeof是操作符，特意查了一下，在英语中操作符和运算符都叫operator，应该可以认为是一个东西吧</span></div><div class="line"><span class="comment">// 与函数的区别在于，一个是符号，一个是有名称的，另外，函数有明确定义的参数表，符号没有</span></div><div class="line"><span class="comment">// 当然，从广义来上来看，任何一个运算符都可看做是一个函数，而它的运算数可看做参数</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hasOwn</span> (<span class="params">obj: Object, key: string</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> hasOwnProperty.call(obj, key)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isPrimitive"><a href="#isPrimitive" class="headerlink" title="isPrimitive"></a>isPrimitive</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断一个值是否是基础类型？字面上看primitive是原始的意思……</span></div><div class="line"><span class="comment">// 总之就是判断传入的参数是否是数字或者字符串</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPrimitive</span> (<span class="params">value: any</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'string'</span> || <span class="keyword">typeof</span> value === <span class="string">'number'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="cached"><a href="#cached" class="headerlink" title="cached"></a>cached</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成一个带缓存的纯函数</span></div><div class="line"><span class="comment">// 就是会把每次函数执行的结果缓存起来</span></div><div class="line"><span class="comment">// 根据纯函数的定义，传入同样的参数值，函数总是求出同样的结果，这样处理之后可以大幅提升函数的运算速度</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cached</span>&lt;<span class="title">F</span>: <span class="title">Function</span>&gt; (<span class="params">fn: F</span>): <span class="title">F</span> </span>&#123;</div><div class="line">  <span class="comment">// 定义缓存对象</span></div><div class="line">  <span class="keyword">const</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div><div class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">cachedFn</span> (<span class="params">str: string</span>) </span>&#123;</div><div class="line">    <span class="comment">// 根据传入的参数取缓存</span></div><div class="line">    <span class="keyword">const</span> hit = cache[str]</div><div class="line">    <span class="comment">// 检查缓存是否存在，如果存在就直接返回缓存，缓存不存在就运行函数缓存结果</span></div><div class="line">    <span class="keyword">return</span> hit || (cache[str] = fn(str))</div><div class="line">  &#125;: any)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="camelize"><a href="#camelize" class="headerlink" title="camelize"></a>camelize</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将破折号分割的命名修改为驼峰命名</span></div><div class="line"><span class="comment">// 感觉是在解析模板时，将tag name转换为 class name用的</span></div><div class="line"><span class="keyword">const</span> camelizeRE = <span class="regexp">/-(\w)/g</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> camelize = cached((str: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> str.replace(camelizeRE, (_, c) =&gt; c ? c.toUpperCase() : <span class="string">''</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="capitalize"><a href="#capitalize" class="headerlink" title="capitalize"></a>capitalize</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将字符串首字母转换为大写的函数</span></div><div class="line"><span class="comment">// 估计是跟camelize配合一起使用的吧</span></div><div class="line"><span class="comment">// 最后的效果就是：&lt;my-component&gt; ==&gt; MyComponent</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> capitalize = cached((str: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> str.charAt(<span class="number">0</span>).toUpperCase() + str.slice(<span class="number">1</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="hyphenate"><a href="#hyphenate" class="headerlink" title="hyphenate"></a>hyphenate</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将驼峰命名再改回中划线命名……(￣.￣)</span></div><div class="line"><span class="comment">// 效果类似于：ABCD =&gt; a-b-c-d</span></div><div class="line"><span class="keyword">const</span> hyphenateRE = <span class="regexp">/([^-])([A-Z])/g</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> hyphenate = cached((str: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> st</div><div class="line">    <span class="comment">// 这里要调用两次replace是因为，如果是 ABCD 这种包含三个连续大写字母的字符串，</span></div><div class="line">    <span class="comment">// 只replace一次会变成A-BC-D这样，需要再replace一次……</span></div><div class="line">    .replace(hyphenateRE, <span class="string">'$1-$2'</span>)</div><div class="line">    .replace(hyphenateRE, <span class="string">'$1-$2'</span>)</div><div class="line">    .toLowerCase()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单实现的bind方法，源码的注释中说比原生的bind快</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">fn: Function, ctx: Object</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">boundFn</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> l: number = <span class="built_in">arguments</span>.length</div><div class="line">    <span class="keyword">return</span> l</div><div class="line">      ? l &gt; <span class="number">1</span></div><div class="line">        ? fn.apply(ctx, <span class="built_in">arguments</span>)</div><div class="line">        : fn.call(ctx, a)</div><div class="line">      : fn.call(ctx)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 记录原始函数的参数个数</span></div><div class="line">  boundFn._length = fn.length</div><div class="line">  <span class="keyword">return</span> boundFn</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将类数组对象转化为一个数组，其实这个操作挺常见的，但是这样用循环处理貌似效率低呢</span></div><div class="line"><span class="comment">// 测试了一下使用Array.prototype上的方法来做转换会快100倍……</span></div><div class="line"><span class="comment">// 不知道为啥不用……</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toArray</span> (<span class="params">list: any, start?: number</span>): <span class="title">Array</span>&lt;<span class="title">any</span>&gt; </span>&#123;</div><div class="line">  start = start || <span class="number">0</span></div><div class="line">  <span class="keyword">let</span> i = list.length - start</div><div class="line">  <span class="keyword">const</span> ret: <span class="built_in">Array</span>&lt;any&gt; = <span class="keyword">new</span> <span class="built_in">Array</span>(i)</div><div class="line">  <span class="keyword">while</span> (i--) &#123;</div><div class="line">    ret[i] = list[i + start]</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> ret</div><div class="line">&#125;</div><div class="line"><span class="comment">// 用14年的mac air测试，</span></div><div class="line"><span class="comment">// 使用concat和slice来做转换的版本，转换10000次耗时10ms，</span></div><div class="line"><span class="comment">// 用循环的版本耗时1000ms</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toArray</span> (<span class="params">list: any, start?: number</span>): <span class="title">Array</span>&lt;<span class="title">any</span>&gt; </span>&#123;</div><div class="line">  start = start || <span class="number">0</span></div><div class="line">  <span class="keyword">const</span> ret: <span class="built_in">Array</span>&lt;any&gt; = [].concat(list)</div><div class="line">  <span class="keyword">return</span> ret.slice(start)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单的浅拷贝，原来用的object.keys来取key，现在改成用循环了，估计用原生API效率低吧</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span> (<span class="params">to: Object, _from: ?Object</span>): <span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> _from) &#123;</div><div class="line">    to[key] = _from[key]</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> to</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isObject"><a href="#isObject" class="headerlink" title="isObject"></a>isObject</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 超简单的对象检查……</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isObject</span> (<span class="params">obj: mixed</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="isPlainObject"><a href="#isPlainObject" class="headerlink" title="isPlainObject"></a>isPlainObject</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用Object.prototype.toString做的严格对象检查</span></div><div class="line"><span class="keyword">const</span> toString = <span class="built_in">Object</span>.prototype.toString</div><div class="line"><span class="keyword">const</span> OBJECT_STRING = <span class="string">'[object Object]'</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span> (<span class="params">obj: any</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> toString.call(obj) === OBJECT_STRING</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="toObject"><a href="#toObject" class="headerlink" title="toObject"></a>toObject</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 讲一个元素都是对象的数组合并成一个对象……</span></div><div class="line"><span class="comment">// 貌似是用来将标签的属性合并为一个配置对象用的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toObject</span> (<span class="params">arr: Array&lt;any&gt;</span>): <span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> res = &#123;&#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (arr[i]) &#123;</div><div class="line">      extend(res, arr[i])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res</div><div class="line">&#125;</div><div class="line"><span class="comment">// 话说之前看到的使用reduce来遍历对象的方法，其实也能够使在这里的</span></div><div class="line"><span class="comment">// 比如这样</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toObject</span> (<span class="params">arr: Array&lt;any&gt;</span>): <span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">res, cur</span>) =&gt;</span> extend(res,cur), &#123;&#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 是不是简洁多了呢？</span></div></pre></td></tr></table></figure>
<h2 id="noop"><a href="#noop" class="headerlink" title="noop"></a>noop</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不执行操作的空函数</span></div><div class="line"><span class="comment">// 抓要是为了兼容那些需要函数作为参数的函数，有没有可做的操作时用的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">noop</span> (<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="no"><a href="#no" class="headerlink" title="no"></a>no</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 永远返回false的函数，作用跟noop一样的</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> no = <span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">false</span></div></pre></td></tr></table></figure>
<h2 id="identity"><a href="#identity" class="headerlink" title="identity"></a>identity</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回传入的参数，同上，嗯……</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> identity = <span class="function">(<span class="params">_: any</span>) =&gt;</span> _</div></pre></td></tr></table></figure>
<h2 id="genStaticKeys"><a href="#genStaticKeys" class="headerlink" title="genStaticKeys"></a>genStaticKeys</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用来将模块数组转换出模块名的一个字符串……</span></div><div class="line"><span class="comment">// 这个方法也是用了reduce来做遍历赋值，使用这种方法还真是挺简洁的</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">genStaticKeys</span> (<span class="params">modules: Array&lt;ModuleOptions&gt;</span>): <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> modules.reduce(<span class="function">(<span class="params">keys, m</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> keys.concat(m.staticKeys || [])</div><div class="line">  &#125;, []).join(<span class="string">','</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="looseEqual"><a href="#looseEqual" class="headerlink" title="looseEqual"></a>looseEqual</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单比较两个对象是否一致，就是转成字符串然后比较字符串是否一致</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">looseEqual</span> (<span class="params">a: mixed, b: mixed</span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> isObjectA = isObject(a)</div><div class="line">  <span class="keyword">const</span> isObjectB = isObject(b)</div><div class="line">  <span class="keyword">if</span> (isObjectA &amp;&amp; isObjectB) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(a) === <span class="built_in">JSON</span>.stringify(b)</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isObjectA &amp;&amp; !isObjectB) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(a) === <span class="built_in">String</span>(b)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="looseIndexOf"><a href="#looseIndexOf" class="headerlink" title="looseIndexOf"></a>looseIndexOf</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用了looseEqual的indexOf</span></div><div class="line"><span class="comment">// 话说这个判断方法的思想就是，只要有同样的结构，那么就是同样的对象</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">looseIndexOf</span> (<span class="params">arr: Array&lt;mixed&gt;, val: mixed</span>): <span class="title">number</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (looseEqual(arr[i], val)) <span class="keyword">return</span> i</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="once"><a href="#once" class="headerlink" title="once"></a>once</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 确保只调用一次函数</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">once</span> (<span class="params">fn: Function</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">  <span class="comment">// called应该算是一个锁吧</span></div><div class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!called) &#123;</div><div class="line">      <span class="comment">// 上锁</span></div><div class="line">      called = <span class="literal">true</span></div><div class="line">      fn()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>昏昏沉沉的总算是完了……不知道是缺觉还是怎么的，写着技术的文章，心里却想到了很多技术之外的东西。不过今天实在是没精力写了，留个TODO吧，后续整理好了再更新上来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊……写这篇博客的时候我刚上了一宿的线……现在多一个字都不想说了……直接开始吧……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>nodejs热更新的方法</title>
    <link href="http://brooch.me/2017/04/07/nodejs-hotreload/"/>
    <id>http://brooch.me/2017/04/07/nodejs-hotreload/</id>
    <published>2017-04-07T14:04:44.000Z</published>
    <updated>2017-04-14T08:47:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，没错，我又来要放水了今天……这个周末停休了，没辙没辙的……</p>
<a id="more"></a>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>话说上周看了朋友的一篇博客 <a href="https://yj1438.github.io/2017/03/31/respawn.html" target="_blank" rel="external">通过 respawn 加强需要即时生效的开发环境构建系统</a> ，里面说到了用子进程来更新应用的方法，个人感觉就是像Jetty那样的热部署机制吧。但是归根结底，还是要重新启动整个应用才能完成更新，这点上来说感觉并不完美。那么能不能做到真正的0重启热更新代码呢？本文提一个另类的思路给大家参考一下。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>废话不多说了，认真读过nodejs文档的人都应该注意过这个api <a href="http://nodejs.cn/api/globals.html#globals_require_cache" target="_blank" rel="external">require.cache</a> 。文档里写的很清楚，如果这个对象中的引用被清除了，下次再调用就会重新加载，我们可以使用这个机制来热加载更新的模块。</p>
<p>下面有个小栗子可以验证这个思路的可行性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanCache</span> (<span class="params">module</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> path = <span class="built_in">require</span>.resolve(<span class="built_in">module</span>);</div><div class="line">    <span class="built_in">require</span>.cache[path] &amp;&amp; (<span class="built_in">require</span>.cache[path] = <span class="literal">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span> (<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                fs.writeFileSync(<span class="string">"test.js"</span>, <span class="string">"module.exports = \""</span> + text + <span class="string">"\";"</span>);</div><div class="line">                resolve(<span class="literal">true</span>)</div><div class="line">            &#125;,<span class="number">1000</span>)</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fs.watchFile(<span class="string">'test.js'</span>,&#123;</div><div class="line">    <span class="attr">interval</span>:<span class="number">100</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    cleanCache(<span class="string">'./test'</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">require</span>(<span class="string">'./test'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">write(<span class="string">"hello"</span>)().then(write(<span class="string">"my name is zxc"</span>))</div><div class="line"></div><div class="line"><span class="comment">// test.js</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="string">''</span>;</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当然这种方法看上去挺好，但是存在的问题也挺多的。首先，这个方法没办法更新c\c++模块，另外，原生模块也是没法更新的。然后，由于 node.js 本身缺乏对有效的留存对象的扫描机制，有时会出现老模块的资源无法释放的问题，比如setInterval中引用的模块之类的……╮(￣▽￣)╭。总之，生产环境就别想了，但是用来开发调试些经常修改的简单模块的话，会是个不错的选择，比如router之类的配置文件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>怎么说呢，既然是个另类的思路，所以应用场景远没有线程替换那种方法大的。如果是生产环境，依然是推荐使用使用重启或者 PM2 的 hot reload 功能来保证稳定性。另外，webpack也有热替换的功能，HMR嘛，其实这也可以算是一个思路，具体的可以参考这个系列的文章<a href="http://jlongster.com/search?query=Backend%20Apps%20with%20Webpack" target="_blank" rel="external">Backend Apps with Webpack</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://segmentfault.com/a/1190000003888845" target="_blank" rel="external">Webpack 做 Node.js 代码热替换, 第一步</a></li>
<li><a href="https://github.com/rlidwka/node-hotswap" target="_blank" rel="external">node-hotswap</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，没错，我又来要放水了今天……这个周末停休了，没辙没辙的……&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(2)</title>
    <link href="http://brooch.me/2017/03/31/vue-source-notes-2/"/>
    <id>http://brooch.me/2017/03/31/vue-source-notes-2/</id>
    <published>2017-03-31T00:23:23.000Z</published>
    <updated>2017-03-31T07:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>啊，又到deadline了……话说因为之前一直在整理<a href="/2017/03/17/vue-source-notes-1/index.html">上一篇</a>笔记，所以过了这么长时间一直都没怎么读新的，真是惭愧啊……那么这次就读两个简单的模块吧，把简单的解决了，后续再啃硬骨头。</p>
<a id="more"></a>
<h2 id="解析单文件组件-sfc"><a href="#解析单文件组件-sfc" class="headerlink" title="解析单文件组件 sfc"></a>解析单文件组件 sfc</h2><p>之前在说目录结构的时候说过，sfc模块是用来解析.vue文件的，sfc貌似就是single file component的意思……(￣.￣;) 整个模块只有一个文件，但是逻辑却不简单呢……另外在官方文档中对单文件组件的描述也只有短短一个章节，所以感觉这部分通过源码能更充分的了解细节呢，那么先看下代码逻辑：</p>
<h3 id="parser-js"><a href="#parser-js" class="headerlink" title="parser.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/sfc/parser.js" target="_blank" rel="external">parser.js</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 用来匹配换行的正则表达式</span></div><div class="line"><span class="keyword">const</span> splitRE = <span class="regexp">/\r?\n/g</span></div><div class="line"><span class="comment">// 定义了一个判断标签是否是script、style、template标签的函数</span></div><div class="line"><span class="keyword">const</span> isSpecialTag = makeMap(<span class="string">'script,style,template'</span>, <span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="comment">// 解析单个.vue文件的函数</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parseComponent</span> (<span class="params"></span></span></div><div class="line">    <span class="regexp">//</span> 这里特意没有去掉flow的语法，顺便记录下flow的用法</div><div class="line">    <span class="regexp">//</span> 参数后面加（: 类型）表示参数的类型</div><div class="line">    content: string,</div><div class="line">    <span class="regexp">//</span> 参数后面加（?: 类型）表示可省略参数和类型， (= &#123;&#125;) 是<span class="title">es6</span>语法，表示参数的默认值……</div><div class="line">    <span class="title">options</span>?: <span class="title">Object</span> = &#123;&#125;</div><div class="line">    <span class="comment">// （function(): 类型）表示函数的返回值类型，</span></div><div class="line">    <span class="comment">// 这里的SFCDescriptor是一个自定义类型，定义在flow/complier.js里面</span></div><div class="line">    <span class="comment">// 感觉有点像结构体(struct)，另外flow还支持interface和class的定义</span></div><div class="line"> ): SFCDescriptor &#123;</div><div class="line">    <span class="comment">// 最后导出的sfc对象，分为template、script、style和自定义块四部分</span></div><div class="line">    <span class="comment">// 其中style和自定义块允许多个，template和script只允许一个</span></div><div class="line">    <span class="keyword">const</span> sfc: SFCDescriptor = &#123;</div><div class="line">        <span class="attr">template</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">script</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">styles</span>: [],</div><div class="line">        <span class="attr">customBlocks</span>: []</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 因为最后是使用compiler/parser/html-parser模块进行解析的，而html-parser模块会根据dom结构进行递归解析的，</span></div><div class="line">    <span class="comment">// 所以每个代码块都有自己的深度，这里的depth就是用来标记深度的，从后续的代码中可以看出，sfc/parser模块不会处理嵌套的块，只处理一层，这个变量被用来做锁了……</span></div><div class="line">    <span class="keyword">let</span> depth = <span class="number">0</span></div><div class="line">    <span class="comment">// 当前处理的代码块</span></div><div class="line">    <span class="keyword">let</span> currentBlock: ?(SFCBlock | SFCCustomBlock) = <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment">// 稍微调整了下代码的顺序，这个parseHTML的调用本来是放到最后的，这样其实也不会报错吧~</span></div><div class="line">    <span class="comment">// 这个调用也是整个parseComponent函数最核心的部分，使用compiler/parser/html-parser模块的能力来解析模板</span></div><div class="line">    <span class="comment">// parseHTML函数接收一个options参数（第二个），里面可以设置匹配到标签开始和结束时的钩子，通过钩子来获取自己写想要的内容，</span></div><div class="line">    <span class="comment">// 就是说，比如有个&lt;tag&gt;xxx&lt;/tag&gt;这样的内容，匹配到&lt;tag&gt;时，执行start，匹配到&lt;/tag&gt;时，执行end，</span></div><div class="line">    <span class="comment">// 如果匹配到&lt;tab/&gt;，就只执行start，貌似是这样吧，我只粗略的看了下parseHTML，后续详细看发现错了再纠正。</span></div><div class="line">    <span class="comment">// 其实直接运行parseHTML不加options也是可以的，只不过不会返回任何的内容，是完全无意义的操作呢……╮(￣▽￣)╭</span></div><div class="line">    parseHTML(content, &#123;</div><div class="line">        start,</div><div class="line">        end</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 匹配到标签开始时的钩子，主要是对标签的属性进行处理</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">start</span> (<span class="params"></span></span></div><div class="line">        tag: string,</div><div class="line">        attrs: Array&lt;Attribute&gt;,</div><div class="line">        unary: boolean,</div><div class="line">        start: number,</div><div class="line">        end: number</div><div class="line">    ) &#123;</div><div class="line">        <span class="comment">// 根据当前解析深度进行判断</span></div><div class="line">        <span class="keyword">if</span> (depth === <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 如果当前深度是0，也就是说不是嵌套的标签，则进行处理</span></div><div class="line">            <span class="comment">// 先缓存当前块的信息</span></div><div class="line">            currentBlock = &#123;</div><div class="line">                <span class="attr">type</span>: tag,</div><div class="line">                <span class="attr">content</span>: <span class="string">''</span>,</div><div class="line">                <span class="comment">// 这里的start是用来标记标签内的内容的起点的</span></div><div class="line">                start: end,</div><div class="line">                <span class="comment">// 设置属性列表这个地方有意思，通过函数定义的flow里面可以看到arrts是个数组，这里通过数组的reduce特性直接把一个[&#123;"key","value"&#125;...]形式的数组转换为&#123;"key":"value"...&#125;形式的对象了</span></div><div class="line">                attrs: attrs.reduce(<span class="function">(<span class="params">cumulated, &#123; name, value &#125;</span>) =&gt;</span> &#123;</div><div class="line">                    cumulated[name] = value || <span class="literal">true</span></div><div class="line">                    <span class="keyword">return</span> cumulated</div><div class="line">                &#125;, <span class="built_in">Object</span>.create(<span class="literal">null</span>))</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 判断是否是特殊标签</span></div><div class="line">            <span class="keyword">if</span> (isSpecialTag(tag)) &#123;</div><div class="line">                <span class="comment">// 是特殊标签，则检查标签属性，并对特殊属性进行处理</span></div><div class="line">                checkAttrs(currentBlock, attrs)</div><div class="line">                <span class="comment">// 检查是否是style标签</span></div><div class="line">                <span class="keyword">if</span> (tag === <span class="string">'style'</span>) &#123;</div><div class="line">                    <span class="comment">// 是style标签就推进队列</span></div><div class="line">                    sfc.styles.push(currentBlock)</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 不是就直接赋值</span></div><div class="line">                    sfc[tag] = currentBlock</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 不是特殊标签，则推进自定义标签的队列</span></div><div class="line">                sfc.customBlocks.push(currentBlock)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 这个属性是根据parseHTML接收的options.isUnaryTag返回的，因为在调用parseHTML时没传，所以unary总是false</span></div><div class="line">        <span class="keyword">if</span> (!unary) &#123;</div><div class="line">            <span class="comment">// 上锁</span></div><div class="line">            depth++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 检查标签的特殊属性，以便做特殊的处理，特殊属性的使用方法貌似文档中都没有写呢，</span></div><div class="line">    <span class="comment">// 貌似这些属性都是给style标签用的，我是从https://github.com/vuejs-templates/webpack 这个项目中看到的相关例子</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkAttrs</span> (<span class="params">block: SFCBlock, attrs: Array&lt;Attribute&gt;</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attrs.length; i++) &#123;</div><div class="line">            <span class="keyword">const</span> attr = attrs[i]</div><div class="line">            <span class="comment">// 可以用lang标签设置style标签内用的预处理语法，less，sass之类的</span></div><div class="line">            <span class="keyword">if</span> (attr.name === <span class="string">'lang'</span>) &#123;</div><div class="line">                block.lang = attr.value</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果设置了scoped属性，那么这个标签就只对当前组件有作用</span></div><div class="line">            <span class="keyword">if</span> (attr.name === <span class="string">'scoped'</span>) &#123;</div><div class="line">                block.scoped = <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 没找到这个属性是干嘛使的……╮(￣▽￣)╭有可能是为了配合src来用的，module作为src的前缀，</span></div><div class="line">            <span class="comment">// 具体参考 https://github.com/vuejs-templates/webpack/blob/17351f5e3b1306a117aaa80b7d575b9aa3144866/docs/static.md#asset-resolving-rules URLs prefixed with 这一小节的说明。</span></div><div class="line">            <span class="keyword">if</span> (attr.name === <span class="string">'module'</span>) &#123;</div><div class="line">                block.module = attr.value || <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 用src属性设置内容对应的文件</span></div><div class="line">            <span class="keyword">if</span> (attr.name === <span class="string">'src'</span>) &#123;</div><div class="line">                block.src = attr.value</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 匹配到标签结束时调用的钩子，主要是对标签里的内容进行处理</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">end</span> (<span class="params">tag: string, start: number, end: number</span>) </span>&#123;</div><div class="line">        <span class="comment">// 检查锁的状态，并且标签不是不对称标签(不是&lt;tag/&gt;这样的)</span></div><div class="line">        <span class="keyword">if</span> (depth === <span class="number">1</span> &amp;&amp; currentBlock) &#123;</div><div class="line">            <span class="comment">// end标记的是标签内的内容结束的位置</span></div><div class="line">            currentBlock.end = start</div><div class="line">            <span class="comment">// 去除标签内的缩进，deindent是尤大大专门为了去除缩进开发的模块……</span></div><div class="line">            <span class="keyword">let</span> text = deindent(content.slice(currentBlock.start, currentBlock.end))</div><div class="line">            <span class="comment">// 判断是不是template标签，不是统一都要加pad，目的是在lint报错时，报错信息行数能对应上……</span></div><div class="line">            <span class="keyword">if</span> (currentBlock.type !== <span class="string">'template'</span> &amp;&amp; options.pad) &#123;</div><div class="line">                text = padContent(currentBlock) + ext</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 给content属性赋值</span></div><div class="line">            currentBlock.content = text</div><div class="line">            <span class="comment">// 至空currentBlock的引用，currentBlock其实已经保存在sfc的属性的引用上了，currentBlock其实只是个临时变量，这里充分的运用了js对象都是引用类型的特性呢……</span></div><div class="line">            currentBlock = <span class="literal">null</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 解锁</span></div><div class="line">        depth--</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 用来生成能跟.vue文件行数对应上的内容用的……用来对应lint软件或者预编译软件的报错信息的行数……</span></div><div class="line">    <span class="comment">// 话说做框架可真不容易呢，不止要实现功能，连报错信息能不能对应上都要考虑……</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">padContent</span> (<span class="params">block: SFCBlock | SFCCustomBlock</span>) </span>&#123;</div><div class="line">        <span class="comment">// 获取当前这段代码到底在多少行</span></div><div class="line">        <span class="keyword">const</span> offset = content.slice(<span class="number">0</span>, block.start).split(splitRE).length</div><div class="line">        <span class="comment">// 根据不同的块使用不同的换行……</span></div><div class="line">        <span class="keyword">const</span> padChar = block.type === <span class="string">'script'</span> &amp;&amp; !block.lang</div><div class="line">        ? <span class="string">'//\n'</span></div><div class="line">        : <span class="string">'\n'</span></div><div class="line">        <span class="comment">// 最后返回对应行数的换行</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(offset).join(padChar)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 最后返回实例</span></div><div class="line">    <span class="keyword">return</span> sfc</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>怎么说呢，虽然sfc这个模块很短，但是详细分析起来还是挺费时间的……连读带写花了我4个小时啊……总的来说作用就是将文本解析成对象，话说如果要是自己也准备写dom类文件解析的，可以参考这部分的功能呢。看完这部分我觉得比较有趣的点有：</p>
<ul>
<li>flow真是好用啊，特别是看函数的时候，有了参数类型和返回类型的标注，一下就能理解用途了，连文档都省了，这么看来typescript也没那么那接受了的说……有机会一定要在项目中实践一下</li>
<li>使用reduce把数组转成对象。这个还真是开眼了以前没见过这种方法呢，以后可以借鉴到自己开发中</li>
<li>解析dom文本的方法，话说如果自己也要写解析dom操作的话（比如要写爬虫或者写要读xml、svg之类的？），可以借鉴这部分的代码呢，因为用了钩子的形式来扩展自定义操作，所以扩展性还挺强的</li>
<li>为了对应lint报错而使用pad这种方法……怎么说呢，为了良好的开发体验作者还挺下功夫的呢，如果以后自己也要开发框架，借鉴这类细节肯定会给自己的作品大大加分的~</li>
</ul>
<p>以上就是我的感悟，那么你的感悟又是什么呢？有想法就留言告诉我吧，欢迎各路灌水拍砖~(￣▽￣)</p>
<p>好的那么由于时间不足本次的博客就到这里，话说我发觉笔记这种东西就得每天读每天写效果才更好，所以我觉得要不要就改成日更算了~所以如果不出意外的话，大概可能maybe也许明天就会更新了呢~！能不能准时更新，就全看米娜桑点赞打赏转发安利发评论的热情啦~！</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊，又到deadline了……话说因为之前一直在整理&lt;a href=&quot;/2017/03/17/vue-source-notes-1/index.html&quot;&gt;上一篇&lt;/a&gt;笔记，所以过了这么长时间一直都没怎么读新的，真是惭愧啊……那么这次就读两个简单的模块吧，把简单的解决了，后续再啃硬骨头。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码阅读笔记(1)</title>
    <link href="http://brooch.me/2017/03/17/vue-source-notes-1/"/>
    <id>http://brooch.me/2017/03/17/vue-source-notes-1/</id>
    <published>2017-03-17T08:37:50.000Z</published>
    <updated>2017-04-21T06:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实我早就开始读vue的源码了，那会儿还是1.x版本，但是因为懒没有坚持下来，现在都已经更新到2.x了……总之坚持读完吧。vue的源码还是比较好读的，因为注释清楚又有中文文档对照，所以作为读源码练手的对象非常合适。这次我读的2.20的release版本，我阅读的习惯是，不只看大概流程，会把每个函数都看一遍，学习借鉴细节。之后的笔记也会以这个思路来写，希望能给自己和看的人带来帮助吧。<br><a id="more"></a></p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>分支：master<br>commit id：2a19f911dc8631d44b7c7e63c4db57ef28ac5e69<br>版本：2.20 release</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>简单写下vue的目录结构，标注下他们都是干嘛用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">|</div><div class="line">|-- + benchmarks 基准测试，用来测性能的</div><div class="line">|-- + build 构建脚本主要都放这里</div><div class="line">|-- + dist 构建后的web端版本的输出目录</div><div class="line">|-- + examples 各种vue使用的例子</div><div class="line">|-- + flow flow的规则文件，flow是facebook出的一套检验js变量类型的框架</div><div class="line">|-- + packages 构建后server side render和weex版本的输出目录</div><div class="line">|-- + src 构建前的源码</div><div class="line">|-- + test 各种测试用例</div><div class="line">|-- + types 类型检查测试的部分，用typescript写的</div><div class="line">|-- .babelrc 转es5的配置，vue用的不是babel用的bubble</div><div class="line">|-- .eslintrc eslint的配置</div><div class="line">|-- .eslintignore eslint忽略的文件夹</div><div class="line">|-- .flowconfig flowtype的配置文件</div><div class="line">|-- BACKERS.md 捐款列表，二百五那栏还没人捐，想排前排的土豪赶紧行动吧</div><div class="line">|-- circle.yml CircleCI集成测试平台的配置文件</div><div class="line">|-- package.json 所有工作流的命令都定义在scripts里面</div><div class="line">|-- yarn.lock yarn生成的依赖文件，估计开发过程中用的yarn替换了npm</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>虽然这感觉很多余，但是对于小白来说应该很重要吧，我刚看的时候为了搞明白<a href="https://flowtype.org/" target="_blank" rel="external">flow</a>和<a href="http://www.blogjava.net/qileilove/archive/2012/07/05/382241.html" target="_blank" rel="external">benchmarks</a>是个啥多少浪费了写时间……</p>
<h2 id="打包构建"><a href="#打包构建" class="headerlink" title="打包构建"></a>打包构建</h2><p>vue是用npm的<a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="external">scripts</a>来定义工作流命令的，貌似用这种方式取代grunt、gulp已经越来越流行了呢……构建命令大体分为四类，dev、build、test、release，下面列出了所有的命令，并注释了是做啥的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="comment">//...</span></div><div class="line">    <span class="string">"scripts"</span>: &#123;</div><div class="line">        <span class="comment">/*------ develop ------*/</span></div><div class="line">        <span class="string">"dev"</span>: <span class="string">"TARGET=web-full-dev rollup -w -c build/config.js"</span>,</div><div class="line">        <span class="string">"dev:cjs"</span>: <span class="string">"TARGET=web-runtime-cjs rollup -w -c build/config.js"</span>,</div><div class="line">        <span class="string">"dev:ssr"</span>: <span class="string">"TARGET=web-server-renderer rollup -w -c build/config.js"</span>,</div><div class="line">        <span class="string">"dev:compiler"</span>: <span class="string">"TARGET=web-compiler rollup -w -c build/config.js"</span>,</div><div class="line">        <span class="string">"dev:weex"</span>: <span class="string">"TARGET=weex-framework rollup -w -c build/config.js"</span>,</div><div class="line">        <span class="string">"dev:weex:compiler"</span>: <span class="string">"TARGET=weex-compiler rollup -w -c build/config.js"</span>,</div><div class="line"></div><div class="line">        <span class="comment">/*------ build ------*/</span></div><div class="line">        <span class="string">"build"</span>: <span class="string">"node build/build.js"</span>,</div><div class="line">        <span class="string">"build:ssr"</span>: <span class="string">"npm run build -- vue.runtime.common.js,vue-server-renderer"</span>,</div><div class="line">        <span class="string">"build:weex"</span>: <span class="string">"npm run build -- weex-vue-framework,weex-template-compiler"</span>,</div><div class="line"></div><div class="line">        <span class="comment">/*------ test ------*/</span></div><div class="line">        <span class="string">"dev:test"</span>: <span class="string">"karma start build/karma.dev.config.js"</span>,</div><div class="line">        <span class="string">"test"</span>: <span class="string">"npm run lint &amp;&amp; flow check &amp;&amp; npm run test:types &amp;&amp; npm run test:cover &amp;&amp; npm run test:e2e -- --env phantomjs &amp;&amp; npm run test:ssr"</span>,</div><div class="line">        <span class="string">"test:unit"</span>: <span class="string">"karma start build/karma.unit.config.js"</span>,</div><div class="line">        <span class="comment">// 单元测试</span></div><div class="line">        <span class="string">"test:cover"</span>: <span class="string">"karma start build/karma.cover.config.js"</span>,</div><div class="line">        <span class="comment">// 覆盖率测试</span></div><div class="line">        <span class="string">"test:e2e"</span>: <span class="string">"npm run build -- vue.min.js &amp;&amp; node test/e2e/runner.js"</span>,</div><div class="line">        <span class="comment">// e2e(end to end，就是所谓的“用户真实场景”)测试</span></div><div class="line">        <span class="string">"test:weex"</span>: <span class="string">"npm run build:weex &amp;&amp; jasmine JASMINE_CONFIG_PATH=test/weex/jasmine.json"</span>,</div><div class="line">        <span class="comment">// weex 的单元测试</span></div><div class="line">        <span class="string">"test:ssr"</span>: <span class="string">"npm run build:ssr &amp;&amp; jasmine JASMINE_CONFIG_PATH=test/ssr/jasmine.json"</span>,</div><div class="line">        <span class="comment">// sever side render 的单元测试</span></div><div class="line">        <span class="string">"test:sauce"</span>: <span class="string">"npm run sauce -- 0 &amp;&amp; npm run sauce -- 1 &amp;&amp; npm run sauce -- 2"</span>,</div><div class="line">        <span class="string">"test:types"</span>: <span class="string">"tsc -p ./types/test/tsconfig.json"</span>,</div><div class="line">        <span class="comment">// 类型校验</span></div><div class="line">        <span class="string">"lint"</span>: <span class="string">"eslint src build test"</span>,</div><div class="line">        <span class="comment">// 规范校验</span></div><div class="line">        <span class="string">"flow"</span>: <span class="string">"flow check"</span>,</div><div class="line">        <span class="comment">// 类型校验</span></div><div class="line">        <span class="string">"sauce"</span>: <span class="string">"SAUCE=true karma start build/karma.sauce.config.js"</span>,</div><div class="line">        <span class="comment">// 兼容性测试</span></div><div class="line">        <span class="string">"bench:ssr"</span>: <span class="string">"npm run build:ssr &amp;&amp; NODE_ENV=production node benchmarks/ssr/renderToString.js &amp;&amp; NODE_ENV=production VUE_ENV=server node benchmarks/ssr/renderToStream.js"</span>,</div><div class="line">        <span class="comment">// 基准测试，用来测性能的</span></div><div class="line"></div><div class="line">        <span class="comment">/*------ release ------*/</span></div><div class="line">        <span class="string">"release"</span>: <span class="string">"bash build/release.sh"</span>,</div><div class="line">        <span class="string">"release:weex"</span>: <span class="string">"bash build/release-weex.sh"</span>,</div><div class="line">        <span class="string">"install:hooks"</span>: <span class="string">"ln -fs ../../build/git-hooks/pre-commit .git/hooks/pre-commit"</span></div><div class="line">    &#125;</div><div class="line"><span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>dev系列命令是开发框架的时候用的。看完所有命令之后知道了以下这些信息：</p>
<ul>
<li>dev系列命令都是 <code>TARGET=XXX rollup -w -c build/config.js</code> 的形式。可以看出vue打包用的是<a href="http://rollupjs.org/" target="_blank" rel="external">rollup</a></li>
<li>-w 是watch，-c 是指定config文件，build/config.js是rollup的配置文件。build/config.js 内部根据 TARGET 参数获取不同的构建配置。</li>
<li>话说使用自己的项目也是使用rollup打包的话，build/config.js 可以作为很好的参考或者模板呢。</li>
<li>使用的rollup插件：<ul>
<li>rollup-plugin-flow-no-whitespace<br>插件用来去掉flow使用的类型检查代码。有趣的是，插件是还是作者自己写的，只是为了想去掉打包后遗留的空格……还真是洁癖呢，噗噗……</li>
<li>rollup-plugin-buble<br>替代babel，用来转换es5用的。</li>
<li>rollup-plugin-alias<br>用来配置打包过程中各个模块的路径映射，具体的配置写在 build/alias.js 中。这样代码中就可以用src作为根目录引用模块了。值得注意的是，src/platforms 目录下的 web 模块和 weex 模块，也都做了映射，所以在看代码时有 import xxx from ‘web/xxx’的引用，就都是从 platforms 下引用的。貌似这是缩短引用路径、区分目录结构和代码逻辑的好方法呢，实际开发中也可以借鉴。</li>
</ul>
</li>
<li><p>简单查了一些rollup的资料，rollup的特性包括：</p>
<ul>
<li>打包后的代码没有 require，import的，而是直接插入到文件中</li>
<li>可以生成 AMD，CMD，UMD 甚至 ES6 模块文件</li>
<li><a href="http://www.2ality.com/2015/12/webpack-tree-shaking.html" target="_blank" rel="external">tree-shaking</a>，会移除未使用到的 ES6 exports模块，打包后的文件体积更小</li>
<li>配置简单</li>
<li>没有自带的模块机制，使用es6原生的模块依赖机制</li>
</ul>
<p>虽然webpack2也支持tree-shaking，但是从rollup的配置简单、功能单一、打包文件没有多余代码这些特点俩看，感觉很适合用来打包独立库或者框架这种都是js并且结构相对简单的项目呢。</p>
</li>
<li>相比之前，现在的dev纯粹是按照不同参数做打包并且watch了，我记得1.x版本还带webpack-dev的调试服务器来着，现在的这套比之前的轻了很多，估计打包速度也会快不少，这点和vue本身的理念也有相符吧？</li>
</ul>
<p>build系列命令用来打包所有配置。总结下看到的知识：</p>
<ul>
<li>build系列命令都是运行 build/build.js 这个文件。这个文件中的逻辑就是通过 build/config.js 获取所有的配置，然后串行用rollup打包。</li>
<li>后面的参数可以用来过滤要打包的配置，获取参数和过滤的逻辑也是写在 build/config.js 里面的。</li>
<li>如果想编写串行执行任务和获取参数做过滤一类的工作流脚本，又不想借助grunt、gulp之类的任务管理库，build/build.js 里部分的这两部分代码可以作为很好的参考。</li>
</ul>
<p>test系列命令是用来搞自动化测试的，具体的分析：</p>
<ul>
<li>测试这部分包含的内容很多，现在只是粗略的看了看。先读源码，后续再详细解读这部分的内容</li>
<li>大部分命令是做啥的我都标出来是干嘛的了，其他命令只是对其他命令的一个封装，话说包含的测试还真是全呢……</li>
<li>其实这些命令也都不是让你自己执行的，这些都是用来搞自动化测试的，自动自动化测试的命令配置在 build/ci.sh 这个脚本文件里面。这个脚本会在CircleCI的hook中被调用。话说想搞持续集成的可以参考这个配置呢。</li>
<li>同时使用了facebook的<a href="https://flowtype.org" target="_blank" rel="external">flow</a>和typescript做类型检查，在类型检查这方面真是费了牛劲了……</li>
</ul>
<p>release系列命令是用来发布rlease版本的：</p>
<ul>
<li>调用了build文件下对应的sh文件，对于windows用户还真是不友好呢哈哈哈</li>
<li>脚本里主要做了设置版本、自动化测试、构建、打tag、提交、npm推送这几件事</li>
<li>还提别为weex做了独立的发布脚本，看来还真是深度合作呢</li>
<li>其实如果团队都是用mac或者linux，或者都用开发机，可以用这套脚本作为工作流中的一个环节，自动发布提交。那句话怎么说的来着，“重复七次以上的工作都应该自动化”？大概吧……</li>
</ul>
<h2 id="源码-src"><a href="#源码-src" class="headerlink" title="源码 src"></a>源码 src</h2><p>接下来看具体源码，所有的源码都在src目录下，先看下src目录下文件的结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">|</div><div class="line">|-- + compiler 解析模板用的？</div><div class="line">|-- + core vue的核心，</div><div class="line">|-- + entries 各种入口的封装</div><div class="line">|-- + platforms 不同平台下自己独特的模块</div><div class="line">|-- + server server side render的</div><div class="line">|-- + sfc 用来将.vue文件转坏为sfc(可识别组件)对象的</div><div class="line">|-- + shared 共享的模块，一个工具集</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>刚才说到的 build/config.js 文件，里面标记了所有的打包配置，从打包配置中可以看出，所有的入口都在 src/entries 文件夹中，我阅读源码的习惯是从入口开始读。</p>
<h2 id="入口-src-entries"><a href="#入口-src-entries" class="headerlink" title="入口 src/entries"></a>入口 src/entries</h2><p>src/entries 的目录结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">|</div><div class="line">|-- web-compiler.js 只包含vue的模板解析器和.vue解析器</div><div class="line">|-- web-runtime.js 只包含vue的运行时部分的代码</div><div class="line">|-- web-runtime-with-compiler.js 这个模块既包含解析器又包含运行时</div><div class="line">|-- web-server-renderer.js server side render 用的模块，和客户端的不一样，不分解析器和运行时</div><div class="line">|-- weex-compiler.js weex的解析器</div><div class="line">|-- weex-factory.js weex的运行时</div><div class="line">|-- weex-framework.js 这个貌似是weex的框架？因为不了解weex，所以只能靠猜的了</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>具体每个文件的用途已经在上面简单的标注出来了，主要包含web端，server端，客户端(weex)三部分，下面详细解读各个文件，因为对server端和客户端并不熟悉，所以这部分只能粗浅的猜猜了……</p>
<h3 id="web-compiler-js"><a href="#web-compiler-js" class="headerlink" title="web-compiler.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/web-compiler.js" target="_blank" rel="external">web-compiler.js</a></h3><p>这个文件比较简单，就是导出了解析sfc模块和compiler模块的接口。compiler模块的作用是用来解析模板的，对应的是 src/compiler 模块，粗略的看了下是使用new Function将字符串转换为js代码，所以对于不支持或者认为这样不安全的环境，vue会给出错误提示。具体的源码后续再继续详细读。</p>
<h3 id="web-runtime-js"><a href="#web-runtime-js" class="headerlink" title="web-runtime.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/web-runtime.js" target="_blank" rel="external">web-runtime.js</a></h3><p>感觉web-runtime是对core的vue模块做了再加工</p>
<p>大概逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//...</span></div><div class="line"><span class="comment">// 添加不同平台下的功能函数，web平台下都有对应的的接口，weex平台下都是空函数</span></div><div class="line"><span class="comment">// 各函数的具体用途看到了再解释吧</span></div><div class="line">Vue.config.mustUseProp = mustUseProp</div><div class="line">Vue.config.isReservedTag = isReservedTag</div><div class="line">Vue.config.getTagNamespace = getTagNamespace</div><div class="line">Vue.config.isUnknownElement = isUnknownElement</div><div class="line"></div><div class="line"><span class="comment">// 添加不同平台下的组件和命令</span></div><div class="line">extend(Vue.options.directives, platformDirectives)</div><div class="line">extend(Vue.options.components, platformComponents)</div><div class="line"></div><div class="line"><span class="comment">// 安装虚拟dom的补丁函数，貌似只有在客户端下才会用到，服务端是没有的，另外weex也有自己的补丁函数，所以这里知识安装浏览器的patch函数</span></div><div class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</div><div class="line"></div><div class="line"><span class="comment">// 定义$mount函数，只是对核心的mountComponent方法进行了个简单的封装</span></div><div class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params">el, hydrating</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// core/instance/lifecycle模块下的mountComponent</span></div><div class="line">    <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义devtool的全局钩子(hook)</span></div><div class="line"><span class="comment">// vue有自己的chrome插件调试工具，下面这段代码就是启动调试工具的</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 判断是否配置了使用调试工具，其实就是看是不是生产版本……</span></div><div class="line">    <span class="keyword">if</span> (config.devtools) &#123;</div><div class="line">        <span class="comment">// 判断是否安装了调试工具，是通过检查全局变量window.__VUE_DEVTOOLS_GLOBAL_HOOK__来判断的</span></div><div class="line">        <span class="keyword">if</span> (devtools) &#123;</div><div class="line">            <span class="comment">// 如果有就触发调试工具的init事件，所以如果项目中使用了生产版本的vue或者没有使用vue，调试工具都不会启动的</span></div><div class="line">            devtools.emit(<span class="string">'init'</span>, Vue)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; isChrome) &#123;</div><div class="line">            <span class="comment">// 如果没有安装调试工具，并且使用的不是生产版本的vue，用的还是chrome浏览器，就提示用户下载调试工具</span></div><div class="line">            <span class="built_in">console</span>[<span class="built_in">console</span>.info ? <span class="string">'info'</span> : <span class="string">'log'</span>](</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            )</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果不是生产版本，提示用户现在使用的是开发版本，正式部署的时候用生产版本</span></div><div class="line">    <span class="comment">// config中的productionTip和devtools其实都是process.env.NODE_ENV，貌似在开发过程中应该可以配置的说</span></div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</div><div class="line">        config.productionTip !== <span class="literal">false</span> &amp;&amp;</div><div class="line">        inBrowser &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">console</span> !== <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>[<span class="built_in">console</span>.info ? <span class="string">'info'</span> : <span class="string">'log'</span>](</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment">// 最后导出Vue模块</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure>
<h3 id="web-runtime-with-compiler-js"><a href="#web-runtime-with-compiler-js" class="headerlink" title="web-runtime-with-compiler.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/web-runtime-with-compiler.js" target="_blank" rel="external">web-runtime-with-compiler.js</a></h3><p>这个文件作为一个入口，将已经整合好的compiler和runtime再一次整合封装，最终导出浏览器用的vue构造函数。</p>
<p>代码的大概逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 定义一个纯函数，之前我在mobx的文章中写过，纯函数的输入、输出都是固定的，所以可以用来做缓存</span></div><div class="line"><span class="comment">// cached函数虽然表面上看引用自core/util/index，实际是core/util/index引用了shared/util，cached定义在shared/util中</span></div><div class="line"><span class="comment">// 利用纯函数做缓存的技巧可以应用在自己的项目中，虽然定义个对象也能搞定，但是这么封装真的是很美观呀~</span></div><div class="line"><span class="keyword">const</span> idToTemplate = cached(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> el = query(id)</div><div class="line">    <span class="keyword">return</span> el &amp;&amp; el.innerHTML</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 定义了一个工具函数，看名字就知道是获取元素outerHTML的</span></div><div class="line"><span class="comment">// 之所以这么处理貌似是因为IE在取svg元素的outerHTML时有bug</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOuterHTML</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// 判断元素是否有outerHTML属性</span></div><div class="line">    <span class="keyword">if</span> (el.outerHTML) &#123;</div><div class="line">        <span class="comment">// 有就直接使outerHTML</span></div><div class="line">        <span class="keyword">return</span> el.outerHTML</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 没有就建个空div把要获取的元素赋值进去，然后取innerHTML</span></div><div class="line">        <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</div><div class="line">        container.appendChild(el.cloneNode(<span class="literal">true</span>))</div><div class="line">        <span class="keyword">return</span> container.innerHTML</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// $mount方法是用来挂载实例的</span></div><div class="line"><span class="comment">// 这里定义的$mount是对之前在web-runtime.js里定义的$mount进行封装</span></div><div class="line"><span class="comment">// 先做个临时变量保存原来的$mount</span></div><div class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</div><div class="line"><span class="comment">// 然后定义新的</span></div><div class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params">el, hydrating</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// 判断el是否body或者html</span></div><div class="line">    <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// 如果是就中断，也就是说vue是无法在dom的根节点上挂载的</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// $options当前 Vue 实例的初始化选项</span></div><div class="line">    <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</div><div class="line">    <span class="comment">// 判断$options是否有render函数</span></div><div class="line">    <span class="keyword">if</span> (!options.render) &#123;</div><div class="line">        <span class="comment">// 没有就造个render函数出来</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// 判断$options是否有template属性</span></div><div class="line">        <span class="keyword">if</span> (template) &#123;</div><div class="line">            <span class="comment">// 如果有template属性</span></div><div class="line">            <span class="comment">// 判断template属性是否是字符串</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</div><div class="line">                <span class="comment">// 如果template是字符串，则把他当做selector使用</span></div><div class="line">                <span class="comment">// 判断selector是否是唯一的(是不是id)</span></div><div class="line">                <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</div><div class="line">                    <span class="comment">// 如果selector是唯一的，则使用selector的innerHTML作为模板</span></div><div class="line">                    <span class="comment">// 并且缓存模板内容</span></div><div class="line">                    template = idToTemplate(template)</div><div class="line">                    <span class="comment">// ...</span></div><div class="line">                &#125;</div><div class="line">            <span class="comment">// 判断template属性是否是dom节点</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</div><div class="line">                <span class="comment">// 如果是dom节点则用innerHTML作为template</span></div><div class="line">                template = template.innerHTML</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// ...</span></div><div class="line">                <span class="comment">// 如果template不符合要求，则中断程序</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</div><div class="line">            <span class="comment">// 如果没有template属性 </span></div><div class="line">            <span class="comment">// 则取挂载dom节点的outerHTML作为template</span></div><div class="line">            template = getOuterHTML(el)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果经过之前的过程获取到了template</span></div><div class="line">        <span class="comment">// 则根据获取到的template生成render函数</span></div><div class="line">        <span class="keyword">if</span> (template) &#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// 根据template生成render</span></div><div class="line">            <span class="comment">// 另外在开发版本中，还会利用window.performance统计生成render的时间，分析性能，因为这部分代码不是主要代码，所以我就删掉了</span></div><div class="line">            <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</div><div class="line">                <span class="comment">// 用来标记是否需要转换换行符的，为了兼容IE的，貌似IE和其他浏览器在处理换行符时的操作不一样啊</span></div><div class="line">                shouldDecodeNewlines: shouldDecodeNewlines,</div><div class="line">                <span class="comment">// 对应 https://cn.vuejs.org/v2/api/#delimiters ，纯文本插入分隔符，可在构建时修改</span></div><div class="line">                delimiters: options.delimiters</div><div class="line">            &#125;, <span class="keyword">this</span>)</div><div class="line">            options.render = render</div><div class="line">            options.staticRenderFns = staticRenderFns</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 调用 web-runtime.js 中定义的$mount</span></div><div class="line">    <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 将解析compile模块也绑定到Vue上</span></div><div class="line">Vue.compile = compileToFunctions</div><div class="line"><span class="comment">// 导出Vue类</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure>
<h3 id="web-server-renderer-js"><a href="#web-server-renderer-js" class="headerlink" title="web-server-renderer.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/web-server-renderer.js" target="_blank" rel="external">web-server-renderer.js</a></h3><p>这个是server side render的入口，所以与brower端用到的方法差别很大。server端只是做初步的渲染，所以只有一个生成render的函数，结构比较简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 定义一个生成render对象的函数</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _createRenderer(&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 定义一个生成render函数的工厂</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> createBundleRenderer = createBundleRendererCreator(createRenderer)</div></pre></td></tr></table></figure>
<p>这部分的功能划分的很细，做了好多的高阶函数，粗略的看了下看的段点儿晕，后续看到不同平台的代码时再详细看。</p>
<h3 id="weex-compiler-js"><a href="#weex-compiler-js" class="headerlink" title="weex-compiler.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/weex-compiler.js" target="_blank" rel="external">weex-compiler.js</a></h3><p>对应web-compiler.js，导出对应平台下的compiler模块</p>
<h3 id="weex-factory-js"><a href="#weex-factory-js" class="headerlink" title="weex-factory.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/weex-factory.js" target="_blank" rel="external">weex-factory.js</a></h3><p>对应web-runtime.js，只不过这里没有添加独特的函数，直接导出的对应平台下的runtime模块</p>
<h3 id="weex-framework-js"><a href="#weex-framework-js" class="headerlink" title="weex-framework.js"></a><a href="https://github.com/vuejs/vue/blob/v2.2.0/src/entries/weex-framework.js" target="_blank" rel="external">weex-framework.js</a></h3><p>导出了weex/framework这个模块下的所有方法，貌似是给weex提供基础支持用的？具体的还没开始仔细看。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说这次记录了整个项目的入口部分的代码。通过这些入口，可以了解所有主要的模块的用途，项目的结构等等基础信息。当然，也能学习借鉴不少知识，我觉得以下这些点值得记录并应用到自己的项目中：</p>
<ul>
<li>npm script的定义规则和分类</li>
<li>flow和typescript做类型检查的方法</li>
<li>打包测试发布整套的工作流定义</li>
<li>通过封装重写的方式不断扩展接口</li>
<li>通过纯函数的特性做缓存</li>
<li>通过高阶函数拆分模块(具体模块的划分思想我还没看出来……)</li>
</ul>
<p>那么你又从这部分代码中悟到了什么呢？有想法就留言告诉我吧，咱们一起交流交流~(￣▽￣)</p>
<p>好的那么由于时间不足本次的博客就到这里，话说这次时间实在是太仓促了，而且解读源码的表达方法我也还没有探索好……我的感觉就是，虽然我都看懂了，但是却说不明白，下次会尝试着配上些流程图或者思维导图来记录，这样也更容易理解吧。</p>
<p>那么如果不出意外的话，大概可能maybe也许下周五会更新吧~！这次就不别安利了，毕竟我自己都觉得好坑啊……就这样了……</p>
<p>白了个白~！</p>
<h2 id="update-2017-03-30"><a href="#update-2017-03-30" class="headerlink" title="update 2017-03-30"></a>update 2017-03-30</h2><p>折腾了两个礼拜，终于想到一个自己比较满意的方式来做记录，把之前的文章大修了一遍，自我感觉还是不错，希望以后自己再看的时候不会觉得尴尬吧，哈哈哈……</p>
<p>另外我还发现了一个<a href="https://www.gitbook.com/book/114000/read-vue-code/details" target="_blank" rel="external">gitbook</a>，也在读vue的源码，不过他在几个月之前断更了……但是这种形式真心不错，后续我也打算用这种形式再整理一遍的说~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实我早就开始读vue的源码了，那会儿还是1.x版本，但是因为懒没有坚持下来，现在都已经更新到2.x了……总之坚持读完吧。vue的源码还是比较好读的，因为注释清楚又有中文文档对照，所以作为读源码练手的对象非常合适。这次我读的2.20的release版本，我阅读的习惯是，不只看大概流程，会把每个函数都看一遍，学习借鉴细节。之后的笔记也会以这个思路来写，希望能给自己和看的人带来帮助吧。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue" scheme="http://brooch.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>fetch 能做哪些 XHR(XMLHttpRequest) 不能做的事</title>
    <link href="http://brooch.me/2017/03/10/difference-between-fetch-and-XHR/"/>
    <id>http://brooch.me/2017/03/10/difference-between-fetch-and-XHR/</id>
    <published>2017-03-10T11:59:29.000Z</published>
    <updated>2017-03-10T16:09:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天刷微博的时候刷到了<a href="http://weibo.com/1708684567/EyzaJpJtS" target="_blank" rel="external">紫云飞的一条微博</a>，遂决定好好整理下，方便以后面试别人或者别人面我的时候装逼用~ ╮(￣▽￣)╭</p>
<a id="more"></a>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>关于 Fetch API 和 XHR 的历史、概念、方法、属性等基础知识我就不回顾了，毕竟网上一搜一大片，文档也早就有了中文翻译，想详细了解细节的就仔细读文档吧。</p>
<ul>
<li><a href="https://fetch.spec.whatwg.org" target="_blank" rel="external">Fetch API的标准</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="external">MDN的Fetch API中文文档</a></li>
<li><a href="https://xhr.spec.whatwg.org/" target="_blank" rel="external">XHR的标准</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">MDN的XHR中文文档</a></li>
</ul>
<h2 id="直奔主题"><a href="#直奔主题" class="headerlink" title="直奔主题"></a>直奔主题</h2><p>总的来说，Fetch API 和 XHR 做的事情很相似，大部分情况我们通过 XHR 就已经能够完成开发任务了。那么为什么还需要新的 Fetch API呢？个人认为 相比 XHR， Fetch API 可以做到以下三点：</p>
<h3 id="Fetch-API更加现代"><a href="#Fetch-API更加现代" class="headerlink" title="Fetch API更加现代"></a>Fetch API更加现代</h3><p>XHR 和 Fetch API 最显著的区别就是调用方式不同。这一点大家应该都知道吧。</p>
<p>举个例子，下面两端代码完成的是同一功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用 XHR 发起一个GET请求</span></div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XHMHttpRequest();</div><div class="line">xhr.open(<span class="string">'GET'</span>, url);</div><div class="line">xhr.responseType = <span class="string">'json'</span>;</div><div class="line"></div><div class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(xhr.response);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'something wrong~ ╮(￣▽￣)╭'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xhr.send();</div><div class="line"></div><div class="line"><span class="comment">// 用 Fetch 完成同样的请求</span></div><div class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> response.json();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">jsonData</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(jsonData);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'something wrong~ ╮(￣▽￣)╭'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>相比 XHR ，Fetch 结合了现代的编码模式，使用起来更简洁 ，完成工作所需的实际代码量也更少。</p>
<h3 id="Fetch-API更底层"><a href="#Fetch-API更底层" class="headerlink" title="Fetch API更底层"></a>Fetch API更底层</h3><p>其实，刚才说到的 Fetch API 并不是指仅仅一个 fetch 方法，还包括 Request、 Response、Headers、Body都一系列原生对象。对于传统的XHR而言，你必须使用它的一个实例来发出请求和处理响应。 但是通过Fetch API，我们还能够通过刚才提到的原生对象，明确的配置请求和响应。这些底层的抽象让 Fetch API 比 XHR 更灵活。</p>
<p>举个例子，现在要下载一个很大的 utf-8 格式的 txt 文件，我们通过流式的响应体而不是文本的形式读取，最后显示在一个div中。(为什么使用流、使用流有什么好处我就不做过多解释了……)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> url = <span class="string">'Test.txt'</span>;</div><div class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> progress = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> contentLength = <span class="number">0</span>;</div><div class="line"></div><div class="line">    fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">        <span class="comment">// 通过响应头获取文件大小</span></div><div class="line">        contentLength = response.headers.get(<span class="string">'Content-Length'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> pump = <span class="function"><span class="keyword">function</span>(<span class="params">reader</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> reader.read().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">                <span class="comment">// 如果流中的内容读取完毕，result.done的值会变为true</span></div><div class="line">                <span class="keyword">if</span> (!result.done) &#123;</div><div class="line">                    <span class="comment">// 获取流中的数据</span></div><div class="line">                    <span class="keyword">var</span> chunk = result.value;</div><div class="line"></div><div class="line">                    <span class="keyword">var</span> text = <span class="string">''</span>;</div><div class="line">                    <span class="comment">// 流中的数据是一串字节码，需要做转码</span></div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">3</span>; i &lt; chunk.byteLength; i++) &#123;</div><div class="line">                        text += <span class="built_in">String</span>.fromCharCode(chunk[i]);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// 添加到页面的div中</span></div><div class="line">                    div.innerHTML += text;</div><div class="line"></div><div class="line">                    <span class="comment">// 还可以用流的长度显示当前进度</span></div><div class="line">                    progress += chunk.byteLength;</div><div class="line">                    <span class="built_in">console</span>.log(((progress / contentLength) * <span class="number">100</span>) + <span class="string">'%'</span>);</div><div class="line"></div><div class="line">                    <span class="comment">// 开始读取下一个流</span></div><div class="line">                    <span class="keyword">return</span> pump(reader);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 开始读取流中的信息</span></div><div class="line">        <span class="keyword">return</span> pump(response.body.getReader());</div><div class="line">    &#125;)</div><div class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(error);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在上面的例子中，我们不止使用了流来下载文件，还通过响应头获取了响应的具体信息，显示了下载的进度。虽然使用XHR也能做到使用流来读取文件，不过现在应该只有IE浏览器支持。但是 Fetch API 提供了访问数据的实际字节的方法，而 XHR 的 responseText 只有文本形式，这意味着在某些场景下它的作用可能非常有限。</p>
<h3 id="Fetch-API更接近未来"><a href="#Fetch-API更接近未来" class="headerlink" title="Fetch API更接近未来"></a>Fetch API更接近未来</h3><p>当我们在谈论 Fetch API 时，我们在谈论的不止是这些已经胜过 XHR 的地方，更是在谈论 Fetch API未来的可能性。比如未来基于 Fetch 和 Service Worker 的缓存和请求拦截技术。由于时间关系细节就不展开了，详细的内容可以参考一下链接。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="external">使用 Service Workers</a></li>
<li><a href="http://www.alloyteam.com/2016/01/9274/" target="_blank" rel="external">Service Worker初体验</a></li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然现在很多Fetch API 的功能还是实验性的，但是虽然现代浏览器的普及，以及诸如promise、async/await等异步语法的实现，相信不久的将来，Fetch 肯定会取代 XHR吧。到时候希望这篇文章能帮助你装逼成功，哈哈~ ╮(￣▽￣)╭</p>
<p>好的那么由于时间不足本次的博客就到这里，如果不出意外的话，大概可能maybe也许下周五会更新吧~！能不能准时更新，就全看米娜桑点赞打赏转发安利发评论的热情啦~！</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天刷微博的时候刷到了&lt;a href=&quot;http://weibo.com/1708684567/EyzaJpJtS&quot;&gt;紫云飞的一条微博&lt;/a&gt;，遂决定好好整理下，方便以后面试别人或者别人面我的时候装逼用~ ╮(￣▽￣)╭&lt;/p&gt;
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="Fetch API" scheme="http://brooch.me/tags/Fetch-API/"/>
    
      <category term="XHR" scheme="http://brooch.me/tags/XHR/"/>
    
      <category term="Service Worker" scheme="http://brooch.me/tags/Service-Worker/"/>
    
  </entry>
  
  <entry>
    <title>使用rem实现响应式布局的方法</title>
    <link href="http://brooch.me/2017/03/03/a-method-of-using-rem/"/>
    <id>http://brooch.me/2017/03/03/a-method-of-using-rem/</id>
    <published>2017-03-03T13:16:05.000Z</published>
    <updated>2017-03-03T15:52:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>前两天小徒弟问我，老看到有人说用rem实现响应式布局，具体要怎么做呢？这可问住我了，之前我只知道rem的概念却不知道要怎么用rem来实现响应式布局……赶紧忽悠她一顿，让她先去各大网站上学习下别人是怎么做的，看不懂了再来问我。自己则私底下恶补了rem实现响应式布局的知识来应付她的问题，这才算糊弄过去……</p>
<p>话说，临阵磨不能白磨了不是，总结下当时搜索到的资料供大家参考，以后真被问起来嘡嘡嘡一说，就准备接受萌新崇拜的目光吧，哈哈(￣▽￣)</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在说rem之前不得不先介绍下em，em这种单位最早源自印刷界，一个em表示一种特殊字体的大写字母M的高度。后来到了网页上，em作为一种相对长度单位，相对于当前对象内文本的字体大小。没有被css设置过的网页，一般页面字体的默认大小是16px，所以1em就等于16px。当然em除了可以作为font-size属性值得单位，还能作为width和height属性值的单位。于是前端工程师们就脑洞大开了，如果所有的宽高单位都用em，那么在做响应式布局的时候，只要改变页面上的字体大小不就能直接调整页面各个部分的大小了吗？</p>
<p>但是事与愿违，em是针对当前对象内文本的，就是说针对的是被设置过字体大小的元素的字体大小。有点绕是不是？举个例子好了，比如现在又这样一个结构，body&gt;div.A&gt;div.B，body的font-size是20px，div.B的width和height都是1em，所以当前页面上div.B的宽高就是20px，这时候如果div.A被设置了font-size为10px，div.B的宽高就是10px了，这个特性让em非常不好被应用，要用em就整个页面所有的font-size都要用em，这在没有node做自动化工具的年代简直是异常噩梦……你想写个页面，还得不停的换算px和em，想想就头疼……</p>
<p>后来rem出现了，其实rem就是root em，故名思意，rem单位就是相对于根节点（html元素）字体大小的单位。这个单位跟em不一样的区别也在这里，他是不受继承影响的，这样就可以各种单位混用，回避了不停换算的问题。当然要想使用换算的过程还是不能少，不过只是根据根节点的字体大小换算，列个换算表需要的时候查表就好了，当然这个问题在有了前端打包工具之后就彻底解决了，咱们后面再具体说。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>理解了rem的概念，揭下来说说利用rem实现响应式布局的方案。一般响应式布局分两种：</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>使用rem定义想要响应式的部分的宽高，使用媒体查询来修改html元素的font-size属性</p>
<p>简单举个例子：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>:<span class="number">16px</span>;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">480px</span>) &#123;</div><div class="line">    <span class="selector-tag">html</span> &#123;</div><div class="line">        <span class="attribute">font-size</span>:<span class="number">14px</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">960px</span>) &#123;</div><div class="line">    <span class="selector-tag">html</span> &#123;</div><div class="line">        <span class="attribute">font-size</span>:<span class="number">15px</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.some-class</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">10rem</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">10rem</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>使用rem定义想要响应式的部分的宽高，在页面resize时动态的改变html的font-size属性。</p>
<p>这个方案也是我觉得比较有趣的一个方案，他可以保证窗口大小在变化时，真个页面也等比例缩放。目前淘宝和饿了么使用的就是这个方案。</p>
<p>本来还想抄一段淘宝计算html元素font-size大小的代码，后来一搜发下阿里无线团队已经把脚本开源了，附上地址好了：<a href="https://github.com/amfe/lib-flexible/" target="_blank" rel="external">lib-flexible</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>除了以上两种方案，其他把root的font-size设死，又使用rem做单位的方案我就真不能理解了……貌似没什么意义吧？希望能白话的同学给我套靠谱的解释，这样以后别人喷我的时候我也好一嘟噜一串儿的喷回去……(￣▽￣)”</p>
<h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>刚才提到了，在使用rem的时候不得不对rem和px做转换。我个人是信奉“一切重复工作都应该交给电脑去做”这一理念的，所以我觉得转换的工作也应该交给电脑去做才对。其实前人早的轮子也已经很多了，这件事less、sass、postcss、stylus等预处理器都支持，也可以用<a href="https://www.npmjs.com/package/px2rem" target="_blank" rel="external">px2rem</a>这个npm模块，使用webpack的也有对应的loader可用<a href="https://www.npmjs.com/package/px2rem-loader" target="_blank" rel="external">px2rem-loader </a>。所以根本不用操心重复劳动的事，某种意义上来说，只要你够勤快，就根本累不着~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在查资料的过程中，也发现有人在说，字体大小自适应是一种错误的想法，因为就算是响应式布局，其实也没必要做到这一步……使用媒体查询、calc、vw单位、flex一样能够完成一个体验优秀的页面。在这件事上，我觉得还是仁者见仁吧，虽然rem实现响应式布局的感觉都有些hack，但是肯定还是有他存在的意义的，屠龙之技学会了，砍谁不是砍不是？何况有的时候，咱们程序员说了真不算，到底要不要做到完全等比例缩放这一步，还是得听产品经理的……毕竟产品小白分分钟就能让技术大牛加班啊~哈哈哈ｂ（￣▽￣）ｄ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;前两天小徒弟问我，老看到有人说用rem实现响应式布局，具体要怎么做呢？这可问住我了，之前我只知道rem的概念却不知道要怎么用rem来实现响应式布局……赶紧忽悠她一顿，让她先去各大网站上学习下别人是怎么做的，看不懂了再来问我。自己则私底下恶补了rem实现响应式布局的知识来应付她的问题，这才算糊弄过去……&lt;/p&gt;
&lt;p&gt;话说，临阵磨不能白磨了不是，总结下当时搜索到的资料供大家参考，以后真被问起来嘡嘡嘡一说，就准备接受萌新崇拜的目光吧，哈哈(￣▽￣)&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="css" scheme="http://brooch.me/tags/css/"/>
    
      <category term="rem" scheme="http://brooch.me/tags/rem/"/>
    
  </entry>
  
  <entry>
    <title>聊聊动态规划(2) -- 特征</title>
    <link href="http://brooch.me/2017/02/24/dynamic-programming-2/"/>
    <id>http://brooch.me/2017/02/24/dynamic-programming-2/</id>
    <published>2017-02-24T06:29:00.000Z</published>
    <updated>2017-02-24T15:26:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>书接前文，上回咱们说到要如何鉴别动态规划可解问题。我预告说要从计算机工作原理开始讲起……呃……貌似跟原本要讲的东西差的有点儿远呢……那么为啥非要从这么底层的问题开始讲起呢？怎么说呢……就好比我要讲西游记，如果只说一句“唐僧师徒四人去西天取经然后都修成正果了”，对于没看过西游记的人来说，唐僧是谁、师徒四人又是谁、为啥非得跑西天去取经等等一系列问题，不去翻翻原著搜搜资料是肯定不知道怎么回事的。所以还是尽量揉碎了讲吧，不然看完了还得一通翻查资料，怪麻烦的……</p>
<a id="more"></a>
<p>尽管计算机技术自20世纪40年代第一部电子通用计算机诞生以来一直飞速的发展，但是，现代计算机仍然采用冯诺依曼结构来实现。冯诺依曼结构将计算机描述为五部分：输入设备、控制器、运算器、存储器和输出设备。工作流程大概就是，输入设备传入数据，控制器发出指令，运算器根据指令做算数逻辑运算，最后存储或者输出结果。如果咱们只关注计算机的理论原理，在抽象一点的看计算机工作的整个过程，你会发现，刚才我们描述的工作过程可以用数学理论来概括。存储器可以看做一个列举了计算机存在的所有可能状态的<strong>集合</strong>，控制器指令可以看做一组<strong>状态转换函数</strong>，运算器使用状态转换函数，从输入的状态和集合的状态，推导出输出的状态。所以计算机的工作原理，可以简单的概括为，利用当前的状态计算出下一个状态（美错儿，我就是在说状态机……）。</p>
<p>我们平时编写程序，是在使用计算机帮我们解决问题。从计算机的本质是状态机这个角度来看，你思考如何编写程序来解决问题，其实就是在思考如何将这个问题表达成状态（用哪些变量，存储哪些数据）以及如何在状态之间中转换（怎样根据一些变量计算出另一些变量）。我们在看算法分析文章时，经常能看到的平时能看到的所谓<strong>空间复杂度</strong>，就是为了支持你的转换状态所必需存储的状态最多有多少；所谓<strong>时间复杂度</strong>，就是从初始状态到达最终状态中间需要做多少次状态转换。</p>
<p>还拿我们上一次说的斐波拉契数列做🌰 ：</p>
<p>我要计算第100项，之前的每一项就是这个问题的一个状态。每求新一项（新的一个状态）只需要之前的两个项（之前的两个状态）。所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；每求一个新状态，所需要的时间是常数，而之前的状态是线性递增的，所以时间复杂度就是线性的。</p>
<p>上面这种状态计算很直接，只需要依照固定的模式从旧状态计算出新状态就行（a[i]=a[i-1]+a[i-2]），不需要考虑是不是需要更多的状态，也不需要选择哪些旧状态来计算新状态。对于这样的解法，我们叫递推。</p>
<p>斐波拉契数列这个例子过于简单，以至于让人忽视了阶段的概念。所谓阶段是指随着问题的解决，在同一个时刻可能会得到的不同状态的集合。斐波拉契数列中，每一步会计算得到一个新数字，所以每个阶段只有一个状态。咱们来想象另外一个情景：假如把你放在一个围棋棋盘上的某一点，你每一步只能走一格，因为你可以东南西北随便走，所以你当你同样走四步可能会处于很多个不同的位置。从头开始走了几步就是第几个阶段，走了n步可能处于的位置称为一个状态，走了这n步所有可能到达的位置的集合就是这个阶段下所有可能的状态。</p>
<p>现在问题来了，有了阶段之后，计算新状态可能会遇到各种奇葩的情况，针对不同的情况，就需要不同的算法，下面就分情况来说明一下：</p>
<p>假如问题有n个阶段，每个阶段都有多个状态，不同阶段的状态数不必相同，一个阶段的一个状态可以得到下个阶段的所有状态中的几个。那我们要计算出最终阶段的状态数自然要经历之前每个阶段的某些状态。</p>
<p>好消息是，有时候我们并不需要真的计算所有状态。</p>
<p>比如拿这样一个的棋盘问题举例：</p>
<p>从棋盘的左上角到达右下角最短需要几步。答案很显然，用这样一个简单的问题是为了帮助我们理解阶段和状态。某个阶段确实可以有多个状态，正如这个问题中走n步可以走到很多位置一样。但是同样n步中，有哪些位置可以让我们在第n+1步中走的最远呢？没错，正是第n步中走的最远的位置。换成一句熟悉话叫做“<strong>下一步最优是从当前最优得到的</strong>”。所以为了计算最终的最优值，只需要存储每一步的最优值即可，解决符合这种性质的问题的算法就叫贪心算法。如果只看最优状态之间的计算过程是不是和斐波拉契数列的计算很像？所以计算的方法也是递推。</p>
<p>既然问题都是可以划分成阶段和状态的。这样一来我们一下子解决了一大类问题：一个阶段的最优可以由前一个阶段的最优得到。</p>
<p>如果一个阶段的最优无法用前一个阶段的最优得到呢？（需要前两个阶段得到当前最优，跟只用前一个阶段并没有本质区别）</p>
<p>最麻烦的情况在于你需要之前所有的情况才行。再举一个探索迷宫的🌰 ：</p>
<p>现在有一个迷宫，我们要计算从起点到终点的最短路线。这时你就不能只保存当前阶段的状态了，因为要求你计算最短路径，所以你必须知道之前走过的所有位置。因为即便你当前在的位置不变，之前的路线不同也会影响你之后走的路线。这时你需要保存的是之前每个阶段所经历的状态，根据之前所有的状态你才能计算出下一个状态！每个阶段的状态或许不多，但是每个状态都可以转移到下一阶段的多个状态，这种记录所有状态计算下一个状态的算法就叫搜索。所以搜索的空间复杂度就是指数级的，时间复杂度也是指数的。</p>
<p>刚才提到的那种令人不开心的情况，就叫做有后效性。</p>
<p>刚刚的情况实在太普遍，我们刚刚说到的解决方法也实在太暴力。那么，有没有哪些情况可以避免如此的暴力呢？契机就在于后效性。</p>
<p>有这么一类问题，看似需要之前所有的状态，其实不用。比如求<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97" target="_blank" rel="external">最长上升子序列（LIS）</a>长度问题：</p>
<p>在一个无序的数组里，找出一组尽可能长的由低到高排列的数，这组数就叫最长上升子序列。</p>
<p>比如，给出[5,4,1,2,3]，LIS 就是 [1,2,3]，长度是3；给出[4,2,4,5,3,7]，LIS 是 [2,4,5,7]，长度是 4。</p>
<p>看到这个问题，第一反应就是用遍历去解决。从头到尾依次枚举是否选择当前的数字，每选定一个数字就要去看看是不是满足“上升”的性质，这里第i个阶段就是去思考是否要选择第i个数，第i个阶段有两个状态，分别是选和不选。哈哈，依稀出现了刚刚搜索迷宫的影子！</p>
<p>但是当我们仔细思考之后会发现，每次当我决定要选择当前数字的时候，只需要和之前选定的一个数字比较，就能做出判断了！这是和之前迷宫问题的本质不同。这样我们就不需要记录之前所有的状态了。因为最后要求的是序列长度，所以我们只需要记录以某个元素结尾的LIS长度就好。</p>
<p>这种“每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到”的性质就叫做最优子结构；而“不管状态之前是如何得到的”的性质就叫做无后效性。</p>
<p>那么，终于可以说出动态规划问题的两个特点了，这两个特点就是<strong>最优子结构</strong>和<strong>无后效性</strong>！只要有这两个特点的问题，就可以用动态规划的方法来解决了。</p>
<p>通过之前的一系列描述我们也能看到，一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间的状态转移方式决定的！</p>
<ul>
<li>每个阶段只有一个状态 —— 用递推。</li>
<li>每个阶段的最优状态都是由上一个阶段的最优状态得到 —— 用贪心。</li>
<li>每个阶段的最优状态是由之前所有阶段的状态的组合得到 —— 用搜索。</li>
<li>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的 —— 用动态规划。</li>
</ul>
<p>另外需要注意的是，一个问题从不同的角度分析，各阶段状态的定义和状态转移方式可能都不相同，存在一个有后效性的定义，并不代表该问题不适用动态规划的方法来解。就像我最早说过的一样：寻找看问题的角度，才是动态规划的核心~</p>
<p>好的那么由于时间不足本次的博客就到这里，如果不出意外的话，大概可能maybe也许下周五会更新吧~！能不能准时更新，就全看米娜桑点赞打赏转发安利发评论的热情啦~！</p>
<p>白了个白~！</p>
<p><strong>相关资料</strong></p>
<ul>
<li><a href="https://www.zhihu.com/question/23995189" target="_blank" rel="external">什么是动态规划？动态规划的意义是什？</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书接前文，上回咱们说到要如何鉴别动态规划可解问题。我预告说要从计算机工作原理开始讲起……呃……貌似跟原本要讲的东西差的有点儿远呢……那么为啥非要从这么底层的问题开始讲起呢？怎么说呢……就好比我要讲西游记，如果只说一句“唐僧师徒四人去西天取经然后都修成正果了”，对于没看过西游记的人来说，唐僧是谁、师徒四人又是谁、为啥非得跑西天去取经等等一系列问题，不去翻翻原著搜搜资料是肯定不知道怎么回事的。所以还是尽量揉碎了讲吧，不然看完了还得一通翻查资料，怪麻烦的……&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="动态规划" scheme="http://brooch.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>聊聊动态规划(1) -- 概念</title>
    <link href="http://brooch.me/2017/02/17/dynamic-programming-1/"/>
    <id>http://brooch.me/2017/02/17/dynamic-programming-1/</id>
    <published>2017-02-17T02:58:00.000Z</published>
    <updated>2017-02-24T06:43:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前某天面试了个年轻的工程师，习惯性的问了几个简单的算法题，冒泡排序二分查找之类的。他没有答上来，解释道这些平时开发中根本不会用到，就算需要，各种开源框架也都封装的烂大街了，根本不用自己写。</p>
<p>听他这么说着，仿佛看到了几年前的自己。当时我也觉得不用了解算法知识，知道冒泡快排能应付面试就得了。前端面向的是界面及交互实现，除非你填游戏或者富文本的坑，不然哪儿用的上什么算法。真需要了，上网搜呗。Max Howell 连个<a href="http://www.lintcode.com/zh-cn/problem/invert-binary-tree/" target="_blank" rel="external">翻转二叉树</a>都不会，不也照样把 Homebrew 做出来了吗。</p>
<a id="more"></a>
<p>直到我听了一次之前的领导的分享。他在分享中介绍，面试中考察算法知识，并不是想看你背了多少题，而是想考察你解决复杂问题的能力。算法能力体现的不只是知识储备，还能体现一个人的聪明才智。</p>
<p>听完之后我茅厕顿开。我的理解是，所谓的算法，其实就是你解决问题的方法。所以就算你不知道最佳答案，用你知道的知识解决问题，也算是一种算法。比如你要去个地方，可以坐公交坐地铁，你都不知道怎么坐，走过去也算是一种算法。算法题也并不是跟实际开发没有关联。就好比 “水池能装100L水，进水管每分钟进水10L，出水管每分钟出水5L，多长时间水池能满？” 这种傻逼的问题，如果改成 “一个驴牌的包包1万，你一个月挣5000，花2000，多长时间能买的起？” 不就有了实际的意义了吗……话说我还真是喜欢打比方的(￣▽￣)……</p>
<p>那么，怎么才算真正具备一定算法能力，入了算法的门儿了呢？显然只会个排序肯定是不行的……当然我并不是说排序算法就简单，各种排序算法优化啥的我觉得也挺难的……我个人觉得，在各种常见的算法中，动态规划应该算是一道坎儿，过去了就算入门儿了。winter大神也<a href="http://weibo.com/1196343093/EqtTv7Nlm" target="_blank" rel="external">说过</a>，写出动态规划，再谈算法。</p>
<p>那么动态规划到底是什么呢？</p>
<p>动态规划(dynamic programming)是求解多阶段决策过程(multistep decision process)最优化的数学方法。</p>
<p>第一次听到这个定义的时候我脑子里只有 “说人话” 这三个字……ok，让我们来仔细掰吃掰吃。</p>
<p>仔细观察发现，这个定义可以拆分成以下两部分：</p>
<ol>
<li>动态规划用来求解问题的最优化方案的</li>
<li>问题表现为多阶段决策过程</li>
</ol>
<p>最优化方案比较好理解。所谓多阶段决策，是将决策问题的全过程恰当地划分为若干个相互联系的子过程（每个子过程为一个阶段），以便按照一定的次序去求解。也就是说，一个大的问题可以被划分为若干个相互联系的子问题。这种相互联系的子问题，又叫交叠子问题。举个例子来说明交叠子问题，以<a href="http://baike.baidu.com/link?url=0EtGUr1kes840H550BpbqXbjVrUn1GmVu3HBIqrz1aFM6MI7p3NPNYNNvmYTb1nxA7LS3w9zeh5C6OcpLclmpvdg-RLJ5MIEKKe1vD3xgRAO9PE1HMkiJ2LjDGsLjxa7QiTj15vcw7yvUBpJOREm7K" target="_blank" rel="external">斐波拉契(Fibonacci)数列</a>为例，计算第100项的时候，需要计算第99项和98项；在计算第101项的时候，需要第100项和第99项，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。上述的需要再次计算的“第99项”，就叫交叠子问题。</p>
<p>在理解了上面每个学术名词的概念以后，可以得出一个结论，所谓动态规划，就是对于<b><i>某一类问题</i></b>的解决方法……呃……可能会有人觉得这是废话，但其实我们正在一步步接近问题的核心。个人觉得，动态规划的重点就在于如何鉴定“某一类问题”是动态规划可解的，而不是纠结用什么解决方法。因为用什么解决方法，取决于你从什么角度观察问题，拆分子问题。寻找看问题的角度，才是动态规划的核心。</p>
<p>那么，如何鉴定动态规划可解的问题呢？这会是一个 long long story……所以，咱们下期再讲~~(￣▽￣)~~！！！</p>
<p>好的那么由于时间不足本次的博客就到这里，简单预告一下，下期博客会从计算机是怎么工作的说起了……</p>
<p>如果不出意外的话，大概可能maybe也许下周五会更新吧~！能不能准时更新，就全看米娜桑点赞打赏转发安利发评论的热情啦~！</p>
<p>白了个白~！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前某天面试了个年轻的工程师，习惯性的问了几个简单的算法题，冒泡排序二分查找之类的。他没有答上来，解释道这些平时开发中根本不会用到，就算需要，各种开源框架也都封装的烂大街了，根本不用自己写。&lt;/p&gt;
&lt;p&gt;听他这么说着，仿佛看到了几年前的自己。当时我也觉得不用了解算法知识，知道冒泡快排能应付面试就得了。前端面向的是界面及交互实现，除非你填游戏或者富文本的坑，不然哪儿用的上什么算法。真需要了，上网搜呗。Max Howell 连个&lt;a href=&quot;http://www.lintcode.com/zh-cn/problem/invert-binary-tree/&quot;&gt;翻转二叉树&lt;/a&gt;都不会，不也照样把 Homebrew 做出来了吗。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="动态规划" scheme="http://brooch.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>年终奖避税程序优化</title>
    <link href="http://brooch.me/2017/02/03/javascript-year-bonus-evade-tax-2/"/>
    <id>http://brooch.me/2017/02/03/javascript-year-bonus-evade-tax-2/</id>
    <published>2017-02-03T06:10:25.000Z</published>
    <updated>2017-02-04T03:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>春节前写了个<a href="/2017/01/24/javascript-year-bonus-evade-tax/">年终奖避税的程序</a>。但是之前的实现上效率有点儿低，这次的博客就写一写如何优化这个程序好了（<s>其实是快到deadline才想起来要写博客临时抓的题目……</s>）</p>
<a id="more"></a>
<p>针对这个年终奖避税的程序，优化的主要方向是降低程序运行的速度。之前的实现，最耗时的是<code>getOneMonthBonus</code>和<code>getTwoMonthBonus</code>中的循环。这是在使用穷举搜索最低纳税点。针对穷举的优化，我了解的比较通用的优化方法，一种是增加缓存，一种是对穷举进行剪枝。</p>
<p>经过观察发现，拆分年终奖不可能把年终奖的50%以上拆到工资里，因为年终奖是用商数来确定交税比例的，确定比例所用的表相当于月薪减去起征点。这样我们就减少了一半的计算量。还有，我们还可以用一个对象来存储计算过的拆分方案，如果遇到相同的情况就直接使用对象里面的结果就可以了。</p>
<p>其实在编写其他程序的时候，这两种也是最简单有效的优化方法。概括的说，就是拿空间换时间和减少计算量……</p>
<p>ok，最后放上优化后的程序，这一期的瞎扯就这么愉快的结束了，咱们下期再见~！\（￣︶￣）/</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> baseQuota = <span class="number">3500</span>;</div><div class="line"><span class="keyword">var</span> taxQuota = [<span class="number">1500</span>, <span class="number">4500</span>, <span class="number">9000</span>, <span class="number">35000</span>, <span class="number">55000</span>, <span class="number">80000</span>];</div><div class="line"><span class="keyword">var</span> taxRat = [<span class="number">0.03</span>, <span class="number">0.10</span>, <span class="number">0.20</span>, <span class="number">0.25</span>, <span class="number">0.30</span>, <span class="number">0.35</span>, <span class="number">0.45</span>];</div><div class="line"><span class="keyword">var</span> taxQuick = [<span class="number">0</span>, <span class="number">105</span>, <span class="number">555</span>, <span class="number">1005</span>, <span class="number">2755</span>, <span class="number">5505</span>, <span class="number">13505</span>];</div><div class="line"><span class="keyword">var</span> cacheGetOnlyBonusTax = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> cacheGetOneMonthBonus = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> cacheGetTwoMonthBonus = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 获取不拆分年奖交税总额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOnlyBonusTax</span>(<span class="params">yearBonus, monthSalary</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> cached = cacheGetOnlyBonusTax[yearBonus + <span class="string">','</span> + monthSalary]</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> cached != <span class="string">'undefined'</span>) &#123;</div><div class="line">		<span class="keyword">return</span> cached;</div><div class="line">	&#125;</div><div class="line">    <span class="keyword">var</span> tax = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (monthSalary &gt; baseQuota) &#123;</div><div class="line">        perMonth = yearBonus / <span class="number">12</span>;</div><div class="line">        tax = round(yearBonus * getTaxRat(perMonth) - getTaxQuick(perMonth), <span class="number">2</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (yearBonus &lt; baseQuota - monthSalary) &#123;</div><div class="line">            tax = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            perMonth = (yearBonus - (baseQuota - monthSalary)) / <span class="number">10</span>;</div><div class="line">            tax = (yearBonus - (baseQuota - monthSalary)) * getTaxRat(perMonth) - getTaxQuick(perMonth);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	cacheGetOnlyBonusTax[yearBonus + <span class="string">','</span> + monthSalary] = tax</div><div class="line">    <span class="keyword">return</span> tax;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取税率等级</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaxNum</span>(<span class="params">money</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = taxQuota.length; i &lt; l; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (money &lt;= taxQuota[i]) &#123;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取税率</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaxRat</span>(<span class="params">money</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> taxRat[getTaxNum(money)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取速算扣除数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaxQuick</span>(<span class="params">money</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> taxQuick[getTaxNum(money)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取平常月交税金额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMonthTax</span>(<span class="params">money</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (money &gt; baseQuota) &#123;</div><div class="line">        <span class="keyword">return</span> getTax(money - baseQuota);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取年奖平均月交税金额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPerMonthTax</span>(<span class="params">money</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getTax(money);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算个人所得税金额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTax</span>(<span class="params">money</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> round(money * getTaxRat(money) - getTaxQuick(money), <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算增加的交税金额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMonthTaxAdd</span>(<span class="params">monthSalary, addNum</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> monthAddSalary = monthSalary + addNum;</div><div class="line">    monthTaxAdd = round(getMonthTax(monthAddSalary) - getMonthTax(monthSalary), <span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> monthTaxAdd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算金额小数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">round</span>(<span class="params">num, toFix</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">parseFloat</span>(num.toFixed(toFix), <span class="number">10</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取拆分为一个月交税总额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOneMonthBonus</span>(<span class="params">yearBonus, monthSalary</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> cached = cacheGetOneMonthBonus[yearBonus + <span class="string">','</span> + monthSalary]</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> cached != <span class="string">'undefined'</span>) &#123;</div><div class="line">		<span class="keyword">return</span> cached</div><div class="line">	&#125;</div><div class="line">    <span class="keyword">var</span> nowBonusTax = getOnlyBonusTax(yearBonus, monthSalary);</div><div class="line">	<span class="keyword">var</span> halfBonus = round(yearBonus/<span class="number">2</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; halfBonus; i++) &#123;</div><div class="line">        <span class="keyword">var</span> bonusRemain = yearBonus - i;</div><div class="line">        <span class="keyword">var</span> monthTaxAdd = getMonthTaxAdd(monthSalary, i);</div><div class="line">        <span class="keyword">var</span> bonusTax = round(getOnlyBonusTax(bonusRemain, monthSalary) + monthTaxAdd, <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (bonusTax &lt; nowBonusTax) &#123;</div><div class="line">            nowBonusTax = bonusTax;</div><div class="line">            oneMonth = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="keyword">var</span> result = &#123;</div><div class="line">		<span class="attr">tax</span>: nowBonusTax,</div><div class="line">		<span class="attr">bonus</span>: i</div><div class="line">	&#125;;</div><div class="line">	cacheGetOneMonthBonus[yearBonus + <span class="string">','</span> + monthSalary] = result;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取拆分为两个月交税总额</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTwoMonthBonus</span>(<span class="params">yearBonus, monthSalary</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> cached = cacheGetTwoMonthBonus[yearBonus + <span class="string">','</span> + monthSalary]</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> cached != <span class="string">'undefined'</span>) &#123;</div><div class="line">		<span class="keyword">return</span> cached</div><div class="line">	&#125;</div><div class="line">    <span class="keyword">var</span> nowBonusTax = getOnlyBonusTax(yearBonus, monthSalary);</div><div class="line">	<span class="keyword">var</span> halfBonus = round(yearBonus/<span class="number">2</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; halfBonus; i++) &#123;</div><div class="line">        <span class="keyword">var</span> bonusRemain = yearBonus - i;</div><div class="line">        <span class="keyword">var</span> monthTaxAdd = getMonthTaxAdd(monthSalary, (i / <span class="number">2</span>)) * <span class="number">2</span>;</div><div class="line">        <span class="keyword">var</span> bonusTax = round(getOnlyBonusTax(bonusRemain, monthSalary) + monthTaxAdd, <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (bonusTax &lt; nowBonusTax) &#123;</div><div class="line">            nowBonusTax = bonusTax;</div><div class="line">            twoMonth = i / <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="keyword">var</span> result = &#123;</div><div class="line">		<span class="attr">tax</span>: nowBonusTax,</div><div class="line">		<span class="attr">bonus</span>: i</div><div class="line">	&#125;;</div><div class="line">	cacheGetTwoMonthBonus[yearBonus + <span class="string">','</span> + monthSalary] = result</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">yearBonus, monthSalary</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> startTime = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</div><div class="line">    <span class="keyword">var</span> yearBonusTax = getOnlyBonusTax(yearBonus, monthSalary);</div><div class="line">    <span class="keyword">var</span> oneMonthTax = getOneMonthBonus(yearBonus, monthSalary);</div><div class="line">    <span class="keyword">var</span> twoMonthTax = getTwoMonthBonus(yearBonus, monthSalary);</div><div class="line">    <span class="keyword">var</span> minTax = <span class="built_in">Math</span>.min(yearBonusTax, oneMonthTax.tax, twoMonthTax.tax);</div><div class="line">    <span class="keyword">var</span> bonusRemain = yearBonus - minTax;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (minTax == yearBonusTax) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'年终奖发放：'</span> + yearBonus, <span class="string">'第一个月发放：'</span> + <span class="number">0</span>, <span class="string">'第二个月发放：'</span> + <span class="number">0</span>, <span class="string">'实际收入：'</span> + bonusRemain);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minTax == oneMonthTax.tax) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'年终奖发放：'</span> + (yearBonus - oneMonthTax.bonus), <span class="string">'第一个月发放：'</span> + oneMonthTax.bonus, <span class="string">'第二个月发放：'</span> + <span class="number">0</span>, <span class="string">'实际收入：'</span> + bonusRemain);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minTax == twoMonthTax.tax) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'年终奖发放：'</span> + (yearBonus - (twoMonthTax.bonus * <span class="number">2</span>)), <span class="string">'第一个月发放：'</span> + twoMonthTax.bonus, <span class="string">'第一个月发放：'</span> + twoMonthTax.bonus, <span class="string">'实际收入：'</span> + bonusRemain);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> endTime = (<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'耗时：'</span> + (endTime - startTime) + <span class="string">'ms'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">run(<span class="number">19000</span>, <span class="number">9500</span>);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;春节前写了个&lt;a href=&quot;/2017/01/24/javascript-year-bonus-evade-tax/&quot;&gt;年终奖避税的程序&lt;/a&gt;。但是之前的实现上效率有点儿低，这次的博客就写一写如何优化这个程序好了（&lt;s&gt;其实是快到deadline才想起来要写博客临时抓的题目……&lt;/s&gt;）&lt;/p&gt;
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="年终奖" scheme="http://brooch.me/tags/%E5%B9%B4%E7%BB%88%E5%A5%96/"/>
    
      <category term="避税" scheme="http://brooch.me/tags/%E9%81%BF%E7%A8%8E/"/>
    
  </entry>
  
</feed>
