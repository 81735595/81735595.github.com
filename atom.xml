<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep Walking</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://brooch.me/"/>
  <updated>2017-01-13T14:26:17.000Z</updated>
  <id>http://brooch.me/</id>
  
  <author>
    <name>投身烈火</name>
    <email>81735595@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入mobx原理</title>
    <link href="http://brooch.me/2017/01/13/an-in-depthexplanation-of-mobx/"/>
    <id>http://brooch.me/2017/01/13/an-in-depthexplanation-of-mobx/</id>
    <published>2017-01-13T13:53:00.000Z</published>
    <updated>2017-01-13T14:26:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章翻译自mobx作者 Michel Weststrate 的一篇博客，虽然我也想做到信达雅，奈何英语水平有限……所以其中掺杂了很多我自己的理解。想了解细节的话可移步<a href="https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.2lcdbiz5f" target="_blank" rel="external">原文</a></p>
</blockquote>
<p>看过我之前的博客的看官都知道，mobx的除了能实现响应式的功能，它的运行速度还很快，那么，他是如何做到的呢？我们一起来看看mobx的内部运行机制。</p>
<a id="more"></a>
<p>首先，让我们来回顾一下mobx的核心概念：</p>
<ol>
<li><p><strong>可观测状态</strong></p>
<p>状态是指任何可以改变并且会引发计算属性变化的值。mobx可以把大多数类型的值(基础类型、数组、各种对象)，都转化成可观测的。而且针对，数组或对象等的结构化的数据类型，这种转化是递归的，数组或对象的所有子节点都会被转化。</p>
</li>
<li><p><strong>计算属性</strong></p>
<p>计算属性是一个函数。这个函数不接收参数，只单纯的依赖的其他可观测状态。依赖的可观测状态发生变化，它的运行结果才会发生变化。</p>
<p>虽然和定义有一定出入，但是从输入输出保持一致这点来看，计算属性应该算是一种纯函数。</p>
<p>很多场景都能用到计算属性，比如字符串的连接，或者生成复杂结构的对象。因为计算属性自身也是可观测的，所以甚至可以使用它从可观测状态导出完整的用户界面。计算属性还可以在惰性和活跃两种状态之间切换。</p>
</li>
<li><p><strong>反应</strong></p>
<p>反应和计算属性有点类似，不同点在于，计算属性的函数是产生一个新的值，而反应是产生一个副作用。所谓副作用，就是指一些跟计算无关的动作，比如打印日志，网络请求，更新界面之类的。总之使用反应可以把数据变化和其他流程关联起来。</p>
</li>
<li><p><strong>动作</strong></p>
<p>动作是修改状态的主要方法。动作本身并不对状态更改做响应，而是修改可观测状态。（如用户触发的事件、web-socket传入消息、或直接对可观测状态的修改）</p>
</li>
</ol>
<p>这四个核心概念对应mobx中最常用的4个api，observable、computed、reaction（autorun）、action。</p>
<p>之后，我们把计算属性和反应都称为<strong>派生</strong>。</p>
<p>上面的解释可能有点儿不好理解，那我把它说的更形象一些：</p>
<p>execl都用过吧？<strong>可观测状态</strong> 就是里面的单元格。<strong>计算属性</strong> 就是里面的公式。<strong>动作</strong> 好比你双击了一个单元格改变了单元格的数据。把修改过后的数据反馈到屏幕上就是 <strong>反应</strong> 做的事。</p>
<p>这有个使用mobx和react的例子，例子中使用到了这四个概念：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  @observable firstName = <span class="string">"Michel"</span>;</div><div class="line">  @observable lastName = <span class="string">"Weststrate"</span>;</div><div class="line">  @observable nickName;</div><div class="line"></div><div class="line">  @computed get fullName() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> michel = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="comment">// 这里就算是一个反应，用来打印可观测状态变化的日志</span></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(person.nickName ? person.nickName : person.fullName));</div><div class="line"></div><div class="line"><span class="comment">// 示例的react组件，根据状态变化发生改变，其中observer是来自react-mobx的api</span></div><div class="line"><span class="keyword">const</span> profileView = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">if</span> (props.person.nickName)</div><div class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;props.person.nickName&#125;&lt;/div&gt;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;props.person.fullName&#125;&lt;/div&gt;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 动作</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> michel.nickName = <span class="string">"mweststrate"</span>, <span class="number">5000</span>)</div><div class="line"></div><div class="line">React.render(React.createElement(profileView, &#123; <span class="attr">person</span>: michel &#125;), <span class="built_in">document</span>.body);</div></pre></td></tr></table></figure>
<p>例1:可观测状态、计算属性、反应渲染Reactjs组件和动作</p>
<p>基于上面的例子，我们可以整理出下图的依赖关系树:</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/an-in-depthexplanation-of-mobx-01.png" alt="Figure 1"></p>
<p>图1:profileView组件的依赖关系树。此时fullName处于活跃状态，它同时观察firstName和lastName</p>
<p>蓝色的是可观测状态。绿色的fullName是计算属性，可以通过观测firstName和lastName的状态自动计算。同理，nickName和fullName的变化都会传导到profileView。profileView 的状态变化会产生一个副作用，让react组件树更新。</p>
<p>在mobx中，依赖关系树会被限制在最小限度。例如,一旦person对象有nickName属性，则视图不再受fullName的影响，也不会受firstName和lastName的影响。这些值之间的所有观察者都会被清理，MobX会自动简化依赖关系树：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/an-in-depthexplanation-of-mobx-02.png" alt="Figure 2"></p>
<p>图 2: 当person对象有nickname属性时的profileView组件的依赖性树，与图1相反，fullName现在处于惰性状态，同事他也不会观测firstName和lastName</p>
<p>mobx将总是试图最小化产生一致状态所需的计算的数量。在这篇文章的其余部分,我将描述用来实现这一目标的一些策略。但在探索计算属性和反应保持同步的原理前，我们首先看下MobX背后的原则:</p>
<blockquote class="blockquote-center"> 响应状态变化永远比处理状态变化好。 </blockquote><br>在我们平时的工作中，应用程序在响应状态更改时所触发的操作，通常会创建或更新某些值。我们可以尝试从另一个角度理解，既可以把大多数的动作都理解为对本地缓存的操作。<br><br>触发用户界面更新?更新某些值?与后端通信?这些都可以认为是缓存失效，我们为了更新缓存所执行的动作。<br><br>为了让这些缓存保持同步，我们一般会使用观察者模式，订阅缓存的状态变化，缓存失效了，好通知你的动作再次被触发。<br><br>但是使用这种模式却有个根本的问题：随着你的应用的不断扩大，你要管理的订阅也越来越多，在这个管理过程中，或多或少都会犯一些错误。比如超额订阅(继续订阅一个值不再使用的值)或遗漏订阅(忘记监听数据更新而导致的数据过时的bug)。<br><br><blockquote class="blockquote-center"> 也就是说，手动维护订阅关系，应用程序早晚会出现数据和展示不一致的情况。</blockquote>

<p><img src="http://oin1wqn2f.bkt.clouddn.com/an-in-depthexplanation-of-mobx-03.png" alt="Figure 3"></p>
<p>图3:更新了个人信息之后，Twitter页面上的不一致现象，推文列表中作者的用户名和头像还是旧的值</p>
<p>Twitter用户界面不一致是一个很好的例子的。我在Reactive2015论坛上解释过造成这种情况的两种原因：要么是没有订阅通知推文列表用户信息已经改变，需要重新渲染。要么就是推文作者的数据和当前登陆用户之前没有关联，尽管这两部分的数据描述的是相同的属性相同的对象。</p>
<p>而像Flux那样的粗粒度的订阅很容易造成超额订阅。使用react时，可以使用react提供的开发工具打印调试信息查看是否有浪费的渲染，来简单的判断是否有超额订阅的情况。而MobX可以将这种情况降至零。mobx会自动帮你管理成千上万的订阅。</p>
<p>值得一提的是，超额订阅可能会很隐秘。如果你订阅的数据但并不是在所有情况下都会被使用，那它仍然是超额订阅的。例如例1中，profileView组件订阅了的fullName，但是person对象有nickName属性时，它还是超额订阅的。</p>
<p>所以设计mobx背后的一个重要的原则是:</p>
<blockquote class="blockquote-center">只有运行时确定下来的订阅，才是最小的订阅集合</blockquote>

<p>mbox背后的第二个重要思想是：尽量使用mobx去创建一个图结构的数据模型去管理你的应用，而不是平时常用的树状结构。</p>
<p>我们真正要开发的应用通常会比TodoList复杂很多。图结构可以有效的保证数据的一致性，并避免数据重复。</p>
<h2 id="mobx如何保持所有派生一致"><a href="#mobx如何保持所有派生一致" class="headerlink" title="mobx如何保持所有派生一致"></a>mobx如何保持所有派生一致</h2><p>解决方案：用计算代替缓存。有人会问：“那不是非常消耗资源的吗?”其实并没有，而且他效率还挺高的。</p>
<p>原因正如上面所解释的：mobx并不运行所有派生，只同步那些参与到反应中的计算属性和可观测状态。这些派生被称为活跃的。</p>
<h2 id="惰性和活跃"><a href="#惰性和活跃" class="headerlink" title="惰性和活跃"></a>惰性和活跃</h2><p>那么没有直接或间接被反应调用的派生咋办呢？当然，你仍然可以随时检查计算属性（如fullName）的值。</p>
<p>解决方法也很简单：如果一个计算值不是活跃的，那么它将在需要他的时候重新计算（就是惰性的），就跟一个正常的getter函数一样。如果惰性的派生(从来没有观察到任何东西)从作用域中移除，就会被垃圾收集。还记得计算属性是可观察状态的纯函数吧？这就是为啥他是纯函数的原因:不管什么状态下，相同的可观测状态，计算属性函数计算的结果也一定是相同的。</p>
<h2 id="运行计算"><a href="#运行计算" class="headerlink" title="运行计算"></a>运行计算</h2><p>mobx中反应和计算属性都是由以同样的方式运行的。当前运行的派生有个函数栈，当有计算触发了派生的函数，这个函数就会被推入栈中。只要计算正在运行，被访问的每个被观测状态都会将其自身注册为派生栈的最顶层函数的依赖。如果需要计算属性的值，并且计算属性已经处于活跃状态，则直接使用最后一次计算出的值。否则就将他推入派生函数栈，切换到活跃状态，并开始计算。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/an-in-depthexplanation-of-mobx-04.png" alt="Figure 4"></p>
<p>图4:在执行profileView响应函数期间的计算过程。</p>
<p>当计算完成时，派生将获得在执行期间访问的可观测列表。 例如，在profileView中，此列表将只包含nickName属性，或nickName和fullName属性。 每次获得的列表与之前的都可能不同。 任何被废弃的属性都将被忽略（计算属性可能从活跃模式转换到惰性模式），并且任何新添加的可观测状态都将被观测，直到下一次计算。 如果firstname的值以后更改了，观测它的派生就知道fullName需要重新计算。这反过来将导致界面重新渲染。 下一段更详细地解释这个过程。</p>
<h2 id="状态变化的传播"><a href="#状态变化的传播" class="headerlink" title="状态变化的传播"></a>状态变化的传播</h2><p><img src="http://oin1wqn2f.bkt.clouddn.com/an-in-depthexplanation-of-mobx-05.png" alt="Figure 5"></p>
<p>图5：在依赖关系树上更改’1’的值的效果。 虚线边框表示需要被更新的派生。 数字表示计算的顺序。</p>
<p>派生会自动响应状态的变化。所有反应函数都是同步执行的，而且是无干扰的。当一个可观测的值被修改，整个修改算法如下：</p>
<ol>
<li>被观测对象给所有观察它的派生发送一个过期通知，告诉它们自己需要更新了。任何受到影响的计算属性将递归的把消息传递给其他的观察者。结果，依赖树中的一部分被标记为过期。在图5的示例依赖关系树中，当值’1’改变时变为陈旧的观察者用橙色的虚线标记。这些都是受影响的派生。</li>
<li>发送失效通知并存储新值后，将发送就绪通知。 此消息还将标记值是否真的发生了改变。</li>
<li>一旦派生接收到针对步骤1的就绪通知，它就知道所有的观测值都已经稳定了，然后它会开始重新计算。就绪/失效消息的计数器会保证计算属性’4’将会在计算属性’3’变得稳定之后才重新计算。</li>
<li>如果没有接到就绪通知值，则派生将简单的告诉自己的观察者自己已经准备好了，但是值没变。否则，计算属性将重新计算并给自己的观察者发送就绪通知。在图5中我们可以看到，比如计算属性‘4’重新计算后没有产生新值，那么最后的响应（‘-’表示的那个）永远都不会被执行。</li>
</ol>
<p>前两段总结了如何在运行时跟踪可观测状态和派生之间的依赖关系，以及如何通过派生来传播变化。 现在，你可能还会意识到，反应其实就是一个总是处于活跃状态的计算属性。 此外，mobx还应用了许多其他优化，不过这超出了本文的范围，暂不讨论。</p>
<h2 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h2><p>人们经常惊讶与mobx所有的动作都是同步运行的（像RxJs和不像knockout）。 这有两大优点：首先，它变得根本不可能观察到过期的派生。 因此，在影响它的值修改之后，可以立即使用派生的值。 其次，它使栈跟踪和调试更容易，因为它避免了无用的栈跟踪。</p>
<p>但是，有些时候我们不得不引入批量操作。比如autocomplate之类的常见功能，会在短时间内连续多次改变值，我们需要在一系列改变之后再发送就绪通知。这就要用mobx中的另一个概念，事务（transaction）。</p>
<p>事务可以推迟就绪通知，整个事务完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">transaction(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  michel.firstName = <span class="string">"Mich"</span>;</div><div class="line">  michel.lastName = <span class="string">"W."</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>例 2: 事务示例。</p>
<p>至此，我们总结了mobx最基本的实现细节。我们还没有覆盖一切，但是剩下的也都很好理解，例如，你可以组合计算属性。 通过组合反应和计算属性，甚至可以自动将一个数据图转换为另一个数据图。通过这些特性，我们还能很容易的实现一些复杂的模式，如map-reduce，时间回溯，或者横向数据加载。</p>
<h2 id="重点概要："><a href="#重点概要：" class="headerlink" title="重点概要："></a>重点概要：</h2><ol>
<li>复杂应用程序的应用程序状态最好使用图表来表示，既能保证数据和视图的一致性，又直观好理解</li>
<li>不应该通过手动订阅来同步状态。这将不可避免地导致超额订阅和遗漏订阅</li>
<li>使用运行时分析来确定观察者→可观测状态关系的最小集合。 这样就能达到既保证基本功能，又保持最小计算量的效果。</li>
<li>没有被主动调用的派生都会被优化掉</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章翻译自mobx作者 Michel Weststrate 的一篇博客，虽然我也想做到信达雅，奈何英语水平有限……所以其中掺杂了很多我自己的理解。想了解细节的话可移步&lt;a href=&quot;https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.2lcdbiz5f&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看过我之前的博客的看官都知道，mobx的除了能实现响应式的功能，它的运行速度还很快，那么，他是如何做到的呢？我们一起来看看mobx的内部运行机制。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="中文渣翻" scheme="http://brooch.me/tags/%E4%B8%AD%E6%96%87%E6%B8%A3%E7%BF%BB/"/>
    
  </entry>
  
  <entry>
    <title>javascript中的进程、线程和协程</title>
    <link href="http://brooch.me/2016/12/30/process-thread-and-coroutine-in-javascript/"/>
    <id>http://brooch.me/2016/12/30/process-thread-and-coroutine-in-javascript/</id>
    <published>2016-12-30T15:26:28.000Z</published>
    <updated>2017-01-01T16:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周一直在编前端构建的脚本，用到了多进程去解决一个效率问题。期间差了很多进程、线程、协程的资料，在这里记录回顾一下。</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>关于进程、线程、协程的概念这里就不再赘述了，具体的可以参考wiki百科：</p>
<ul>
<li><p><a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B" target="_blank" rel="external">进程</a></p>
</li>
<li><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" target="_blank" rel="external">线程</a></p>
</li>
<li><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B" target="_blank" rel="external">协程</a></p>
</li>
</ul>
<h2 id="简单概括一下它们间的区别"><a href="#简单概括一下它们间的区别" class="headerlink" title="简单概括一下它们间的区别"></a>简单概括一下它们间的区别</h2><p>就是相对线程和协程，进程更独立，有自己的内存空间，所以进程间通信比较困难。线程比进程轻量级，属于同一进程的多个线程间可以共享全部资源。协程与线程类似，不同点在于，线程由系统控制切换，协程是由用户控制切换。</p>
<p>那么，控制切换，指的是控制什么的切换呢？</p>
<p>在一个进程中执行的程序，有时需要同时处理多个工作，这时我们可以创建多个线程，让每个线程处理一个工作。但是，进程只有一个。就好比一个人，你给他分配了多个工作，帮他把每个工作单独拉了一个列表，可还是他一个人干，他只能一会儿干干这一会儿干干那，来模拟多个工作同时进行的状态，这就是所谓的系统控制切换，系统不停的在多个线程间切换来达到并行的效果。你可能会说，那根一件一件干不是一样吗？没错，是一样的，在只有一个cpu的电脑上，用不用多线程程序执行的时间是一样的。但是，如果这个人长了两个脑袋呢？那么他就能同时处理两件工作了。多核cpu就是那个长了好多个脑地的人……而协程的切换是要由用户手动来控制的，所以协程并适合并行计算，而更多的用来优化程序结构。</p>
<h2 id="js都支持吗？"><a href="#js都支持吗？" class="headerlink" title="js都支持吗？"></a>js都支持吗？</h2><p>这要看js在什么环境运行。</p>
<p>在浏览器中，可以通过webworkers创建进程，可以通过async/await，yield/Generator/GeneratorFunction实现协程，控制程序切换。</p>
<p>在node中，除了可以使用上面浏览器中可以使用的方法，还可以通过cluster，child_process创建进程，通过libuv，tagg创建线程</p>
<h2 id="刚才提到的那些都是啥？怎么用？"><a href="#刚才提到的那些都是啥？怎么用？" class="headerlink" title="刚才提到的那些都是啥？怎么用？"></a>刚才提到的那些都是啥？怎么用？</h2><h3 id="webworkers"><a href="#webworkers" class="headerlink" title="webworkers"></a>webworkers</h3><p>简单点儿说就是使用webworkers你可以在全新的环境中运行一个你指定的js文件。这个全新的环境是独立的，既一个全新的进程，有点儿像一个新iframe还没有window.top，window.parent属性，哈哈……</p>
<p>webworkers创建的进程和主进程之间可以通过message事件传递消息，但是消息只能是字符串，所以想要传对象和数组就只能传json了……这也是他不方便的地方。</p>
<p>具体使用方法可以看MDN上的文章：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">使用 Web Workers</a></p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>async/await是es7中新加的两个关键字，async 可以声明一个异步函数，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果。</p>
<p>其实就是类似汇编的寄存器和跳转指令……呃，通俗的说就是可以根据状态跳转态另一个函数半中间。</p>
<p>由于es7还未在各个环境实现，想要使用的话还的用一些babel-polyfill之类的库做兼容……</p>
<p>更详细介绍请看阿阮的文章：<a href="http://es6.ruanyifeng.com/?search=async&amp;x=0&amp;y=0#docs/async" target="_blank" rel="external">异步操作和Async函数</a></p>
<h2 id="yield-Generator-GeneratorFunction"><a href="#yield-Generator-GeneratorFunction" class="headerlink" title="yield/Generator/GeneratorFunction"></a>yield/Generator/GeneratorFunction</h2><p>generator是es6中新增的函数，本质是可以将一个函数执行暂停，并保存上下文，再次调用时恢复当时的状态。但是用来解决协程切换的问题貌似有点儿滥用特性的感觉呢……</p>
<p>更详细介绍请看阿阮的文章：<a href="http://es6.ruanyifeng.com/?search=async&amp;x=0&amp;y=0#docs/generator" target="_blank" rel="external">Generator 函数</a></p>
<h3 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h3><p>cluster是node官方提供的一个多进程模块，效果和C语言的fork函数类似，当前文件完全重新执行一遍，通过cluster.isMaster判断是不是主进程，在区分不同的操作。进程间通过事件回调来通信，NodeJS 0.6.x 以上的版本开始支持。</p>
<p>示例代码就不放了，node官方文档上写的很详细：<a href="https://nodejs.org/api/cluster.html" target="_blank" rel="external">cluster</a></p>
<h3 id="child-process"><a href="#child-process" class="headerlink" title="child_process"></a>child_process</h3><p>node自带的child_process模块里的fork函数可以实现类似浏览器里webworkers的效果，使用方法和webworker一毛一样，都是通过读取新文件开启新进程，通过message通信。</p>
<p>具体介绍请看文档：<a href="https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options" target="_blank" rel="external">child_process.fork(modulePath[, args][, options])</a></p>
<p>官方文档没有示例，下面给出一个web服务接收参数计算斐波那契数组的例子：</p>
<h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</div><div class="line"><span class="keyword">var</span> app = express();</div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> worker = fork(<span class="string">'./work_fibo.js'</span>) <span class="comment">//创建一个工作进程</span></div><div class="line">	worker.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;<span class="comment">//接收工作进程计算结果</span></div><div class="line">		<span class="keyword">if</span>(<span class="string">'object'</span> === <span class="keyword">typeof</span> m &amp;&amp; m.type === <span class="string">'fibo'</span>)&#123;</div><div class="line">			worker.kill();<span class="comment">//发送杀死进程的信号</span></div><div class="line">			res.send(m.result.toString());<span class="comment">//将结果返回客户端</span></div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	worker.send(&#123;<span class="attr">type</span>:<span class="string">'fibo'</span>,<span class="attr">num</span>:~~req.query.n || <span class="number">1</span>&#125;);<span class="comment">//发送给工作进程计算fibo的数量</span></div><div class="line">&#125;);</div><div class="line">app.listen(<span class="number">8124</span>);</div></pre></td></tr></table></figure>
<h4 id="work-fibo-js"><a href="#work-fibo-js" class="headerlink" title="work_fibo.js"></a>work_fibo.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fibo = <span class="function"><span class="keyword">function</span> <span class="title">fibo</span> (<span class="params">n</span>) </span>&#123;<span class="comment">//定义算法</span></div><div class="line">	<span class="keyword">return</span> n &gt; <span class="number">1</span> ? fibo(n - <span class="number">1</span>) + fibo(n - <span class="number">2</span>) : <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</div><div class="line"><span class="comment">//接收主进程发送过来的消息</span></div><div class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> m === <span class="string">'object'</span> &amp;&amp; m.type === <span class="string">'fibo'</span>)&#123;</div><div class="line">		<span class="keyword">var</span> num = fibo(~~m.num);</div><div class="line">		<span class="comment">//计算jibo</span></div><div class="line">		process.send(&#123;<span class="attr">type</span>: <span class="string">'fibo'</span>,<span class="attr">result</span>:num&#125;)</div><div class="line">		<span class="comment">//计算完毕返回结果        </span></div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line">process.on(<span class="string">'SIGHUP'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	process.exit();<span class="comment">//收到kill信息，进程退出</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="libuv"><a href="#libuv" class="headerlink" title="libuv"></a>libuv</h3><p>libuv是node底层实现使用的c++库……呃，所以如果你想使用这个库来实现多线程，那么你就得编写c++的代码了，不得不说，要想真正理解程序的本质，不多掌握几门语言真是不行啊……</p>
<p>对c++不了解我就不瞎BB了，推荐两篇文章延伸阅读：</p>
<ul>
<li><a href="http://blog.csdn.net/limite_god/article/details/43668235" target="_blank" rel="external">libuv多线程处理的简单示例</a></li>
<li><a href="http://snoopyxdy.blog.163.com/blog/static/601174402013422103614385/" target="_blank" rel="external">利用libuv编写异步多线程的addon实例</a></li>
</ul>
<h3 id="tagg"><a href="#tagg" class="headerlink" title="tagg"></a>tagg</h3><p>tagg(Threads a gogo for Node.js)是Jorge Chamorro Bieling开发的一个node包。使用c语言phread库实现的多线程。</p>
<p>还是那刚才的斐波那契数组计算为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Threads = <span class="built_in">require</span>(<span class="string">'threads_a_gogo'</span>);<span class="comment">//加载tagg包</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibo</span>(<span class="params">n</span>) </span>&#123;<span class="comment">//定义斐波那契数组计算函数</span></div><div class="line">	<span class="keyword">return</span> n &gt; <span class="number">1</span> ? fibo(n - <span class="number">1</span>) + fibo(n - <span class="number">2</span>) : <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> t = Threads.create().eval(fibo);</div><div class="line">t.eval(<span class="string">'fibo(35)'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;<span class="comment">//将fibo(35)丢入子线程运行</span></div><div class="line">	<span class="keyword">if</span> (err) <span class="keyword">throw</span> err; <span class="comment">//线程创建失败</span></div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'fibo(35)='</span> + result);<span class="comment">//打印fibo执行35次的结果</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'not block'</span>);<span class="comment">//打印信息了，表示没有阻塞</span></div></pre></td></tr></table></figure>
<p>最后结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">not block</div><div class="line">fibo(<span class="number">35</span>)=<span class="number">14930352</span></div></pre></td></tr></table></figure></p>
<p>我们可以看到执行效果与webworker类似，不同的是通信使用了异步回调的方式。</p>
<p>值得一提的是tagg包目前只能在linux下安装运行，这里再推荐一个tagg2包，是跨平台的。</p>
<p>这里需要重点提一下的是，不论tagg还是tagg2包都是利用phtread库和v8的v8::Isolate Class类来实现js多线程功能的。</p>
<blockquote>
<p>Isolate代表着一个独立的v8引擎实例，v8的Isolate拥有完全分开的状态，在一个Isolate实例中的对象不能够在另外一个Isolate实例中使用。嵌入式开发者可以在其他线程创建一些额外的Isolate实例并行运行。在任何时刻，一个Isolate实例只能够被一个线程进行访问，可以利用加锁/解锁进行同步操作。</p>
</blockquote>
<p>换而言之，我们在进行v8的嵌入式开发时，无法在多线程中访问js变量，这条规则将直接导致我们之前的tagg2里面线程执行的函数无法使用Node.js的核心api，比如fs，crypto等模块。</p>
<p>延伸阅读：</p>
<ul>
<li><a href="https://github.com/xk/node-threads-a-gogo" target="_blank" rel="external">tagg</a></li>
<li><a href="https://github.com/DoubleSpout/node-threads-a-gogo2" target="_blank" rel="external">tagg2</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过以上的学习，我们大概应该了解到进程、线程、协程的使用场景了，进程、线程适合用来处理计算密集型操作，协程适合用来优化代码结构，解决回调函数嵌套问题。线程比进程更轻，更节省资源，但是由于上面提到的线程问题，针对一些可以使用js原生的大量计算或循环还可以用用，涉及到使用nodejs核心api的操作，比如文件处理之类的操作，就要用进程使用解决了。当然，也可以用libuv库写c++模块处理多线程的操作，但是还要学c++啊望天儿……</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="http://www.admin10000.com/document/4196.html" target="_blank" rel="external">Node.js的线程和进程</a></li>
<li><a href="https://cnodejs.org/topic/518b679763e9f8a5424406e9" target="_blank" rel="external">nodejs多线程，真正的非阻塞</a></li>
<li><a href="https://www.zhihu.com/question/20511233" target="_blank" rel="external">协程的好处是什么?</a></li>
<li><a href="https://www.zhihu.com/question/32218874" target="_blank" rel="external">为什么觉得协程是趋势？</a></li>
</ul>
<h2 id="p-s-我的问题"><a href="#p-s-我的问题" class="headerlink" title="p.s. 我的问题"></a>p.s. 我的问题</h2><p>我在工作中使用的是fis配合grunt调用打包。由于要同时打包多个项目，grunt和fis都会定义全局变量，各个模块之间的配置可能会相互影响，各个模块在打包过程中又没有相互的通信，同时为了提高效率，非常时候适合使用多进程的方式来运行脚本。所以用cluster实现了多进程打包的。</p>
<p>最后，新年快乐，祝大家在2017年里，都能喝最烈的酒，日最野的狗~ ┑(￣Д ￣)┍</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周一直在编前端构建的脚本，用到了多进程去解决一个效率问题。期间差了很多进程、线程、协程的资料，在这里记录回顾一下。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://brooch.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="nodejs" scheme="http://brooch.me/tags/nodejs/"/>
    
      <category term="webworkers" scheme="http://brooch.me/tags/webworkers/"/>
    
      <category term="cluster" scheme="http://brooch.me/tags/cluster/"/>
    
      <category term="child_process" scheme="http://brooch.me/tags/child-process/"/>
    
      <category term="tagg2" scheme="http://brooch.me/tags/tagg2/"/>
    
      <category term="yield" scheme="http://brooch.me/tags/yield/"/>
    
      <category term="generator" scheme="http://brooch.me/tags/generator/"/>
    
      <category term="async" scheme="http://brooch.me/tags/async/"/>
    
      <category term="await" scheme="http://brooch.me/tags/await/"/>
    
  </entry>
  
  <entry>
    <title>响应式react：构建高效易用的react应用</title>
    <link href="http://brooch.me/2016/12/23/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/"/>
    <id>http://brooch.me/2016/12/23/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/</id>
    <published>2016-12-23T07:53:53.000Z</published>
    <updated>2016-12-23T13:59:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章翻译自mobx作者 Michel Weststrate 的一篇博客，虽然我也想做到信达雅，奈何英语水平有限……所以我写的内容自动屏蔽了一些前因后果没营养的话，只翻译我觉得重点的内容。我的原则是，捞干的说，不BB~<br>想了解细节的话可移步<a href="https://www.mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/" target="_blank" rel="external">原文</a></p>
</blockquote>
<p>使用react开发应用有啥好处，我想是个前端都能数出个十条八条来。但是如果你的项目需要在浏览器中绘制成千上万的对象，而且这些对象之前还有大量的耦合关系，那维护这些对象也够喝一壶的……mobx作者在发明mobx的时候就面临了这样一个项目，一个对象的值可能被其他对象引用，任何变化都可能引起大量的ui更新和重绘。在一些特殊场景，比如拖拽操作，这些动作还必须在40毫秒响应……</p>
<p>于是，mobx被开发出来了。简单来说，他使用了函数响应式编程的概念 Observables 来解决上述的问题，其实 mobx 并不是第一个使用这一概念的前端库，ember、knockout还有vue其实都使用了这一概念，我个人感觉，mobx就好像把vue和knockout的数据绑定那部分抽出来然后揉到一起一样……真的能发现很多有相似的地方……使用 Observables 的好处就在于，你可以很容易实现自动更新关联数据和sideways data loading，从而解放生产力，提升应用的性能。后面测试数据一章可以看到具体的对比结果。</p>
<a id="more"></a>
<p>下面我们以一个简单的购物应用为例：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-1.png?1" alt="shoping"></p>
<p>里面包含商品列表，购物车，结算等部分。完整的例子可以再<a href="https://jsfiddle.net/mweststrate/46vL0phw/embedded/result/" target="_blank" rel="external">jsfiddle</a>上看到（需要翻墙）。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>首先，我们先看下数据模型。商品列表（Articles）里的每个商品，有名称（name）和价格（price）属性，购物车（Cart）有已加入购物车列表（Entries）和总价（Total）属性。已加入购物车列表中的每个商品除了名字和价格属性以外，还有数量属性（amount）、根据数量和单价计算出的总价。数据之间的关系如下图所示。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-2.png?1" alt="data model"></p>
<p>从上图中我们可以看出，如果对一个数据进行修改，那么就会带动其他的数据修改，同时还得修改ui。<br>大概列一下数据联动的逻辑：</p>
<ul>
<li>如果商品列表里的商品价格发生改变，购物车里的商品价格也需要更新。</li>
<li>……购物车的总价也得更新。</li>
<li>如果购物车中商品数量变化，总价也得跟着更新。</li>
<li>如果商品列表里的商品被重命名了，商品列表的界面得更新。</li>
<li>……购物车里对应的商品也得更新。</li>
<li>如果添加新文章合计购物车……</li>
</ul>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-3.jpg?1" alt="(╯‵□′)╯︵┻━┻"></p>
<p>作为一个程序员，就是这么闹心……你不得不写大量的代码来处理各种可能的状态，处理速度还得快，让用户老爷等着急了你担待得起吗……</p>
<p>那么，让我们来看看怎么用mobx来日翻这些问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params">name, price</span>) </span>&#123;</div><div class="line">    mobx.extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">name</span>: name,</div><div class="line">        <span class="attr">price</span>: price</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ShoppingCartEntry</span>(<span class="params">article</span>) </span>&#123;</div><div class="line">    mobx.extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">article</span>: article,</div><div class="line">        <span class="attr">amount</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">price</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.article ? <span class="keyword">this</span>.article.price * <span class="keyword">this</span>.amount : <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ShoppingCart</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    mobx.extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">entries</span>: [],</div><div class="line">        <span class="attr">total</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.entries.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sum, entry</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> sum + entry.price;</div><div class="line">            &#125;, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用工具函数包装之后，通过构造函数创建的对象都是可观测的，就是说当对象的某一个属性改变，跟他跟他相关联的属性都会自动更新。这样状态变化就不用我们手动维护了，比如添加商品到购物车时总价的变化、物品的价格发生变化时其他关联项的变化等等。</p>
<h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>模型建好了，该搭界面了。下面的列了一段购物车组件的代码，包含了显示购物车里的商品列表和总价。其他组件请自行脑补，都差不离的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CartView = React.createClass(&#123;</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">renderEntry</span>(<span class="params">entry</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> (&lt;CartEntryView entry=&#123;entry&#125; cart=&#123;this.props.cart&#125; key=&#123;entry.id&#125; /&gt;);</div><div class="line">        &#125;</div><div class="line">        return (&lt;div&gt;</div><div class="line">            &lt;ul id="cart"&gt;&#123;this.props.cart.entries.map(renderEntry)&#125;&lt;/ul&gt;</div><div class="line">            &lt;div&gt;&lt;b&gt;Total: &lt;span id="total"&gt;&#123;this.props.cart.total&#125;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;</div><div class="line">        &lt;/div&gt;)</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var CartEntryView = React.createClass(&#123;</div><div class="line">    render: function() &#123;</div><div class="line">        return (&lt;li&gt;</div><div class="line">            &lt;button onClick=&#123;this.removeArticle&#125;&gt;&amp;laquo;&lt;/button&gt;</div><div class="line">            &lt;span&gt;&#123;this.props.entry.article.name&#125;&lt;/span&gt;</div><div class="line">            &lt;span&gt;&#123;this.props.entry.amount&#125;&lt;/span&gt;</div><div class="line">        &lt;/li&gt;);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    removeArticle: function() &#123;</div><div class="line">        if (--this.props.entry.amount &lt; 1)</div><div class="line">            this.props.cart.entries.splice(this.props.cart.entries.indexOf(this.props.entry), 1);      </div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>组件写完了，但是没跟模型关联还跑不起来，需要用mobx-react库里的 <code>mobxReact.observer</code> 方法把组件都包装装一下，这就算关联上了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CartEntryView = mobxReact.observer(React.createClass(&#123;</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> (&lt;li&gt;</div><div class="line">            // etc...</div></pre></td></tr></table></figure>
<p>然后，就没有然后……是的，这就算齐活了。让我们看下<a href="https://jsfiddle.net/mweststrate/46vL0phw/" target="_blank" rel="external">jsfiddle</a>上的演示。</p>
<p>这里 <code>observer</code> 函数为我们做了两件事。首先，它将组件的 <code>render</code> 函数变成一个可观察到的函数。然后，把组件注册到观察者函数，所以每次 <code>render</code> 需要更新了他都会自动更新。<code>mobxReact.observer</code>（如果你使用ES6的话是 <code>@observer</code>）确保每当数据改变，只更新UI的相关部分，就是刚才上面提到的sideways data loading。你可以自己点点试试，注意看下方的日志面板，看看UI更新的数据，你会发现，每次操作，组件的重绘数量都是最低的。</p>
<p>另外，由于每个组件都只跟踪自己的依赖，通常不需要重新渲染子组件。比如，如果购物车的总价重新渲染了，在不必要的情况下就不会重新渲染购物车里的商品列表。</p>
<h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>东西好不好,主要看疗效。<a href="https://jsfiddle.net/mweststrate/wr2hcdwL/" target="_blank" rel="external">这里</a>你可以找到一个一毛一样的应用，但没有使用mobx，而是简单的使用每次替换数据的方法构建的。只有几个商品，不会感觉到有任何区别，但一旦商品数量上升，就会提现出真正意义上的性能差异。</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-4.png?1" alt="create"><br><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-5.png?1" alt="update"></p>
<p>创建大量的数据和组件的时候，基本没啥差别。但是在修改数据时，强弱立分高下力判。如果在有10000个元素的列表中更新其中10个元素的数据，速度大约快了十倍。2.5秒下降到250毫秒……那么这种差别是从哪里来的呢？让我们来瞅瞅不适用mobx时React的渲染报告：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-6.png?1" alt="without mobx render reports"></p>
<p>可以看到，ArticleViews 和 CartEntryViews一共渲染了20000次。2433毫秒的渲染时间中，2145毫秒的渲染时间是被浪费的（Wasted time）。Wasted time的意思是：花费在执行渲染函数上的时间，实际上并没有更新任何一个DOM元素。这有力地说明了，无脑更新是一件很浪费cup资源的，组件越多浪费的时间就越多。</p>
<p>相较之下，这是使用mobx的报告：</p>
<p><img src="http://oin1wqn2f.bkt.clouddn.com/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps-7.png?1" alt="with mobx render reports"></p>
<p>重绘的只有31个组件，完全没有一点浪费。就是说每个重新渲染的组件都是确实需要修改的。这正是我们想要实现的效果！</p>
<p>然而，这样你就满足了吗？我们还可以再进一步优化！</p>
<p>从报告中我们还可以看出，267毫秒的总体渲染时间里，大部分剩余的渲染时间消耗在CartView的渲染上（243毫秒）。那是在更新购物车的总价属性。值得注意的是，要重新渲染CartView，也就意味着要检查购物车中一万个商品是否有修改，是否要更新CartEntryView。而这就浪费了大部分时间。我们可以把总价再单独做一个控件，CartTotalView。通过这个简单的处理，如果只是总价的变化，就可以跳过CartView的重新渲染。这使得渲染时间进一步下降到约60毫秒（见上图中的灰色那一条），这比没有使用Mobx的React应用大约快了40倍!</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好的，通过上面的例子我们看到了使用mobx和不使用mobx在性能上的区别。这里还需要强调的一点是，使用了mobx还有一个优势，就是不会影响代码的可维护性，对于程序员来说，这点很重要，就算有万般好处，如果代码写出来像屎一样难看，也不会有人想用对吧？在jsfiddle里面可以看到两个例子的完整程序。两段代码基本没啥太大的区别……┑(￣Д ￣)┍</p>
<p>那么，我们可以用其他技术达到相同的效果吗？也许吧。例如，使用ImmutableJS也能做到sideways data loading。然而，就像我刚才说的，有可能你会收获一坨是一样的代码……毕竟，恕我直言，相对于不可变对象，可变类使用起来会更方便一些。此外，不可变的数据结构不能帮助你保持计算属性。如果使用不可变数据，改变商品的名字ArticleView会重新渲染的很快，但是CartEntryView中引用的相同商品实例就会失效。</p>
<p>另一种优化React应用的方案是为每一个可能发生的操作创建事件，然后在管理这些事件，在恰当的时机恰当的地点（组件）触发（注销）它们。但这将导致编写大量的样板式代码，维护起来相当困难。我不知道人啊，反正我是懒得弄这些……（哥你是不是不会断句……这段看的好纠结啊……）</p>
<p>顺便说一下，我强烈建议使用action来抽象对模型的更新，这样能有效的做到表现和行为分离。</p>
<p>最后，在大型项目中使用mbox配合React是非常好用的。有时我看到数据变化时，界面上某个角落也跟着更新了，我自己都惊呆了……而且还没有任何性能问题，你说气人不……(￣▽￣)”……心动不如行动，让我们把繁重的维护工作都丢给React和Mobx，敬请享受更轻松有趣的coding吧~！</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="https://github.com/mobxjs/mobx" target="_blank" rel="external">MobX library</a></li>
<li><a href="https://facebook.github.io/react/docs/advanced-performance.html" target="_blank" rel="external">React performance guide</a></li>
<li><a href="https://jsfiddle.net/mweststrate/46vL0phw/" target="_blank" rel="external">Shopping cart demo, React with Observables</a></li>
<li><a href="https://jsfiddle.net/mweststrate/wr2hcdwL" target="_blank" rel="external">Shopping cart demo, React without Observables</a></li>
<li><a href="https://jsfiddle.net/mweststrate/vxn7qgdw/" target="_blank" rel="external">Shopping cart demo, JQuery with Observables</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章翻译自mobx作者 Michel Weststrate 的一篇博客，虽然我也想做到信达雅，奈何英语水平有限……所以我写的内容自动屏蔽了一些前因后果没营养的话，只翻译我觉得重点的内容。我的原则是，捞干的说，不BB~&lt;br&gt;想了解细节的话可移步&lt;a href=&quot;https://www.mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用react开发应用有啥好处，我想是个前端都能数出个十条八条来。但是如果你的项目需要在浏览器中绘制成千上万的对象，而且这些对象之前还有大量的耦合关系，那维护这些对象也够喝一壶的……mobx作者在发明mobx的时候就面临了这样一个项目，一个对象的值可能被其他对象引用，任何变化都可能引起大量的ui更新和重绘。在一些特殊场景，比如拖拽操作，这些动作还必须在40毫秒响应……&lt;/p&gt;
&lt;p&gt;于是，mobx被开发出来了。简单来说，他使用了函数响应式编程的概念 Observables 来解决上述的问题，其实 mobx 并不是第一个使用这一概念的前端库，ember、knockout还有vue其实都使用了这一概念，我个人感觉，mobx就好像把vue和knockout的数据绑定那部分抽出来然后揉到一起一样……真的能发现很多有相似的地方……使用 Observables 的好处就在于，你可以很容易实现自动更新关联数据和sideways data loading，从而解放生产力，提升应用的性能。后面测试数据一章可以看到具体的对比结果。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
      <category term="中文渣翻" scheme="http://brooch.me/tags/%E4%B8%AD%E6%96%87%E6%B8%A3%E7%BF%BB/"/>
    
  </entry>
  
  <entry>
    <title>MobX入坑指南(4) -- Utility functions</title>
    <link href="http://brooch.me/2016/12/16/MobX-simple-entry-4/"/>
    <id>http://brooch.me/2016/12/16/MobX-simple-entry-4/</id>
    <published>2016-12-16T05:11:29.000Z</published>
    <updated>2016-12-20T14:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前几篇大概介绍了mobx最常用的几个方法，这次准备把剩余的公共方法都介绍了。</p>
<h2 id="autorunAsync"><a href="#autorunAsync" class="headerlink" title="autorunAsync"></a>autorunAsync</h2><p><code>autorunAsync(debugName?: string, action: () =&gt; void, minimumDelay?: number, scope?): disposer</code></p>
<p><code>autorunAsync</code> 的功能与 <code>autorun</code> 相似，功能都是在观测对象发生变化时自动运行回调函数 <code>action</code>。不同点在于 <code>autorun</code> 是在观测对象发生变化时立即执行的，而 <code>autorunAsync</code>是异步的，可以通过 <code>minimumDelay</code> 参数来指定延迟的时间。<br><a id="more"></a><br>如果被观测对象的在延迟过程中发生多次变化，<code>action</code> 也只会在延迟结束时触发一次，所以它和后面要介绍到的 <code>transaction</code> 方法效果类似。在某些场景下这个方法很有用，比如他可以被用来防止频繁向服务端发起请求。</p>
<p>如果传了 <code>scope</code> 参数，那么 <code>scope</code> 将作为 <code>action</code> 运行时的this。</p>
<p>如果传了第一个参数 <code>debugName</code>，那么在调试工具中将使用 <code>debugName</code> 作为调试信息。</p>
<p>和 <code>autorun</code> 一样，<code>autorunAsync</code> 也会返回一个销毁函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">autorunAsync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 我们假设 searchBar.keyword 已经被观测, 是搜索输入框的值。当它发生变化时我们要把它发送到服务端请求搜索结果。</span></div><div class="line">	<span class="comment">// 如果这里使用autorun，那么每次变化都会向调用sendKeywordToServer。</span></div><div class="line">    <span class="comment">// 使用autorunAsync延迟300ms发送，当发送时，searchBar.keyword会是这300ms内变化的最终值。</span></div><div class="line">    <span class="comment">// 这样就可以有效的防止频繁请求造成服务抖动。</span></div><div class="line">    sendKeywordToServer(searchBar.keyword);</div><div class="line">&#125;, <span class="number">300</span>);</div></pre></td></tr></table></figure>
<h2 id="Atom类-和-Reaction类"><a href="#Atom类-和-Reaction类" class="headerlink" title="Atom类 和 Reaction类"></a>Atom类 和 Reaction类</h2><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><p>有些时候，你可能想要有更多的数据结构或其他的东西(比如streams)，也可以用于响应计算。可以使用 <code>Atom</code> 类简单快速的实现这一功能。<code>Atom</code> 实例可以通知mobx观测对象发生了变化，而mobx会在启用和停用观测对象的时候通知 <code>Atom</code> 实例。</p>
<p>下面的例子展示了 <code>Atom</code> 的全部功能，这个例子展示了如何创建一个时钟，这个时钟只有在被观测时才会运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;Atom, autorun&#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> </span>&#123;</div><div class="line">    atom;</div><div class="line">    intervalHandler = <span class="literal">null</span>;</div><div class="line">    currentDateTime;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="comment">// 创建一个Atom实例</span></div><div class="line">        <span class="keyword">this</span>.atom = <span class="keyword">new</span> Atom(</div><div class="line">            <span class="comment">// 第一个参数: Atom实例的名字, 调试用的</span></div><div class="line">            <span class="string">"Clock"</span>,</div><div class="line">            <span class="comment">// 第二个参数（可选）: 从不被监听到被监听时的回调函数.</span></div><div class="line">            () =&gt; <span class="keyword">this</span>.startTicking(),</div><div class="line">            <span class="comment">// 第三个参数（可选）: 从被监听到不被监听时的回调函数</span></div><div class="line">            <span class="comment">// 注意，atom实例会多次在这两种状态见转换</span></div><div class="line">            () =&gt; <span class="keyword">this</span>.stopTicking()</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getTime() &#123;</div><div class="line">        <span class="comment">// 如果Atom实例被响应函数调用，则reportObserved返回true。</span></div><div class="line">		<span class="comment">// 同时，reportObserved会通知mobx这个实例在响应回调中被使用了，它还会触发实例的第二个参数（startTicking）</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.atom.reportObserved()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.currentDateTime;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 当没有响应函数调用Atom实例的时候，就不会触发startTicking。</span></div><div class="line">            <span class="comment">// 根据不同的情况，这里也可以做不同的处理，比如抛出一个错误，返回一个默认值等等。</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tick() &#123;</div><div class="line">        <span class="keyword">this</span>.currentDateTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">		<span class="comment">// 通知mobx当前值发生了变化</span></div><div class="line">        <span class="keyword">this</span>.atom.reportChanged();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    startTicking() &#123;</div><div class="line">        <span class="keyword">this</span>.tick(); <span class="comment">// 初始化时钟</span></div><div class="line">        <span class="keyword">this</span>.intervalHandler = setInterval(</div><div class="line">            <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.tick(),</div><div class="line">            <span class="number">1000</span></div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    stopTicking() &#123;</div><div class="line">        clearInterval(<span class="keyword">this</span>.intervalHandler);</div><div class="line">        <span class="keyword">this</span>.intervalHandler = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> Clock();</div><div class="line"></div><div class="line"><span class="keyword">const</span> disposer = autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(clock.getTime()));</div><div class="line"></div><div class="line"><span class="comment">// ... 每秒打印时间</span></div><div class="line"></div><div class="line">disposer();</div><div class="line"></div><div class="line"><span class="comment">// 停止打印。如果没有响应函数调用当前clock实例，那么时钟将停止。会触发stopTicking函数。</span></div></pre></td></tr></table></figure>
<h3 id="Reaction"><a href="#Reaction" class="headerlink" title="Reaction"></a>Reaction</h3><p>使用 <code>Reaction</code> 可以创建一个自定义的监听器。<code>Reaction</code> 接受一个函数作为参数，他会分析这个函数所依赖的被观测对象，然后追踪他们，当他们发生变化时发出事件。</p>
<p>下面的例子展示了 <code>autorun</code> 是如何用 <code>Reaction</code> 实现的，其实这个例子我没看太懂，貌似必须调用 <code>Reaction</code> 的track方法才能追踪并发出信号，但是例子中是在 <code>Reaction</code> 接收的函数中调用，然后runReaction的时候开始，具体的得等我翻了源码之后才能知道了……</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">autorun</span>(<span class="params">view: Lambda, scope?: any</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (scope)</div><div class="line">        view = view.bind(scope);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> reaction = <span class="keyword">new</span> Reaction(view.name || <span class="string">"Autorun"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.track(view);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// 开始或者排入队列</span></div><div class="line">    <span class="keyword">if</span> (isComputingDerivation() || globalState.inTransaction &gt; <span class="number">0</span>)</div><div class="line">        globalState.pendingReactions.push(reaction);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        reaction.runReaction();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> reaction.getDisposer();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="createTransformer"><a href="#createTransformer" class="headerlink" title="createTransformer"></a>createTransformer</h2><p><code>createTransformer(transformation: (value: A) =&gt; B, onCleanup?: (result: B, value?: A) =&gt; void): (value: A) =&gt; B</code></p>
<p><code>createTransformer</code> 可以将一个转换函数（可以将一个值转换为另一个值得函数，比如数组的map方法接收的函数）包装成一个可缓存的响应函数。换句话说, 如果参数<code>transformation</code>接收到一个值A，然后把A转化为了B，那么以后再接收到A，它就会把缓存的B返回。如果A发生了变化，那么<code>transformation</code>会重新计算更新B。如果没有响应函数引用这个转换函数了，那么他将自动清除自己的缓存。</p>
<p>使用 <code>createTransformer</code> 可以方便的对一个完整的数据结构进行转换（原文：it is very easy to transform a complete data graph into another data graph，我个人理解是，作者想表达这种转换方式对图这种数据结构会特别有效……）。转换函数还可以进行嵌套，这样你就可以用很多小的转换函数碎片组成一个树状结构，描述更复杂的模型。最终组成的数据模型不会过期，他会一直与组成他的转换函数碎片保持同步。这个特性能让mobx很容易实现一些强大的功能，比如sideways data loading（react的一个概念，将数据直接推送给某些具体的组件，而非从父级层层传递，数据加载后基本上无需从底层刷新app，而是刷新若干组件中某个具体的部分）、map-reduce（仿佛说的是谷歌三宝之一的MapReduce架构……map-reduce与js相关的资料我没有查到，具体MapReduce的介绍可以看<a href="http://blog.csdn.net/opennaive/article/details/7514146" target="_blank" rel="external">这里</a>）、追踪不可变对象变更历史，等等。</p>
<p><code>onCleanup</code> 参数会在转换函数不再被使用时被调用，可以用来销毁资源。</p>
<p>转换函数需要用响应函数包装才能起作用，比如放在 <code>@observer</code> 或者 <code>autorun</code> 里。和其他的计算属性一样，如果不再有观察者调用，转换函数也将退好为惰性的，不会自动执行，以保证程序的性能。</p>
<p>上面说的各种概念可能会比较难理解，下面列出了两个例子来解释之前的概念:</p>
<h3 id="追踪数据变化，分享数据结构"><a href="#追踪数据变化，分享数据结构" class="headerlink" title="追踪数据变化，分享数据结构"></a>追踪数据变化，分享数据结构</h3><p>这个例子是从<a href="https://github.com/mobxjs/mobx-reactive2015-demo" target="_blank" rel="external">这里</a>来得（我能从中看出追踪数据状态来，但是分享数据结构没看出来……）:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">    store用来保存boxes和arrows</div><div class="line">*/</div><div class="line"><span class="keyword">const</span> store = observable(&#123;</div><div class="line">    <span class="attr">boxes</span>: [],</div><div class="line">    <span class="attr">arrows</span>: [],</div><div class="line">    <span class="attr">selection</span>: <span class="literal">null</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">    states列表用来保存序列化之后的store历史状态</div><div class="line">*/</div><div class="line"><span class="keyword">const</span> states = [];</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    states.push(serializeState(store));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">const</span> serializeState = createTransformer(<span class="function"><span class="params">store</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">boxes</span>: store.boxes.map(serializeBox),</div><div class="line">    <span class="attr">arrows</span>: store.arrows.map(serializeArrow),</div><div class="line">    <span class="attr">selection</span>: store.selection ? store.selection.id : <span class="literal">null</span></div><div class="line">&#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> serializeBox = createTransformer(<span class="function"><span class="params">box</span> =&gt;</span> (&#123;...box&#125;));</div><div class="line"></div><div class="line"><span class="keyword">const</span> serializeArrow = createTransformer(<span class="function"><span class="params">arrow</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">id</span>: arrow.id,</div><div class="line">    <span class="attr">to</span>: arrow.to.id,</div><div class="line">    <span class="attr">from</span>: arrow.from.id</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>在这个例子中，states中的每个state的序列化，由三个不同的转化函数完成。autorun触发store的序列化，进而序列化所有的boxes和arrows。</p>
<p>让我们用一个假设的例子来看看执行的过程。假设我们往store.boxes中添加一个box，我们叫他box#3。</p>
<ol>
<li>首先box#3会被 <code>map</code> 方法传入 <code>serializeBox</code> 函数，<code>serializeBox</code> 函数执行将其序列化并将结果添加进自己的缓存列表。</li>
<li>当另一个box别添加进store.boxes，将导致 <code>serializeState</code> 函数重新计算结果，从而产生一个全新的boxes列表。在这个过程中，对于已存在的值，serializeBox都将从缓存列表返回旧值，这样转换函数就不需要再次运行了。</li>
<li>然后，如果有人更改box#3属性，这将导致 <code>serializeBox</code> 重新计算box#3的值。转换函数将产生一个新的box#3的Json对象，所有订阅了这个转换函数的观察者都将再次运行。这个例子中 <code>serializeState</code> 会自动执行。<code>serializeState</code>将产生新值，映射所有的box的。除了box#3，其他所有box的值都将会从缓存列表返回。</li>
<li>最后，如果box#3从 <code>store.boxes</code> 中移除，<code>serializeState</code> 也将重新计算。<code>serializeBox</code> 不再监听box#3，监听它的响应函数也将退化为非响应模式。<code>serializeBox</code> 的缓存列表中也将移除box#3的缓存。</li>
</ol>
<p>上面的例子中，我们使用不可变的状态跟踪有效的取得了状态变化列表,共享了数据结构。所有box和arrow都会被转化为简单状态树。每次计算的都会给<code>states</code> 中添加一条新的数据。不同的数据之间将共享box和arrow。</p>
<h3 id="将一个数据结构转换为一个可响应的数据结构"><a href="#将一个数据结构转换为一个可响应的数据结构" class="headerlink" title="将一个数据结构转换为一个可响应的数据结构"></a>将一个数据结构转换为一个可响应的数据结构</h3><blockquote>
<p>这段儿我都看懵逼了……纯凭感觉理解的……下面贴上原文对比着看吧</p>
</blockquote>
<p>Instead of returning plain values from a transformation function, it is also possible to return observable objects. This can be used to transform an observable data graph into a another observable data graph, which can be used to transform… you get the idea.</p>
<p>转换函数除了可以返回一般数据类型，还可以返回观测对象。所以也可以使用转换函数完成可观测对象间的转换。</p>
<p>Here is a small example that encodes a reactive file explorer that will update its representation upon each change. Data graphs that are built this way will in general react a lot faster and will consist of much more straight-forward code, compared to derived data graph that are updated using your own code. See the performance tests for some examples.</p>
<p>下面是个自动响应的文件管理器的例子。使用这种方式构建的数据结构，形式上更加简单直接，数据更新时响应速度也比一般的方式快的多。可以看一看这些例子的<a href="https://github.com/mobxjs/mobx/blob/master/test/perf/transform-perf.js#L10" target="_blank" rel="external">性能测试</a>。</p>
<p>Unlike the previous example, the transformFolder will only run once as long as a folder remains visible; the DisplayFolder objects track the associated Folder objects themselves.</p>
<p>不像之前的例子，如果文件夹一直可见，那么 <code>transformFolder</code> 只会运行一次；<code>DisplayFolder</code> 对象会追踪 <code>Folder</code> 对象的变化。</p>
<p>In the following example all mutations to the state graph will be processed automatically. Some examples:</p>
<p>下面的例子中，所有对 <code>state</code> 的改变都会自动处理。比如做如下操作：</p>
<ol>
<li><p>Changing the name of a folder will update it’s own path property and the path property of all its descendants.</p>
<p>改变文件夹的名字将更新它和它的子文件夹的文件路径，</p>
</li>
<li><p>Collapsing a folder will remove all descendant DisplayFolders from the tree.</p>
<p>折叠一个文件夹将会移除所有子文件夹的DisplayFolder实例</p>
</li>
<li><p>Expanding a folder will restore them again.</p>
<p>展开文件夹时，子文件夹再都恢复回来</p>
</li>
<li><p>Setting a search filter will remove all nodes that do not match the filter, unless they have a descendant that matches the filter.</p>
<p>如果设置了搜索过滤条件，将会只保留符合条件的子文件夹，其他的都会移除掉。<br>……</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;extendObservable, asFlat, observable, createTransformer, autorun&#125; <span class="keyword">from</span> mobx;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Folder</span>(<span class="params">parent, name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">    extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">name</span>: name,</div><div class="line">        <span class="attr">children</span>: asFlat([]),</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DisplayFolder</span>(<span class="params">folder, state</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.state = state;</div><div class="line">    <span class="keyword">this</span>.folder = folder;</div><div class="line">    extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">collapsed</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">name</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.folder.name;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">isVisible</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> !<span class="keyword">this</span>.state.filter || <span class="keyword">this</span>.name.indexOf(<span class="keyword">this</span>.state.filter) !== <span class="number">-1</span> || <span class="keyword">this</span>.children.some(<span class="function"><span class="params">child</span> =&gt;</span> child.isVisible);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">children</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.collapsed)</div><div class="line">                <span class="keyword">return</span> [];</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.folder.children.map(transformFolder).filter(<span class="function"><span class="keyword">function</span>(<span class="params">child</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> child.isVisible;</div><div class="line">            &#125;)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">path</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.folder.parent === <span class="literal">null</span> ? <span class="keyword">this</span>.name : transformFolder(<span class="keyword">this</span>.folder.parent).path + <span class="string">"/"</span> + <span class="keyword">this</span>.name;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> state = observable(&#123;</div><div class="line">    <span class="attr">root</span>: <span class="keyword">new</span> Folder(<span class="literal">null</span>, <span class="string">"root"</span>),</div><div class="line">    <span class="attr">filter</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">displayRoot</span>: <span class="literal">null</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> transformFolder = createTransformer(<span class="function"><span class="keyword">function</span> (<span class="params">folder</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DisplayFolder(folder, state);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    state.displayRoot = transformFolder(state.root);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h2><p><code>expr(worker: () =&gt; void)</code></p>
<p><code>expr</code> 可以在计算属性的函数中创建一个临时的计算属性，其实就是<code>computed(func).get()</code>。作者在文档中说设计这个api的意图是为了提升计算属性的性能，比如下面的例子，如果使用 <code>expr</code> 替代直接用比较运算，可以利用计算属性的缓存，减少运算次数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> TodoView = observer(<span class="function">(<span class="params">&#123;todo, editorState&#125;</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> isSelected = mobx.expr(<span class="function"><span class="params">()</span> =&gt;</span> editorState.selection === todo);</div><div class="line">    <span class="keyword">return</span> &lt;div className=&#123;isSelected ? "todo todo-selected" : "todo"&#125;&gt;&#123;todo.title&#125;&lt;/div&gt;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="extendObservable"><a href="#extendObservable" class="headerlink" title="extendObservable"></a>extendObservable</h2><p><code>extendObservable(target: object, ...properties: object)</code></p>
<p>在之前的几篇文章中，我们已经大概见过 <code>extendObservable</code> 应用的实例了。 <code>extendObservable</code>  和 <code>Object.assign</code> 类似，接受多个参数，将 <code>properties</code> 上所有的键值对，都合并到 <code>target</code> 上，同时把它们都转换成可观测的属性。</p>
<p>如果属性值是一个没有参数的函数，那 <code>extendObservable</code> 将用 <code>computed</code> 把它转化为一个计算属性。</p>
<p>所以，<code>observable(object)</code> 其实是 <code>extendObservable(object, object)</code>的别名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">firstName, lastName</span>) </span>&#123;</div><div class="line">    <span class="comment">// 在当前实例为观测对象</span></div><div class="line">    extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">        <span class="attr">firstName</span>: firstName,</div><div class="line">        <span class="attr">lastName</span>: lastName</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> matthew = <span class="keyword">new</span> Person(<span class="string">"Zheng"</span>, <span class="string">"Xingcheng"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 向观测对象上添加属性</span></div><div class="line">extendObservable(matthew, &#123;</div><div class="line">    <span class="attr">age</span>: <span class="number">30</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="isObservable"><a href="#isObservable" class="headerlink" title="isObservable"></a>isObservable</h2><p><code>isObservable(testValue:object, propertyName?: string)</code></p>
<p><code>isObservable</code> 是用来判断一个变量是不是用observable观测对象的，如果是就会返回true，如果想看变量的某个属性是否可观测，直接传入属性的引用是不行的，需要传第二个参数 <code>propertyName</code> 指定要判断哪个属性，如果属性可观测，就返回true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = observable(&#123;</div><div class="line">    <span class="attr">firstName</span>: <span class="string">"Zheng"</span>,</div><div class="line">    <span class="attr">lastName</span>: <span class="string">"Xingcheng"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">person.age = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(isObservable(person)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isObservable(person, <span class="string">"firstName"</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isObservable(person.firstName)); <span class="comment">// false (just a string)</span></div><div class="line"><span class="built_in">console</span>.log(isObservable(person, <span class="string">"age"</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>为了细化各种类型的判断，mobx还提供了map，array，object三种类型的判断，比起 <code>isObservable</code> ，他们的判断标准更严格，如果类型不符合就会返回false。</p>
<h3 id="isObservableMap"><a href="#isObservableMap" class="headerlink" title="isObservableMap"></a>isObservableMap</h3><p><code>isObservableMap(testValue:object)</code></p>
<p>如果<code>testValue</code>是用 <code>mobx.map</code> 创建的对象，则返回true。</p>
<h3 id="isObservableArray"><a href="#isObservableArray" class="headerlink" title="isObservableArray"></a>isObservableArray</h3><p><code>isObservableArray(testValue:object)</code></p>
<p>如果<code>testValue</code>是用 <code>mobx.observable(array)</code> 创建的对象，则返回true。</p>
<h3 id="isObservableObject"><a href="#isObservableObject" class="headerlink" title="isObservableObject"></a>isObservableObject</h3><p><code>isObservableObject(testValue:object)</code></p>
<p>如果<code>testValue</code>是用 <code>mobx.observable(object)</code> 创建的对象，则返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> testValue = observable(&#123;</div><div class="line">	<span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">    <span class="attr">obj</span>: &#123;</div><div class="line">    	<span class="attr">x</span>: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">map</span>: map([[<span class="string">'y'</span>,<span class="number">2</span>]])</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(isObservableMap(testValue.map)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isObservableArray(testValue.arr)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isObservableObject(testValue.obj)); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="modifiers"><a href="#modifiers" class="headerlink" title="modifiers"></a>modifiers</h2><h2 id="intercept-amp-observe"><a href="#intercept-amp-observe" class="headerlink" title="intercept &amp; observe"></a>intercept &amp; observe</h2><h2 id="reaction"><a href="#reaction" class="headerlink" title="reaction"></a>reaction</h2><h2 id="spy"><a href="#spy" class="headerlink" title="spy"></a>spy</h2><p><code>spy(listener)</code></p>
<p><code>spy</code> 可以注册一个全局的监听函数，监听所有的mobx发出的事件，通常是用来做log或者做调试的。</p>
<p>比如以下例子，会打印所有的action：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">spy(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (event.type === <span class="string">'action'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.name&#125;</span> with args: <span class="subst">$&#123;event.<span class="built_in">arguments</span>&#125;</span>`</span>)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>不同的操作，event也会不一样，下面的表格是每种事件对应的参数：</p>
<table>
<thead>
<tr>
<th>event</th>
<th>event带的属性</th>
<th>是否可以嵌套发生</th>
</tr>
</thead>
<tbody>
<tr>
<td>action</td>
<td>name, target (scope), arguments, fn (source function of the action)</td>
<td>yes</td>
</tr>
<tr>
<td>transaction</td>
<td>name, target (scope)</td>
<td>yes</td>
</tr>
<tr>
<td>scheduled-reaction</td>
<td>object (Reaction instance)</td>
<td>no</td>
</tr>
<tr>
<td>reaction</td>
<td>object (Reaction instance), fn (source of the reaction)</td>
<td>yes</td>
</tr>
<tr>
<td>compute</td>
<td>object (ComputedValue instance), target (scope), fn (source)</td>
<td>no</td>
</tr>
<tr>
<td>error</td>
<td>message</td>
<td>no</td>
</tr>
<tr>
<td>update (array)</td>
<td>object (the array), index, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>update (map)</td>
<td>object (observable map instance), name, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>update (object)</td>
<td>object (instance), name, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>splice (array)</td>
<td>object (the array), index, added, removed, addedCount, removedCount</td>
<td>yes</td>
</tr>
<tr>
<td>add (map)</td>
<td>object, name, newValue</td>
<td>yes</td>
</tr>
<tr>
<td>add (object)</td>
<td>object, name, newValue</td>
<td>yes</td>
</tr>
<tr>
<td>delete (map)</td>
<td>object, name, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>create (boxed observable)</td>
<td>object (ObservableValue instance), newValue</td>
<td>yes</td>
</tr>
</tbody>
</table>
<h2 id="toJS"><a href="#toJS" class="headerlink" title="toJS"></a>toJS</h2><p><code>toJS(value: any, supportCycles?=true: boolean)</code></p>
<p>toJS可以将一个observableObject下的转化为javascript原生的对象。他会递归转换array，object，map和基础类型的值，但是不会转换计算属性和其他不可枚举的值。默认情况下，toJS会缓存下每次运行的值，貌似作者设计这个api就是为了输出log用的，可以设置 <code>supportCycles</code> 参数为false来提高toJS的性能。</p>
<p>对于更复杂的序列化反序列化场景，mobx的作者推荐使用他开发的<a href="https://github.com/mobxjs/serializr" target="_blank" rel="external">serializr</a>库。</p>
<h2 id="transaction"><a href="#transaction" class="headerlink" title="transaction"></a>transaction</h2><p><code>transaction(worker: () =&gt; void)</code></p>
<p>在之前的 <code>autorunAsync</code> 有提到过，除了 <code>autorunAsync</code> ，还可以使用 <code>transaction</code> 来做批量处理。</p>
<p><code>transaction</code> 用来批处理一系列的更新，而不会通知观测对象，当所有更新结束，才会发出通知。<code>transaction</code> 接收一个没有参数的worker函数作为参数，在这个函数执行完成之前，不会通知观察者。<code>transaction</code> 的返回值就是worker函数的返回值。另外 <code>transaction</code> 是同步的，可以被嵌套，只有最外层的 <code>transaction</code> 执行完，才会触发响应。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;observable, transaction, autorun&#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> numbers = observable([]);</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(numbers.length, <span class="string">"numbers!"</span>));</div><div class="line"><span class="comment">// Prints: '0 numbers!'</span></div><div class="line"></div><div class="line">transaction(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    transaction(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        numbers.push(<span class="number">1</span>);</div><div class="line">        numbers.push(<span class="number">2</span>);</div><div class="line">    &#125;);</div><div class="line">    numbers.push(<span class="number">3</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// Prints: '3 numbers!'</span></div></pre></td></tr></table></figure>
<h2 id="untracked"><a href="#untracked" class="headerlink" title="untracked"></a>untracked</h2><p><code>untracked(fn: () =&gt; void)</code></p>
<p>使用 <code>untracked</code> 可以创建一个不被观测的代码块，通常 <code>untracked</code> 需要放在 <code>(@)action</code> 里面才有意义，比如以下的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> person = observable(&#123;</div><div class="line">    <span class="attr">firstName</span>: <span class="string">"Michel"</span>,</div><div class="line">    <span class="attr">lastName</span>: <span class="string">"Weststrate"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(</div><div class="line">        person.lastName,</div><div class="line">        <span class="string">","</span>,</div><div class="line">        <span class="comment">// person.firstName放在了untracked的回调里面，所以不会跟这个autorun的监听函数绑定到一起</span></div><div class="line">		<span class="comment">// 在修改person.firstName时就不会触发这个监听函数</span></div><div class="line">        untracked(<span class="function"><span class="params">()</span> =&gt;</span> person.firstName)</div><div class="line">    );</div><div class="line">&#125;);</div><div class="line"><span class="comment">// prints: Weststrate, Michel</span></div><div class="line"></div><div class="line">person.firstName = <span class="string">"G.K."</span>;</div><div class="line"><span class="comment">// doesn't print!</span></div><div class="line"></div><div class="line">person.lastName = <span class="string">"Chesterton"</span>;</div><div class="line"><span class="comment">// prints: Chesterton, G.K.</span></div></pre></td></tr></table></figure>
<h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p><code>when(debugName?, predicate: () =&gt; boolean, effect: () =&gt; void, scope?)</code></p>
<p><code>when</code> 会感测并运行参数predicate，predicate有点类似一个计算属性，当predicate为true的时候，则自动运行effect，然后销毁自己。所以 <code>when</code> 是一个只运行一次的 <code>autorun</code>。</p>
<p>下面这个例子展示了用 <code>when</code> 来实现自动销毁组件的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        when(</div><div class="line">            <span class="comment">// 当断言为真...</span></div><div class="line">            () =&gt; !<span class="keyword">this</span>.isVisible,</div><div class="line">            <span class="comment">// ... 则运行一次然后销毁</span></div><div class="line">            () =&gt; <span class="keyword">this</span>.dispose()</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @computed get isVisible() &#123;</div><div class="line">        <span class="comment">// 返回组件是否可见</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dispose() &#123;</div><div class="line">        <span class="comment">// 销毁组件</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇整理了下mobx的公共方法和作用。就此，基础api算是都介绍完了。之后会再着重写些使用方法和介绍mobx原理的内容。</p>
<p>话说最近懒癌又开始发作了……_(:3 」∠)_……看着朋友们跟打了鸡血一样写那么多blog好着急的说……希望以后能迎头赶上吧……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前几篇大概介绍了mobx最常用的几个方法，这次准备把剩余的公共方法都介绍了。&lt;/p&gt;
&lt;h2 id=&quot;autorunAsync&quot;&gt;&lt;a href=&quot;#autorunAsync&quot; class=&quot;headerlink&quot; title=&quot;autorunAsync&quot;&gt;&lt;/a&gt;autorunAsync&lt;/h2&gt;&lt;p&gt;&lt;code&gt;autorunAsync(debugName?: string, action: () =&amp;gt; void, minimumDelay?: number, scope?): disposer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;autorunAsync&lt;/code&gt; 的功能与 &lt;code&gt;autorun&lt;/code&gt; 相似，功能都是在观测对象发生变化时自动运行回调函数 &lt;code&gt;action&lt;/code&gt;。不同点在于 &lt;code&gt;autorun&lt;/code&gt; 是在观测对象发生变化时立即执行的，而 &lt;code&gt;autorunAsync&lt;/code&gt;是异步的，可以通过 &lt;code&gt;minimumDelay&lt;/code&gt; 参数来指定延迟的时间。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
      <category term="中文渣翻" scheme="http://brooch.me/tags/%E4%B8%AD%E6%96%87%E6%B8%A3%E7%BF%BB/"/>
    
  </entry>
  
  <entry>
    <title>MobX入坑指南(3) -- Observable Types</title>
    <link href="http://brooch.me/2016/12/09/MobX-simple-entry-3/"/>
    <id>http://brooch.me/2016/12/09/MobX-simple-entry-3/</id>
    <published>2016-12-09T05:29:04.000Z</published>
    <updated>2016-12-09T13:13:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周阅读了一部分mobx的源码，和作者写的几篇介绍文章，发现这个库有些特性还挺有趣的。以下的内容大部分翻译自<a href="http://mobxjs.github.io/mobx/" target="_blank" rel="external">mobx文档</a>中 <code>Observable Types</code> 一节，奈何小生英文水平有限，没有划词软件帮忙就看不懂句子……所以翻的很渣，基本上都是掺杂了一些我的理解在里边，连蒙带猜拼出来的，有啥写的不对的，也请多指教了~(￣▽￣)~*</p>
<p>在mobx中，如果你想监听某个变量的变化，需要先使用 <code>observable</code> 函数将其转化为生成Observable对象才行。这个章节主要讲的是 <code>observable</code> 函数生成的不同Observable对象</p>
<a id="more"></a>
<h2 id="Observable-Objects"><a href="#Observable-Objects" class="headerlink" title="Observable Objects"></a>Observable Objects</h2><p>当 <code>observable</code> 函数接受的参数是个普通的javascript object（普通javascript对象是指不是通过构造函数生成的对象，mobx的判断方式是，通过getPrototypeOf获取原型，检查是不是Object.prototype或者null）时，这个对象中的所有属性都将被传入 <code>observable</code> 函数进行转换，如果属性值是object或者array，则会递归的转化内部的元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;observable, autorun, action&#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = observable(&#123;</div><div class="line">    <span class="comment">// 常量会自动使用observable转化:</span></div><div class="line">    name: <span class="string">"John"</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">42</span>,</div><div class="line">    <span class="attr">showAge</span>: <span class="literal">false</span>,</div><div class="line">    <span class="comment">// 有get描述符的属性会自动使用computed转化:</span></div><div class="line">    get labelText() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.showAge ? <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> (age: <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>)`</span> : <span class="keyword">this</span>.name;</div><div class="line">    &#125;,</div><div class="line">	<span class="comment">// 如果直接写</span></div><div class="line">	<span class="comment">// labelText: function () &#123;</span></div><div class="line">    <span class="comment">//    return this.showAge ? `$&#123;this.name&#125; (age: $&#123;this.age&#125;)` : this.name;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">	<span class="comment">// 在自动转化时会报一个warning，mobx认为渲染函数需要用computed显式调动一下</span></div><div class="line">	<span class="comment">// labelText: computed(function () &#123;</span></div><div class="line">	<span class="comment">//    return this.showAge ? `$&#123;this.name&#125; (age: $&#123;this.age&#125;)` : this.name;</span></div><div class="line">	<span class="comment">// &#125;)</span></div><div class="line">    <span class="comment">// 同理，action也需要显式调动一下:</span></div><div class="line">    setAge: action(<span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(person.labelText));</div><div class="line"></div><div class="line">person.name = <span class="string">"Dave"</span>;</div><div class="line"><span class="comment">// 'Dave'</span></div><div class="line"></div><div class="line">person.setAge(<span class="number">21</span>);</div><div class="line"><span class="built_in">console</span>.log(person.age);</div><div class="line"><span class="comment">// 21</span></div></pre></td></tr></table></figure>
<p>需要注意的点：</p>
<ul>
<li><p>当对象传入 <code>observable</code> 函数时，只有当时对象上已经存在的属性才能被监听，后添加的属性是不能的，如果想要往已经生成的Observable对象上添加属性，需要使用<a href="http://mobxjs.github.io/mobx/refguide/extend-observable.html" target="_blank" rel="external"><code>extendObservable</code></a>函数进行类似merge的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//接上面的例子</span></div><div class="line">extendObservable(person, &#123;</div><div class="line">    <span class="attr">sex</span>: <span class="string">'male'</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(person.sex);</div><div class="line"><span class="comment">// 'male'</span></div></pre></td></tr></table></figure>
</li>
<li><p>只有普通对象能够被转化为Observable对象。使用构造函数创建的对象，需要在构造函数初始化时使用<a href="http://mobxjs.github.io/mobx/refguide/extend-observable.html" target="_blank" rel="external"><code>extendObservable</code></a>函数合并属性。使用类创建的对象，需要使用 <a href="http://mobxjs.github.io/mobx/refguide/observable-decorator.html" target="_blank" rel="external"><code>@observable</code></a>装饰器包装类的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">firstName, lastName</span>) </span>&#123;</div><div class="line">	<span class="comment">// 在一个新的对象里写要监听的属性，然后merge和当前实例merge</span></div><div class="line">	extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">		<span class="attr">firstName</span>: firstName,</div><div class="line">		<span class="attr">lastName</span>: lastName</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> zxc = <span class="keyword">new</span> Person(<span class="string">"Zheng"</span>, <span class="string">"Xingcheng"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 或者</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    @observable firstName:string = <span class="string">""</span>;</div><div class="line">    @observable lastName:string = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(firstName, lastName) &#123;</div><div class="line">		<span class="keyword">this</span>.firstName = firstName;</div><div class="line">		<span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> zxc = <span class="keyword">new</span> Person(<span class="string">"Zheng"</span>, <span class="string">"Xingcheng"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>带有get描述符的属性会自动被<a href="http://mobxjs.github.io/mobx/refguide/computed-decorator" target="_blank" rel="external"><code>@computed</code></a>转化，第一个例子中已经展示了。</p>
</li>
<li>如果对象的属性值是一个构造函数生成的对象（我真是不想把它叫成”非普通对象”……），那这个属性也不会被 <code>observable</code> 函数自动转化。</li>
<li>基本上使用<code>observable</code> 函数自动转化已经能解决绝大部分的使用场景了（原文写的是”95% of the cases”……）。如果想要了解更详细的设定每个属性的方法，请看 <a href="http://mobxjs.github.io/mobx/refguide/modifiers.html" target="_blank" rel="external"><code>modifiers</code></a> 一章（本来这一章的内容也想发到这里的，但是实在是没时间写了只能拉倒……等下次吧）。</li>
</ul>
<h2 id="Observable-Arrays"><a href="#Observable-Arrays" class="headerlink" title="Observable Arrays"></a>Observable Arrays</h2><p>和 object 类似，array 也可以使用 <code>observable</code>函数转化为ObservableArray对象。当然，也是递归转化每个元素的，所以数组的所有元素也会被转化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;observable, autorun&#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> todos = observable([</div><div class="line">    &#123; <span class="attr">title</span>: <span class="string">"吃午饭"</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</div><div class="line">    &#123; <span class="attr">title</span>: <span class="string">"喝咖啡"</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</div><div class="line">]);</div><div class="line"></div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"代办:"</span>, todos</div><div class="line">        .filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed)</div><div class="line">        .map(<span class="function"><span class="params">todo</span> =&gt;</span> todo.title)</div><div class="line">        .join(<span class="string">", "</span>)</div><div class="line">    );</div><div class="line">&#125;);</div><div class="line"><span class="comment">// '代办: 喝咖啡'</span></div><div class="line"></div><div class="line">todos[<span class="number">0</span>].completed = <span class="literal">false</span>;</div><div class="line"><span class="comment">// '代办: 吃午饭, 喝咖啡'</span></div><div class="line"></div><div class="line">todos[<span class="number">2</span>] = &#123; <span class="attr">title</span>: <span class="string">"睡午觉"</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;;</div><div class="line"><span class="comment">// '代办: 吃午饭, 喝咖啡, 睡午觉'</span></div><div class="line"></div><div class="line">todos.shift();</div><div class="line"><span class="comment">// '代办: 喝咖啡, 睡午觉'</span></div></pre></td></tr></table></figure>
<p>由于ES5中原生数组的限制（<code>array.observe</code>到ES7中才有，而且数组不能扩展），<code>observable</code>函数基于原始数组克隆了一个新的数组，这个新数组支持所有原生数组的方法和功能，同时还有监听值变化的能力。</p>
<p>不过，当使用Array.isArray检查包装后数组时返回的是false。所以在跟其他库联合使用时，如果想把ObservableArray对象当做数组传递给其他库，最好使用浅拷贝生成新数组，或者使用 <code>array.slice</code> 方法生成新数组，就是说 <code>Array.isArray(observable([]).slice())</code> 返回的是true。</p>
<p>由于不喜欢原生的 <code>array.sort</code> 和 <code>array.reverse</code> 方法，ObservableArray对象的 <code>sort</code> 和 <code>reverse</code> 方法是并不会改变自身的，而是返回一个新的ObservableArray对象。</p>
<p>除了原生数组支持的方法，ObservableArray对象还可以使用以下的方法：</p>
<ul>
<li><code>intercept(interceptor)</code><br>这个方法可以在所有数组的操作被应用之前，将操作拦截。具体的请看<a href="http://mobxjs.github.io/mobx/refguide/observe.html" target="_blank" rel="external">observe &amp; intercept</a></li>
<li><code>observe(listener, fireImmediately? = false)</code><br>这个方法可以监听数组的变化，回调函数会接收数组新增或者修改的元素，符合<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/observe" target="_blank" rel="external">ES7的规范</a>。这个方法返回一个注销函数用来停止监听。</li>
<li><code>clear()</code><br>清空数组。</li>
<li><code>replace(newItems)</code><br>替换数组里的所有元素。</li>
<li><code>find(predicate: (item, index, array) =&gt; boolean, thisArg?, fromIndex?)</code><br>使用方法与ES7的 <code>array.find</code> 一致，但是增加了formIndex参数。</li>
<li><code>remove(value)</code><br>移除数组中第一个值等于value的元素，如果移除成功会返回true。</li>
<li><code>peek()</code><br>与 <code>slice</code> 类似，会返回一个包含所有元素的数组。它与 <code>slice</code> 的区别在于 <code>peek</code> 不会进行保护性拷贝，所以性能更好。</li>
</ul>
<h2 id="Observable-Maps"><a href="#Observable-Maps" class="headerlink" title="Observable Maps"></a>Observable Maps</h2><p><code>observable(asMap(values?, modifier?))</code> 和 <code>map(values?, modifier?))</code> 方法可以创建一个ObservableMap对象。如果你不想响应特定属性的变化，还要添加删除属性，那么使用ObservableMap对象很合适。不同于ES6的Map对象，ObservableMap对象是能用字符串当做key。</p>
<p>根据ES6 Map的规范，可以使用以下方法:</p>
<ul>
<li><code>has(key)</code><br>返回map中是否存在这个key，这个方法是可被监听的</li>
<li><code>set(key, value)</code><br>设置key对应的value，如果key之前不错在，那么这个key会被添加上</li>
<li><code>delete(key)</code><br>删除key和key对应的value</li>
<li><code>get(key)</code><br>获取key对应的value，如果没找到会返回undefined</li>
<li><code>keys()</code><br>获取map的所有key，顺序为key的插入顺序</li>
<li><code>values()</code><br>获取map的所有key对应的value，顺序为key的插入顺序</li>
<li><code>entries()</code><br>返回一个数组，数组中每个元素为一个数组，数组中的元素为map中的key/value对，形式如[key, value]，顺序为key的插入顺序</li>
<li><code>forEach(callback:(value, key, map) =&gt; void, thisArg?)</code><br>对map中的每个key/value对调用回调</li>
<li><code>clear()</code><br>清除map中的所有key/value对</li>
<li><code>size()</code><br>返回map中所有key/value对的数量</li>
</ul>
<p>ObservableMap对象还提供了以下方法可以使用:</p>
<ul>
<li><code>toJS()</code><br>返回一个map的浅拷贝的对象，如果想获得深拷贝的对象，需要使用 <code>mobx.toJS(map)</code></li>
<li><code>intercept(interceptor)</code><br>注册一个拦截器，拦截器会在map被修改之前被触发。具体的请看<a href="http://mobxjs.github.io/mobx/refguide/observe.html" target="_blank" rel="external">observe &amp; intercept</a></li>
<li><code>observe(listener, fireImmediately?)</code><br>注册一个监听，map被修改时会被触发。与Object.observe类似。具体的请看<a href="http://mobxjs.github.io/mobx/refguide/observe.html" target="_blank" rel="external">observe &amp; intercept</a></li>
<li><code>merge(object | map)</code><br>将对象上所有的属性拷贝到当前map中</li>
</ul>
<h2 id="Primitive-常量）"><a href="#Primitive-常量）" class="headerlink" title="Primitive (常量）"></a>Primitive (常量）</h2><p>在javascript中，常量是不可变的，所以也没办法观测。所以如果想要监听一个常量属性的变化，需要使用 <code>observable</code> 函数包装一下。</p>
<p><code>observable</code> 函数包装后会返回一个ObservablePrimitive对象。这个对象使用get和set方法来获取和改变变量的值。可以使用 <code>.observe</code> 方法来监听值的变化。不过通常使用 <code>mobx.autorun</code> 是更好的选择。</p>
<p>以下是ObservablePrimitive支持的方法：</p>
<ul>
<li><code>get()</code><br>返回当前值</li>
<li><code>set(value)</code><br>替换当前存储的值，并通知所有的监听器</li>
<li><code>intercept(interceptor)</code><br>注册拦截器，当值发生变化前触发。具体的请看<a href="http://mobxjs.github.io/mobx/refguide/observe.html" target="_blank" rel="external">observe &amp; intercept</a></li>
<li><code>observe(callback: (newValue, previousValue) =&gt; void, fireImmediately = false)</code><br>注册监听器，当值发生变化时触发，返回一个注销函数。具体的请看<a href="http://mobxjs.github.io/mobx/refguide/observe.html" target="_blank" rel="external">observe &amp; intercept</a></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;observable&#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> cityName = observable(<span class="string">"Vienna"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(cityName.get());</div><div class="line"><span class="comment">// 'Vienna'</span></div><div class="line"></div><div class="line">cityName.observe(<span class="function"><span class="keyword">function</span>(<span class="params">newCity, oldCity</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(oldCity, <span class="string">"-&gt;"</span>, newCity);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">cityName.set(<span class="string">"Amsterdam"</span>);</div><div class="line"><span class="comment">// 'Vienna -&gt; Amsterdam'</span></div></pre></td></tr></table></figure>
<h2 id="References-引用类型）"><a href="#References-引用类型）" class="headerlink" title="References (引用类型）"></a>References (引用类型）</h2><p>之前在ObservableObject中提到，observable在转换时会自动用computed包装函数，这个自动转换其实是由限制条件的。mobx只会转换渲染用的函数，既函数不能接受参数，如果接受参数，则认为这个是一个复合函数，就不会自动转化。同样的，如果对象中有属性是通过构造函数或者类创建的对象，也不会自动转化。他们都继续保持着转化之前的引用。</p>
<p>有时我们也会有这一类的需求，要求对象中某个属性不被自动转化。可以使用 <code>asReference</code> 来达到这一目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = observable(&#123;</div><div class="line">    <span class="attr">x</span> : <span class="number">3</span>,</div><div class="line">    <span class="attr">doubler</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x*<span class="number">2</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">someFunc</span>: asReference(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</div><div class="line">    &#125;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(test.doubler);</div><div class="line"><span class="comment">// 6</span></div><div class="line"><span class="built_in">console</span>.log(test.someFunc);</div><div class="line"><span class="comment">// function() &#123;</span></div><div class="line"><span class="comment">//     return this.x;</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体感觉上，mobx的api和knockout的api很像，但是在实现原理上，更像rx。mobx实现监听变化调用回调的过程是同步的，通过这种方式就能会自动的分析各个变量间的调用关系，从而减少重复订阅的情况。同时计算最新的值时还是用了memoizing技术，这样就算调用频繁，性能上也能得到保证。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="http://mobxjs.github.io/mobx/refguide/object.html" target="_blank" rel="external">Observable Objects</a></li>
<li><a href="http://mobxjs.github.io/mobx/refguide/array.html" target="_blank" rel="external">Observable Arrays</a></li>
<li><a href="http://mobxjs.github.io/mobx/refguide/map.html" target="_blank" rel="external">Observable Maps</a></li>
<li><a href="http://mobxjs.github.io/mobx/refguide/boxed.html" target="_blank" rel="external">Primitive values and references</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周阅读了一部分mobx的源码，和作者写的几篇介绍文章，发现这个库有些特性还挺有趣的。以下的内容大部分翻译自&lt;a href=&quot;http://mobxjs.github.io/mobx/&quot;&gt;mobx文档&lt;/a&gt;中 &lt;code&gt;Observable Types&lt;/code&gt; 一节，奈何小生英文水平有限，没有划词软件帮忙就看不懂句子……所以翻的很渣，基本上都是掺杂了一些我的理解在里边，连蒙带猜拼出来的，有啥写的不对的，也请多指教了~(￣▽￣)~*&lt;/p&gt;
&lt;p&gt;在mobx中，如果你想监听某个变量的变化，需要先使用 &lt;code&gt;observable&lt;/code&gt; 函数将其转化为生成Observable对象才行。这个章节主要讲的是 &lt;code&gt;observable&lt;/code&gt; 函数生成的不同Observable对象&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
      <category term="中文渣翻" scheme="http://brooch.me/tags/%E4%B8%AD%E6%96%87%E6%B8%A3%E7%BF%BB/"/>
    
  </entry>
  
  <entry>
    <title>MobX入坑指南(2) -- action</title>
    <link href="http://brooch.me/2016/11/29/MobX-simple-entry-2/"/>
    <id>http://brooch.me/2016/11/29/MobX-simple-entry-2/</id>
    <published>2016-11-29T12:40:50.000Z</published>
    <updated>2016-12-09T05:43:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2016/11/29/MobX-simple-entry-1/">上一篇</a>简单介绍了下mobx常用的几个api(observable、computed、autorun)，以及mobx-react的api(observer)。这次说说action。</p>
<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>用法：</p>
<ul>
<li>action(fn)</li>
<li>action(name, fn)</li>
<li>@action classMethod</li>
<li>@action(name) classMethod</li>
<li>@action boundClassMethod = (args) =&gt; { body }</li>
<li>@action(name) boundClassMethod = (args) =&gt; { body }</li>
</ul>
<p>之前的例子里使用了回调的方式来触发响应，mobx其实也支持使用flux的方式来出发响应，并且在2.2版本提供了action的功能。</p>
<p>action是一个工厂函数，可以接受name和fn两个参数，name是String，主要描述action的作用，fn是Function，是这个action的具体逻辑。action执行后返回一个函数，调用这个函数就会执行action，其实就是调用fn参数。</p>
<p>个人感觉在mobx中，action的作用更多的是用来注释当前的操作……使用的时候在name参数上写操作是干啥的，能够快速的了解action的意图。当然如果安装了devtools，action还能输出调试信息。</p>
<p>需要注意的是，如果使用<a href="https://github.com/mobxjs/mobx/blob/gh-pages/docs/refguide/api.md#usestrict" target="_blank" rel="external">useStrict</a>api开启了严格模式，就必须通过action才能修改状态(state)，直接修改值会报错。</p>
<p>举个🌰</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;observable, useStrict, action, computed, autorun&#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</div><div class="line"></div><div class="line">useStrict(<span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = observable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line"><span class="keyword">let</span> sum = computed(<span class="function"><span class="params">()</span> =&gt;</span> numbers.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>));</div><div class="line"></div><div class="line"><span class="keyword">let</span> disposer1 = autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`sum:<span class="subst">$&#123;sum.get()&#125;</span>`</span>));</div><div class="line"><span class="comment">// sum:6</span></div><div class="line"><span class="keyword">let</span> disposer2 = autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`length:<span class="subst">$&#123;numbers.length&#125;</span>`</span>));</div><div class="line"><span class="comment">// length:3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> pushNumber = action(<span class="string">'push number'</span>,()=&gt;&#123;</div><div class="line">	numbers.push(<span class="number">4</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">pushNumber(<span class="number">4</span>)</div><div class="line"><span class="comment">// sum:10</span></div><div class="line"><span class="comment">// length:4</span></div><div class="line"></div><div class="line">numbers.push(<span class="number">5</span>)</div><div class="line"><span class="comment">// Uncaught Error: [mobx] Invariant failed: It is not allowed to create</span></div><div class="line"><span class="comment">// or change state outside an `action` when MobX is in strict mode. Wrap</span></div><div class="line"><span class="comment">// the current method in `action` if this state change is intended.</span></div></pre></td></tr></table></figure>
<p>另外，action在执行时是可以接受参数的，而且action在执行后还会返回fn参数的返回值，这一点文档里没有明显的说明，害的我翻源码才翻出来的……┑(￣Д ￣)┍……话说mobx是用typescript写的呢。虽然ts最近很火，而且功能也确实挺实用的，但是我对java一样死板的语法却怎么都都爱不起来……所以更看好<a href="https://www.zhihu.com/question/31415286/answer/58022648" target="_blank" rel="external">WebAssembly</a>一些……</p>
<p>扯远了扯远了……那么我们再把上面那个例子修改一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;observable, useStrict, action, computed, autorun&#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</div><div class="line"></div><div class="line">useStrict(<span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = observable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line"><span class="keyword">let</span> sum = computed(<span class="function"><span class="params">()</span> =&gt;</span> numbers.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>));</div><div class="line"><span class="comment">// sum:6</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> disposer = autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`sum:<span class="subst">$&#123;sum.get()&#125;</span>`</span>));</div><div class="line"></div><div class="line"><span class="keyword">var</span> pushNumber = action(<span class="string">'push number'</span>,(number)=&gt;numbers.push(number))</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">`length:<span class="subst">$&#123;pushNumber(<span class="number">6</span>)&#125;</span>`</span>)</div><div class="line"><span class="comment">// sum:12</span></div><div class="line"><span class="comment">// length:4</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">`length:<span class="subst">$&#123;pushNumber(<span class="number">7</span>)&#125;</span>`</span>)</div><div class="line"><span class="comment">// sum:19</span></div><div class="line"><span class="comment">// length:5</span></div></pre></td></tr></table></figure>
<p>从上面的例子可以看到，传入pushNumber的参数最后被传入了action的fn中，然后pushNumber返回了push的返回值。</p>
<p>官方文档中的一个例子也能看到调用action返回函数时传递参数的应用场景：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@action createRandomContact() &#123;</div><div class="line">	<span class="keyword">this</span>.pendingRequestCount++;</div><div class="line">	superagent</div><div class="line">		.get(<span class="string">'https://randomuser.me/api/'</span>)</div><div class="line">		.set(<span class="string">'Accept'</span>, <span class="string">'application/json'</span>)</div><div class="line">		.end(action(<span class="string">"createRandomContact-callback"</span>, (error, results) =&gt; &#123;</div><div class="line">			<span class="keyword">if</span> (error)</div><div class="line">				<span class="built_in">console</span>.error(error);</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(results.text).results[<span class="number">0</span>];</div><div class="line">				<span class="keyword">const</span> contact = <span class="keyword">new</span> Contact(<span class="keyword">this</span>, data.dob, data.name, data.login.username, data.picture)</div><div class="line">				contact.addTag(<span class="string">'random-user'</span>);</div><div class="line">				<span class="keyword">this</span>.contacts.push(contact);</div><div class="line">				<span class="keyword">this</span>.pendingRequestCount--;</div><div class="line">			&#125;</div><div class="line">		&#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个🌰中可以看到，action的返回值作为superagent.end的回调，接收error和results两个参数，最后传入fn进行处理。这个例子也引出了另一个问题，action中如何处理一步操作。</p>
<h2 id="async-action-和-runInAction"><a href="#async-action-和-runInAction" class="headerlink" title="async action 和 runInAction"></a>async action 和 runInAction</h2><p>action只能影响正在运行的函数，而无法影响当前函数调用的异步操作。也就是说如果fn中有setTimeout，promise.then，async函数，并且这些函数的回调里对state进行了修改，那么这些回调也应该用action包装一下（在非严格模式下，action和直接修改state值都能生效，所以并不会出现异常，如果是严格模式下就会报错）。</p>
<p>还有，如果要使用<code>async</code>函数作为action，不能直接用action包装<code>async</code>函数，这里需要使用一个tricky，将一个<code>async</code>匿名函数赋值给一个变量或者属性再做包装。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@action updateDocument = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> fetchDataFromUrl();</div><div class="line">    <span class="comment">/* required in strict mode to be allowed to update state: */</span></div><div class="line">    runInAction(<span class="string">"update state after fetching data"</span>, () =&gt; &#123;</div><div class="line">        <span class="keyword">this</span>.data.replace(data);</div><div class="line">        <span class="keyword">this</span>.isSaving = <span class="literal">true</span>;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子还用到了<code>runInAction</code>，它其实就是action(name,fn)()的语法糖，调用后action会立即执行，它的用法是：<code>runInAction(name?, fn, scope?)</code>，scope是fn调用时的this指向。注：2.3.0版本以后才能使用。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="http://mobxjs.github.io/mobx/refguide/action.html" target="_blank" rel="external">MobX Documentation – action</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2016/11/29/MobX-simple-entry-1/&quot;&gt;上一篇&lt;/a&gt;简单介绍了下mobx常用的几个api(observable、computed、autorun)，以及mobx-react的api(observer)。这次说说action。&lt;/p&gt;
&lt;h2 id=&quot;action&quot;&gt;&lt;a href=&quot;#action&quot; class=&quot;headerlink&quot; title=&quot;action&quot;&gt;&lt;/a&gt;action&lt;/h2&gt;&lt;p&gt;用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;action(fn)&lt;/li&gt;
&lt;li&gt;action(name, fn)&lt;/li&gt;
&lt;li&gt;@action classMethod&lt;/li&gt;
&lt;li&gt;@action(name) classMethod&lt;/li&gt;
&lt;li&gt;@action boundClassMethod = (args) =&amp;gt; { body }&lt;/li&gt;
&lt;li&gt;@action(name) boundClassMethod = (args) =&amp;gt; { body }&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前的例子里使用了回调的方式来触发响应，mobx其实也支持使用flux的方式来出发响应，并且在2.2版本提供了action的功能。&lt;/p&gt;
&lt;p&gt;action是一个工厂函数，可以接受name和fn两个参数，name是String，主要描述action的作用，fn是Function，是这个action的具体逻辑。action执行后返回一个函数，调用这个函数就会执行action，其实就是调用fn参数。&lt;/p&gt;
&lt;p&gt;个人感觉在mobx中，action的作用更多的是用来注释当前的操作……使用的时候在name参数上写操作是干啥的，能够快速的了解action的意图。当然如果安装了devtools，action还能输出调试信息。&lt;/p&gt;
&lt;p&gt;需要注意的是，如果使用&lt;a href=&quot;https://github.com/mobxjs/mobx/blob/gh-pages/docs/refguide/api.md#usestrict&quot;&gt;useStrict&lt;/a&gt;api开启了严格模式，就必须通过action才能修改状态(state)，直接修改值会报错。&lt;/p&gt;
&lt;p&gt;举个🌰&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React全家桶又填新成员 MobX入坑指南(1)</title>
    <link href="http://brooch.me/2016/11/23/MobX-simple-entry-1/"/>
    <id>http://brooch.me/2016/11/23/MobX-simple-entry-1/</id>
    <published>2016-11-23T14:34:10.000Z</published>
    <updated>2016-12-09T05:43:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>话说，吐槽被react全家桶坑的文章已经算是各大论坛上的月经贴了吧……行内样式、jsx里html和js混排、依赖太多、学习曲线陡峭……当然其中不乏抱怨redux反人类的……</p>
<p>当然，这篇文章并不是来黑react不好的，毕竟以后涨工资还得靠它呢哈哈哈(￣▽￣)……</p>
<p>今天咱们要说的是众多槽点之一，”反人类的redux”和其替代方案。<br><a id="more"></a></p>
<h2 id="redux有什么不好？"><a href="#redux有什么不好？" class="headerlink" title="redux有什么不好？"></a>redux有什么不好？</h2><p>首先，redux绝对是个优秀的库。它体小精悍，api简单优雅，扩展能力强，足以衍生出丰富的工具集和生态系统。在它出现之前，各种flux实现貌似都不能让人如意，以至于有人宁可用 backbone 甚至是 angular 和 react搭配，也不用flux……后来redux出现，解决了flux操作繁琐的问题，开始受到人们的关注，再后来作者也加入了 facebook从事react的开发，redux也顺理成章的成为了react官方推荐状态管理库。</p>
<p>但是，在真正去开发的时候，我发现状态的维护还是有些繁琐，如果你在设计阶段没有考虑周全，开发时就要不停的在action,container,reducer之前修改，穿梭，让人眼花缭乱……嗯，也没准儿是我项目不够大……</p>
<p>另外，由于redux大量使用函数式编程的思想，门槛有点高呢。当时为了理解redux里面的概念，我大概读了一周的文档……</p>
<p>按你胃（Anywhere），如果你更熟悉面向对象，羡慕mvvm框架的简单，那你真的应该体验一下mobx</p>
<h2 id="mobx是啥？"><a href="#mobx是啥？" class="headerlink" title="mobx是啥？"></a>mobx是啥？</h2><p>mobx是个新的状态管理库，响应式的，我是看了<a href="http://weibo.com/1400854834/EdqkGrQh6" target="_blank" rel="external">阮一峰的微博</a>知道的，后来查了资料发现，redux的作者在twitter推荐了这个库，还是作为redex的替代品……</p>
<p>那么废话少说，让我们现在看看mobx怎么用吧</p>
<h2 id="api简单介绍"><a href="#api简单介绍" class="headerlink" title="api简单介绍"></a>api简单介绍</h2><p>和redux一样，mobx是一个独立的库，不依赖于react也能自己用，它只有三个概念：观测状态，计算值和反应。这三个概念分别对应三个mobx的api：observable，computed和autorun。</p>
<p>咱们先来个最简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; observable, computed, autorun &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = observable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line"><span class="keyword">let</span> sum = computed(<span class="function"><span class="params">()</span> =&gt;</span> numbers.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>));</div><div class="line"></div><div class="line"><span class="keyword">let</span> disposer1 = autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`sum:<span class="subst">$&#123;sum.get()&#125;</span>`</span>));</div><div class="line"><span class="keyword">let</span> disposer2 = autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`length:<span class="subst">$&#123;numbers.length&#125;</span>`</span>));</div><div class="line"><span class="comment">// sum:6</span></div><div class="line"><span class="comment">// length:3</span></div><div class="line"></div><div class="line">numbers.push(<span class="number">4</span>);</div><div class="line"><span class="comment">// sum:10</span></div><div class="line"><span class="comment">// length:4</span></div><div class="line"></div><div class="line">disposer2();</div><div class="line">numbers.push(<span class="number">5</span>);</div><div class="line"><span class="comment">// sum:15</span></div></pre></td></tr></table></figure>
<p>这个例子中，observable用来绑定数据；computed用来绑定计算方法；autorun用来注册数据变化时响应的方法，返回的函数用来取消响应。</p>
<p>下面我们试着来写一个TodoList</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; observable, computed, autorun &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</div><div class="line">    id = <span class="built_in">Math</span>.random();</div><div class="line">    @observable content;</div><div class="line">    @observable finished = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">constructor</span>(content) &#123;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> </span>&#123;</div><div class="line">    @observable todos = [];</div><div class="line">    @computed get todoListString() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.finished).map(<span class="function">(<span class="params">todo, i</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>. <span class="subst">$&#123;todo.content&#125;</span>`</span>).join(<span class="string">'\n'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> TodoList();</div><div class="line"></div><div class="line">store.todos.push(</div><div class="line">    <span class="keyword">new</span> Todo(<span class="string">"task1"</span>),</div><div class="line">    <span class="keyword">new</span> Todo(<span class="string">"task2"</span>),</div><div class="line">    <span class="keyword">new</span> Todo(<span class="string">"task3"</span>)</div><div class="line">);</div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.todoListString))</div><div class="line"></div><div class="line">store.todos[<span class="number">2</span>].finished = <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<p>从上面的例子可以看到，针对类的属性，可以使用修饰器@observable、@computed来进行绑定，修饰器是ES7的一个提案，目前Babel已经支持。详细的介绍可以看<a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="external">ECMAScript 6 入门中修饰器一章</a></p>
<p>如果不想用修饰器，也可以使用extendObservable函数，跟修饰器的功能是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; extendObservable, autorun &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</div><div class="line">    id = <span class="built_in">Math</span>.random();</div><div class="line">    <span class="keyword">constructor</span>(content) &#123;</div><div class="line">		extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">			<span class="attr">content</span>: content,</div><div class="line">			<span class="attr">finished</span>: <span class="literal">false</span></div><div class="line">		&#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>() &#123;</div><div class="line">		extendObservable(<span class="keyword">this</span>, &#123;</div><div class="line">			<span class="attr">todos</span>: [],</div><div class="line">			<span class="attr">todoListString</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		        <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.finished).map(<span class="function">(<span class="params">todo, i</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>. <span class="subst">$&#123;todo.content&#125;</span>`</span>).join(<span class="string">'\n'</span>);</div><div class="line">		    &#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> TodoList();</div><div class="line"></div><div class="line">store.todos.push(</div><div class="line">    <span class="keyword">new</span> Todo(<span class="string">"task1"</span>),</div><div class="line">    <span class="keyword">new</span> Todo(<span class="string">"task2"</span>),</div><div class="line">    <span class="keyword">new</span> Todo(<span class="string">"task3"</span>)</div><div class="line">);</div><div class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.todoListString))</div><div class="line"></div><div class="line">store.todos[<span class="number">2</span>].finished = <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<h2 id="mobx-react"><a href="#mobx-react" class="headerlink" title="mobx-react"></a>mobx-react</h2><p>在跟react配合时，mobx提供了mobx-react包，使用@observer装饰器或者observer函数，可以自动将react组建的render方法包装到mobx.autorun里面。还是以前面的TodoList为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; observable, computed &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</div><div class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> mobxReact;</div><div class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> React;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</div><div class="line">    id = <span class="built_in">Math</span>.random();</div><div class="line">    @observable content;</div><div class="line">    @observable finished = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">constructor</span>(content) &#123;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">    &#125;</div><div class="line">    finish() &#123;</div><div class="line">      <span class="keyword">this</span>.finished = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> </span>&#123;</div><div class="line">    @observable todos = [];</div><div class="line">    @computed get unFinishedList() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.finished);</div><div class="line">	&#125;</div><div class="line">    @computed get finishedList() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.finished);</div><div class="line">    &#125;</div><div class="line">	addTodo(content) &#123;</div><div class="line">	  	<span class="keyword">if</span> (content)&#123;</div><div class="line">			<span class="keyword">this</span>.todos.push(<span class="keyword">new</span> Todo(content))</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@observer</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoListView</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">		<span class="keyword">const</span> &#123; todoList &#125; = <span class="keyword">this</span>.props;</div><div class="line">		<span class="keyword">let</span> onChange = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</div><div class="line">	    	<span class="keyword">this</span>.value = event.target.value</div><div class="line">	    &#125;</div><div class="line">		<span class="keyword">let</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123; todoList.addTodo(<span class="keyword">this</span>.value) &#125;</div><div class="line">        <span class="keyword">return</span> (&lt;div&gt;</div><div class="line">			&lt;h2&gt;添加任务&lt;/h2&gt;</div><div class="line">			&lt;input type="text" value=&#123; this.value &#125; onChange=&#123; onChange &#125;/&gt;</div><div class="line">			&lt;button type="button" onClick=&#123; onClick &#125;&gt;添加&lt;/button&gt;</div><div class="line">			&lt;h2&gt;未完成任务&lt;/h2&gt;</div><div class="line">            &lt;ol&gt;</div><div class="line">                &#123;todoList.unFinishedList.slice(0).map((todo,index) =&gt;</div><div class="line">                    &lt;TodoView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt;</div><div class="line">                )&#125;</div><div class="line">            &lt;/ol&gt;</div><div class="line">            Tasks left: &#123;todoList.unFinishedList.length&#125;</div><div class="line">			&lt;h2&gt;已完成任务&lt;/h2&gt;</div><div class="line">			&lt;ol&gt;</div><div class="line">                &#123;todoList.finishedList.map((todo) =&gt;</div><div class="line">                    &lt;FinishedView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt;</div><div class="line">                )&#125;</div><div class="line">            &lt;/ol&gt;</div><div class="line">        &lt;/div&gt;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const TodoView = observer((props) =&gt;</div><div class="line">&#123;</div><div class="line">		let &#123; todo &#125; = props;</div><div class="line">    return (&lt;li&gt;</div><div class="line">            &lt;input</div><div class="line">                type="checkbox"</div><div class="line">                checked=&#123;todo.finished&#125;</div><div class="line">                onClick=&#123;todo.finish.bind(todo)&#125;</div><div class="line">                /&gt;&#123;todo.content&#125;</div><div class="line">        &lt;/li&gt;)</div><div class="line">    &#125;</div><div class="line">);</div><div class="line"></div><div class="line">@observer</div><div class="line">class FinishedView extends Component&#123;</div><div class="line">	render() &#123;</div><div class="line">		let &#123; todo &#125; = this.props;</div><div class="line">	  return (&lt;li&gt;</div><div class="line">	        &lt;del&gt;&#123;todo.content&#125;&lt;/del&gt;</div><div class="line">	    &lt;/li&gt;)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const store = new TodoList();</div><div class="line"></div><div class="line">React.render(&lt;TodoListView todoList=&#123;store&#125; /&gt;, document.body);</div><div class="line"></div><div class="line">store.todos.push(</div><div class="line">    new Todo("Get Coffee"),</div><div class="line">    new Todo("Write simpler code")</div><div class="line">);</div></pre></td></tr></table></figure>
<p>在上面的例子里可以看到，使用mobx-react的不同点只是在编写组件类时observer包装了一下，其他的跟不使用mobx-react没什么区别。另外，如果在stroe里加入方法，就可以做到类似action一样的动作，使用上比redux要简单很多。当然这也引出一个问题，就是当子组件状态变化影响到父组件的状态，如何通知父组件。redux用类似dbus的设计解决了这个问题，mobx怎么解决，我还没有看到，后续看到了再做补充。</p>
<h2 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h2><p>怎么说呢，总感觉mobx的功能和vue好像……￣ω￣=……特别是computed……这种设计对于写惯了mvc的人来说会感觉非常亲切，stroe其实就是相当于平时常写的model嘛，概念很容易理解。难度上，个人感觉不高，除了一些绑定后的数据需要调用set、get方法，api也不多。</p>
<p>其实mobx还有很多的功能没有介绍到，而且在网上资料也很少，如果有时间的话，打算试着翻译mobx的文档。更多的例子，后续再做详细的补充，今天就先到这里吧，我实在是写不动了……_(:3 」∠)_</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="http://mobxjs.github.io/mobx/index.html" target="_blank" rel="external">MobX Documentation</a></li>
<li><a href="http://frontendinsights.com/short-introduction-to-mobx/" target="_blank" rel="external">A short introduction to MobX</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话说，吐槽被react全家桶坑的文章已经算是各大论坛上的月经贴了吧……行内样式、jsx里html和js混排、依赖太多、学习曲线陡峭……当然其中不乏抱怨redux反人类的……&lt;/p&gt;
&lt;p&gt;当然，这篇文章并不是来黑react不好的，毕竟以后涨工资还得靠它呢哈哈哈(￣▽￣)……&lt;/p&gt;
&lt;p&gt;今天咱们要说的是众多槽点之一，”反人类的redux”和其替代方案。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://brooch.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="mobx" scheme="http://brooch.me/tags/mobx/"/>
    
      <category term="react" scheme="http://brooch.me/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>浮点数计算为什么不精确</title>
    <link href="http://brooch.me/2016/11/17/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%B2%BE%E7%A1%AE/"/>
    <id>http://brooch.me/2016/11/17/浮点数计算为什么不精确/</id>
    <published>2016-11-17T02:22:47.000Z</published>
    <updated>2016-11-17T14:49:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>其实这篇博客早就写好了，只不过之前懒一直没有整理完善……哈哈哈…… _(:3 」∠)_</p>
</blockquote>
<p>前几几几几天，在微博上看到<a href="http://weibo.com/u/1778942741" target="_blank" rel="external">寇胖</a>转了一个关于浮点数计算的<a href="http://weibo.com/1996814695/DC0c6iAVD" target="_blank" rel="external">微博</a>，里面的内容不太准确。正好之前我调查过一些关于浮点数的资料，在这里好好掰吃掰吃，做个记录~(￣▽￣)~*</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>先说结论，嫌又臭又长的看到这里就可以了:</p>
<ul>
<li>浮点数计算不精确并不是bug，因为标准就是这样的。</li>
<li>原因简单来说是这样：2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。</li>
<li>解决方法：对于需要精确结果的场景，别直接使用浮点数进行计算。现阶段可以使用<a href="http://mikemcl.github.io/big.js/" target="_blank" rel="external">big.js</a>解决，等以后ecmascript实现decimal了，就可以使用decimal类型计算了。</li>
</ul>
<a id="more"></a>
<h2 id="小数算不准，真的是js的锅吗？"><a href="#小数算不准，真的是js的锅吗？" class="headerlink" title="小数算不准，真的是js的锅吗？"></a>小数算不准，真的是js的锅吗？</h2><p>说到这个问题，其实这是两个锅，js计算不准确不止会出现在小数的计算上，还会出现在大整数计算上，可以运行下面两行代码查看问题的具体表现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>; <span class="comment">// false</span></div><div class="line"><span class="number">9999999999999999</span> + <span class="number">2</span> == <span class="number">10000000000000001</span>; <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>当然，这个锅肯定不是javascript背。事实上，使用了IEEE 754 标准来存储浮点类型的任何编程语言（C/C++/C#/Java 等等）都存在精度丢失问题。</p>
<p>例如在 Java 中，要想算准浮点数，同样不能直接计算，需要使用 BigDecimal 类来进行相应的处理。</p>
<p>当然，javascript也并没有落后于其他语言。ECMAScript 规范中已有 <a href="http://wiki.ecmascript.org/doku.php?id=proposals:decimal" target="_blank" rel="external">decimal </a>类型的提案了，但目前尚未被正式采纳。</p>
<h2 id="为什么不算准？"><a href="#为什么不算准？" class="headerlink" title="为什么不算准？"></a>为什么不算准？</h2><p>要解释这个问题，就得从10进制与2进制的转换说起。</p>
<p>众所周知，计算机做运算是使用二级制的。所以其实咱们在程序中做10进制运算，都是要转换为2进制再进行计算的。10进制整数转换为2进制的方法可能大家都知道：</p>
<blockquote>
<p><strong>除以2，商继续除以2，得到0为止，将余数逆序排列</strong><br>例如：<br>22 / 2     11 余 0<br>11 / 2     5  余 1<br>5  / 2     2  余 1<br>2  / 2     1  余 0<br>1  / 2     0  余 1<br>所以22的的二进制是10110</p>
</blockquote>
<p>那10进制小数转换为2进制的方法呢？</p>
<blockquote>
<p><strong>乘以2，取整，小数部分继续乘以2，取整，得到小数部分0为止，将整数顺序排列</strong><br>0.8125 x 2     1.625 取 1<br>0.625  x 2     1.25  取 1<br>0.25   x 2     0.5   取 0<br>0.5    x 2     1.0   取 1<br>所以0.8125的二进制是0.1101</p>
</blockquote>
<p>那么问题就来了，比如你想计算10进制0.2的2进制：</p>
<blockquote>
<p>0.2 x 2     0.4<br>0.4 x 2     0.8<br>0.8 x 2     1.6<br>0.6 x 2     1.2<br>0.2 x 2     0.4<br>……</p>
</blockquote>
<p>发现了吗？它乘不尽，是无限循环的……</p>
<p>而 javascript 使用64位双精度浮点数存储数字，类似科学计数法，其中1位用来存储符号，11位用来存储指数值，52位用来存储尾数值（真正的数字），当计算的结果的二进制有效位数超过 52 位时，就会出现精度丢失的问题……</p>
<p>大整数计算的原因也是一样，有效位数超过 52位时，精度就会丢失</p>
<p>这就解释了下面这种情况：</p>
<blockquote>
<p>十进制 0.1 的二进制为 0.0 0011 0011 0011 … （循环 0011）<br>十进制 0.2 的二进制为 0.0011 0011 0011 … （循环 0011）</p>
<p>0.1 + 0.2 相加可表示为：<br>   e = -4; m = 1.10011001100…1100（52 位）<br> + e = -3; m = 1.10011001100…1100（52 位）<br>-——————————————–<br>   e = -3; m = 0.11001100110…0110<br> + e = -3; m = 1.10011001100…1100<br>-——————————————–<br>   e = -3; m = 10.01100110011…001<br>-——————————————–<br> = 0.01001100110011…001<br> = 0.30000000000000004（十进制）</p>
</blockquote>
<p>但是0.05和0.2用二进制都无法精确表达，0.05 + 0.2 却不会计算错误，0.2 + 0.7 会计算错误，1.2 +1.7 又不会，这又是为什么？</p>
<p>具体的原因我并没有找到相关的资料……</p>
<p>貌似这和 IEEE 754 的舍入模式有关系。</p>
<p>IEEE 754 采用的是最近舍入模式，和我们最熟悉的是四舍五入模式有些许不同，也是比较容易引起误解的地方之一。举例比较如下：</p>
<blockquote>
<p>最近舍入模式：Round(0.5) = 0; Round(1.5) = 2; Round(2.5) = 2;</p>
<p>四舍五入模式：Round(0.5) = 1; Round(1.5) = 2; Round(2.5) = 3;</p>
</blockquote>
<p>既当有两个最接近的可表示的值时首选“偶数”值。</p>
<p>具体的原因我会再调查调查，有了新的资料再补充到这里。</p>
<h2 id="如何解决这个问题？"><a href="#如何解决这个问题？" class="headerlink" title="如何解决这个问题？"></a>如何解决这个问题？</h2><p>当然，问题的解决方法其实也已经有前人跟咱们铺好路了，毕竟这个在问题在编程领域里其实是个挺常见的问题……</p>
<p>网上的解决办法五花八门，总的原则就是逐位运算。我推荐 github 上  <a href="https://github.com/MikeMcl" target="_blank" rel="external">MikeMcl</a> 开发的 <a href="http://mikemcl.github.io/big.js/" target="_blank" rel="external">big.js</a> 。这个库不尽支持基础运算，而且还支持各种函数运算和比较运算，相当全面呢。实现上，是将数字按照科学计数法解析成一个包含正负符号、指数、尾数的对象，再做运算。例子就不写了，它的文档很全，而且简单易懂。</p>
<p>有趣的是，这个作者除了 big.js 还开发了另两个计算库 bignumber.js 和 decimal.js，三个库的侧重点不一样，关于这三个的对比，有兴趣的话可以看作者自己写的wiki <a href="https://github.com/MikeMcl/big.js/wiki" target="_blank" rel="external">What is the difference between big.js, bignumber.js and decimal.js?</a></p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章:"></a>相关文章:</h2><ol>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513140&amp;idx=1&amp;sn=565517e977ac56904305a4a9f9d65012#rd" target="_blank" rel="external">浮点数为什么不精确？</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/maplejan/p/3893545.html" target="_blank" rel="external">JavaScript超大整数加法</a></p>
</li>
<li><p><a href="http://demon.tw/copy-paste/javascript-precision.html" target="_blank" rel="external">JavaScript 中小数和大整数的精度丢失</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/bossin/archive/2007/04/08/704567.html" target="_blank" rel="external">IEEE 754 浮点数的表示精度探讨</a></p>
</li>
<li><p><a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="external">IEEE 754</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实这篇博客早就写好了，只不过之前懒一直没有整理完善……哈哈哈…… _(:3 」∠)_&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前几几几几天，在微博上看到&lt;a href=&quot;http://weibo.com/u/1778942741&quot;&gt;寇胖&lt;/a&gt;转了一个关于浮点数计算的&lt;a href=&quot;http://weibo.com/1996814695/DC0c6iAVD&quot;&gt;微博&lt;/a&gt;，里面的内容不太准确。正好之前我调查过一些关于浮点数的资料，在这里好好掰吃掰吃，做个记录~(￣▽￣)~*&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h2&gt;&lt;p&gt;先说结论，嫌又臭又长的看到这里就可以了:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浮点数计算不精确并不是bug，因为标准就是这样的。&lt;/li&gt;
&lt;li&gt;原因简单来说是这样：2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。&lt;/li&gt;
&lt;li&gt;解决方法：对于需要精确结果的场景，别直接使用浮点数进行计算。现阶段可以使用&lt;a href=&quot;http://mikemcl.github.io/big.js/&quot;&gt;big.js&lt;/a&gt;解决，等以后ecmascript实现decimal了，就可以使用decimal类型计算了。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机原理" scheme="http://brooch.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="javascript" scheme="http://brooch.me/tags/javascript/"/>
    
      <category term="floating point" scheme="http://brooch.me/tags/floating-point/"/>
    
      <category term="big decimal" scheme="http://brooch.me/tags/big-decimal/"/>
    
      <category term="IEEE 754" scheme="http://brooch.me/tags/IEEE-754/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="http://brooch.me/2016/11/16/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>http://brooch.me/2016/11/16/新的开始/</id>
    <published>2016-11-16T14:23:33.000Z</published>
    <updated>2016-11-16T16:36:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>哈，距离上次写博客刚好一年了呢，话说我还真是懒呢…… _(:3 」∠)_</p>
<p>这里不得不感叹下榜样的力量是无穷的。要不是<a href="http://testudy.cc/" target="_blank" rel="external">继伟</a>发起每周写博客的活动，估计我现在还在床上躺着呢……读好书，交高人，此言非虚呀~</p>
<p>总之，希望这是个新的开始，期待能遇见更好的自己~(｡･ω･｡)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈，距离上次写博客刚好一年了呢，话说我还真是懒呢…… _(:3 」∠)_&lt;/p&gt;
&lt;p&gt;这里不得不感叹下榜样的力量是无穷的。要不是&lt;a href=&quot;http://testudy.cc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;继伟&lt;/a&gt;发起每周写博
    
    </summary>
    
      <category term="感想" scheme="http://brooch.me/categories/%E6%84%9F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>Capitan之后JetBrains的产品都不能用了</title>
    <link href="http://brooch.me/2015/11/21/Capitan%E4%B9%8B%E5%90%8EJetBrains%E7%9A%84%E4%BA%A7%E5%93%81%E9%83%BD%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86/"/>
    <id>http://brooch.me/2015/11/21/Capitan之后JetBrains的产品都不能用了/</id>
    <published>2015-11-21T04:06:24.000Z</published>
    <updated>2016-11-16T16:35:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>更新了osx升级10.11 EL Capitan之后发现有好多坑啊……限制超多而且JetBrains的产品都不能用了……</p>
<p>查了一溜够貌似是之前安装的一些系统软件都被清除了，而且还需要接触rootless模式，总之先附上搜索到的资料链接吧</p>
<p><a href="http://blog.euphonictech.com/entry/2014/11/12/192856" target="_blank" rel="external">Intellij IDEAやAppCodeが起動しない場合に考えられること</a>（需翻墙）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;更新了osx升级10.11 EL Capitan之后发现有好多坑啊……限制超多而且JetBrains的产品都不能用了……&lt;/p&gt;
&lt;p&gt;查了一溜够貌似是之前安装的一些系统软件都被清除了，而且还需要接触rootless模式，总之先附上搜索到的资料链接吧&lt;/p&gt;
&lt;p&gt;&lt;a h
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="osx" scheme="http://brooch.me/tags/osx/"/>
    
  </entry>
  
  <entry>
    <title>邮件链接中加入参数可以给要发送的邮件添加标题和内容，第一次发现唉</title>
    <link href="http://brooch.me/2015/10/21/%E9%82%AE%E4%BB%B6%E9%93%BE%E6%8E%A5%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E7%BB%99%E8%A6%81%E5%8F%91%E9%80%81%E7%9A%84%E9%82%AE%E4%BB%B6%E6%B7%BB%E5%8A%A0%E6%A0%87%E9%A2%98%E5%92%8C%E5%86%85%E5%AE%B9%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%91%E7%8E%B0%E5%94%89/"/>
    <id>http://brooch.me/2015/10/21/邮件链接中加入参数可以给要发送的邮件添加标题和内容，第一次发现唉/</id>
    <published>2015-10-21T03:51:34.000Z</published>
    <updated>2016-11-16T16:36:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>a标签的href属性值可以是mailto协议的地址，这个比较常见，但是能加参数设置邮件内容我还是第一次见呢。</p>
<p>示例：</p>
<p>mailto:xxx@xxx.com?Subject=标题&amp;Body=正文</p>
<p>貌似按照get方式加上参数就行了，Subject代表标题，Body代表正文</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;a标签的href属性值可以是mailto协议的地址，这个比较常见，但是能加参数设置邮件内容我还是第一次见呢。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;mailto:xxx@xxx.com?Subject=标题&amp;amp;Body=正文&lt;/p&gt;
&lt;p&gt;貌似按照get方式加上参数就行
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="html" scheme="http://brooch.me/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>总结下hexo搭建的过程</title>
    <link href="http://brooch.me/2015/10/16/%E6%80%BB%E7%BB%93%E4%B8%8Bhexo%E6%90%AD%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://brooch.me/2015/10/16/总结下hexo搭建的过程/</id>
    <published>2015-10-16T14:23:22.000Z</published>
    <updated>2016-11-16T16:35:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2016-11-16 UPDATE:</strong> 距离写下这篇博客已经过了一年了，hexo在这一年里发展的挺快。现在hexo的文档已经齐全，整个工作流程也相当顺畅了。</p>
<p>安装过程中如果 node-gyp 报 error，可以尝试升级xcode，并安装xcode-select 升级 CLT。</p>
<p>下面附上几篇比较好的文章，建站过程中遇到问题可以查阅一下。</p>
<p><a href="http://wp.huangshiyang.com/hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" target="_blank" rel="external">Hexo常见问题解决方案</a><br>收集了很多使用hexo过程中的常见问题</p>
<a id="more"></a>
<p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客</a><br>文章的内容很全，不止写了如何使用hexo，如何使用github，如何找图床等问题也都有描述，如果是使用github pages搭建博客的话，看这篇就够用了</p>
<p><a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br>和上一篇文章一样，这篇文章的内容也很全面，除了博客的搭建过程，如何在购买域名和服务器也有描述，只不过图片貌似都已经失效了……有些遗憾呢……</p>
<p><a href="http://segmentfault.com/a/1190000003776905" target="_blank" rel="external">翻译自GitHub Pages的Help页面（仍在更新中）</a><br>github pages的help页面的翻译，对于英语苦手的人来说，应该会很有帮助吧</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;2016-11-16 UPDATE:&lt;/strong&gt; 距离写下这篇博客已经过了一年了，hexo在这一年里发展的挺快。现在hexo的文档已经齐全，整个工作流程也相当顺畅了。&lt;/p&gt;
&lt;p&gt;安装过程中如果 node-gyp 报 error，可以尝试升级xcode，并安装xcode-select 升级 CLT。&lt;/p&gt;
&lt;p&gt;下面附上几篇比较好的文章，建站过程中遇到问题可以查阅一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wp.huangshiyang.com/hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot;&gt;Hexo常见问题解决方案&lt;/a&gt;&lt;br&gt;收集了很多使用hexo过程中的常见问题&lt;/p&gt;
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://brooch.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>总结一下升级OS X El Capitan后brew遇到的问题</title>
    <link href="http://brooch.me/2015/10/15/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%8D%87%E7%BA%A7OS-X-El-Capitan%E5%90%8Ebrew%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://brooch.me/2015/10/15/总结一下升级OS-X-El-Capitan后brew遇到的问题/</id>
    <published>2015-10-15T14:45:31.000Z</published>
    <updated>2016-11-17T10:00:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>升级了osx之后，先是brew update的时候报错，后来用brew安装jenv的时候又提示说需要root权限</p>
<blockquote>
<p>Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo.<br>Error: Failure while executing: /usr/bin/otool -L /usr/bin/install_name_tool</p>
</blockquote>
<p>但是sudo brew install又报错</p>
<blockquote>
<p>Error: Cowardly refusing to <code>sudo brew install</code><br>You can use brew with sudo, but only if the brew executable is owned by root.<br>However, this is both not recommended and completely unsupported so do so at your own risk.</p>
</blockquote>
<p>搜了下貌似是新版osx的问题，需要进行权限设置，用chown命令设置一下就好了</p>
<p>以下是一些参考资料</p>
<p><a href="http://digitizor.com/2014/06/29/fix-cowardly-refusing-sudo-error-brew/" target="_blank" rel="external">How To Fix Cowardly Refusing to Sudo error in Brew – Mac OS X</a></p>
<p><a href="https://github.com/Homebrew/homebrew/issues/41665" target="_blank" rel="external">Failed <code>brew update</code> on El Capitan (OS X 10.11) Beta</a></p>
<p><a href="http://gotohayato.com/content/69" target="_blank" rel="external">Mac OS X El Capitan にアップデートした後に brew update が動かない場合の対処方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级了osx之后，先是brew update的时候报错，后来用brew安装jenv的时候又提示说需要root权限&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Agreeing to the Xcode/iOS license requires admin privileges,
    
    </summary>
    
      <category term="随手一记" scheme="http://brooch.me/categories/%E9%9A%8F%E6%89%8B%E4%B8%80%E8%AE%B0/"/>
    
    
      <category term="osx" scheme="http://brooch.me/tags/osx/"/>
    
      <category term="brew" scheme="http://brooch.me/tags/brew/"/>
    
  </entry>
  
  <entry>
    <title>啊，我的第一次</title>
    <link href="http://brooch.me/2015/10/14/first-love/"/>
    <id>http://brooch.me/2015/10/14/first-love/</id>
    <published>2015-10-14T07:15:06.000Z</published>
    <updated>2016-11-16T16:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>人生第一篇blog，总觉得有点儿小激动呢……⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄</p>
<p>话说再过生日就30岁了呢，做程序员也是第8个年头，愈发觉得将自己的平时的一些想法、遇到的一些问题记录下来很重要，其实以前也很想，奈何我懒……</p>
<p>总之，之后会努力多写一些，也算是对自己的一种提升吧，嗯，希望我能一直坚持下去~</p>
<p>&lt;(￣▽￣)&gt; 哈哈哈……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生第一篇blog，总觉得有点儿小激动呢……⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄&lt;/p&gt;
&lt;p&gt;话说再过生日就30岁了呢，做程序员也是第8个年头，愈发觉得将自己的平时的一些想法、遇到的一些问题记录下来很重要，其实以前也很想，奈何我懒……&lt;/p&gt;
&lt;p&gt;总之，之后会努力多写一些，也
    
    </summary>
    
      <category term="感想" scheme="http://brooch.me/categories/%E6%84%9F%E6%83%B3/"/>
    
    
  </entry>
  
</feed>
