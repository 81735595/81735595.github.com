<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[MobX入坑指南(3) -- Observable Objects & Arrays]]></title>
      <url>%2F2016%2F12%2F09%2FMobX-simple-entry-3%2F</url>
      <content type="text"><![CDATA[这周阅读了一部分mobx的源码，和作者写的几篇介绍文章，发现这个库有些特性还挺有趣的。以下的内容大部分翻译自mobx文档中 Observable Types 一节，奈何小生英文水平有限，没有划词软件帮忙就看不懂句子……所以翻的很渣，基本上都是掺杂了一些我的理解在里边，连蒙带猜拼出来的，有啥写的不对的，也请多指教了~(￣▽￣)~* 在mobx中，如果你想监听某个变量的变化，需要先使用 observable 函数将其转化为生成Observable对象才行。这个章节主要讲的是 observable 函数生成的不同Observable对象 Observable Objects当 observable 函数接受的参数是个普通的javascript object（普通javascript对象是指不是通过构造函数生成的对象，mobx的判断方式是，通过getPrototypeOf获取原型，检查是不是Object.prototype或者null）时，这个对象中的所有属性都将被传入 observable 函数进行转换，如果属性值是object或者array，则会递归的转化内部的元素。 123456789101112131415161718192021222324252627282930313233import &#123;observable, autorun, action&#125; from "mobx";var person = observable(&#123; // 常量会自动使用observable转化: name: "John", age: 42, showAge: false, // 有get描述符的属性会自动使用computed转化: get labelText() &#123; return this.showAge ? `$&#123;this.name&#125; (age: $&#123;this.age&#125;)` : this.name; &#125;, // 如果直接写 // labelText: function () &#123; // return this.showAge ? `$&#123;this.name&#125; (age: $&#123;this.age&#125;)` : this.name; // &#125; // 在自动转化时会报一个warning，mobx认为渲染函数需要用computed显式调动一下 // labelText: computed(function () &#123; // return this.showAge ? `$&#123;this.name&#125; (age: $&#123;this.age&#125;)` : this.name; // &#125;) // 同理，action也需要显式调动一下: setAge: action(function(age) &#123; this.age = age; &#125;)&#125;);autorun(() =&gt; console.log(person.labelText));person.name = "Dave";// 'Dave'person.setAge(21);console.log(person.age);// 21 需要注意的点： 当对象传入 observable 函数时，只有当时对象上已经存在的属性才能被监听，后添加的属性是不能的，如果想要往已经生成的Observable对象上添加属性，需要使用extendObservable函数进行类似merge的操作。 123456//接上面的例子extendObservable(person, &#123; sex: 'male'&#125;);console.log(person.sex);// 'male' 只有普通对象能够被转化为Observable对象。使用构造函数创建的对象，需要在构造函数初始化时使用extendObservable函数合并属性。使用类创建的对象，需要使用 @observable装饰器包装类的属性。 123456789101112131415161718192021var Person = function(firstName, lastName) &#123; // 在一个新的对象里写要监听的属性，然后merge和当前实例merge extendObservable(this, &#123; firstName: firstName, lastName: lastName &#125;);&#125;var zxc = new Person("Zheng", "Xingcheng");// 或者class Person &#123; @observable firstName:string = ""; @observable lastName:string = ""; constructor(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125;var zxc = new Person("Zheng", "Xingcheng"); 带有get描述符的属性会自动被@computed转化，第一个例子中已经展示了。 如果对象的属性值是一个构造函数生成的对象（我真是不想把它叫成”非普通对象”……），那这个属性也不会被 observable 函数自动转化。 基本上使用observable 函数自动转化已经能解决绝大部分的使用场景了（原文写的是”95% of the cases”……）。如果想要了解更详细的设定每个属性的方法，请看 modifiers 一章（本来这一章的内容也想发到这里的，但是实在是没时间写了只能拉倒……等下次吧）。 Observable Arrays和 object 类似，array 也可以使用 observable函数转化为ObservableArray对象。当然，也是递归转化每个元素的，所以数组的所有元素也会被转化。 123456789101112131415161718192021222324import &#123;observable, autorun&#125; from "mobx";var todos = observable([ &#123; title: "吃午饭", completed: true &#125;, &#123; title: "喝咖啡", completed: false &#125;]);autorun(() =&gt; &#123; console.log("代办:", todos .filter(todo =&gt; !todo.completed) .map(todo =&gt; todo.title) .join(", ") );&#125;);// '代办: 喝咖啡'todos[0].completed = false;// '代办: 吃午饭, 喝咖啡'todos[2] = &#123; title: "睡午觉", completed: false &#125;;// '代办: 吃午饭, 喝咖啡, 睡午觉'todos.shift();// '代办: 喝咖啡, 睡午觉' 由于ES5中原生数组的限制（array.observe到ES7中才有，而且数组不能扩展），observable函数基于原始数组克隆了一个新的数组，这个新数组支持所有原生数组的方法和功能，同时还有监听值变化的能力。 不过，当使用Array.isArray检查包装后数组时返回的是false。所以在跟其他库联合使用时，如果想把ObservableArray对象当做数组传递给其他库，最好使用浅拷贝生成新数组，或者使用 array.slice 方法生成新数组，就是说 Array.isArray(observable([]).slice()) 返回的是true。 由于不喜欢原生的 array.sort 和 array.reverse 方法，ObservableArray对象的 sort 和 reverse 方法是并不会改变自身的，而是返回一个新的ObservableArray对象。 除了原生数组支持的方法，ObservableArray对象还可以使用以下的方法： intercept(interceptor)这个方法可以在所有数组的操作被应用之前，将操作拦截。具体的请看observe &amp; intercept observe(listener, fireImmediately? = false)这个方法可以监听数组的变化，回调函数会接收数组新增或者修改的元素，符合ES7的规范。这个方法返回一个注销函数用来停止监听。 clear()清空数组。 replace(newItems)替换数组里的所有元素。 find(predicate: (item, index, array) =&gt; boolean, thisArg?, fromIndex?)使用方法与ES7的 array.find 一致，但是增加了formIndex参数。 remove(value)移除数组中第一个值等于value的元素，如果移除成功会返回true。 peek()与 slice 类似，会返回一个包含所有元素的数组。它与 slice 的区别在于 peek 不会进行保护性拷贝，所以性能更好。 Observable Mapsobservable(asMap(values?, modifier?)) 和 map(values?, modifier?)) 方法可以创建一个ObservableMap对象。如果你不想响应特定属性的变化，还要添加删除属性，那么使用ObservableMap对象很合适。不同于ES6的Map对象，ObservableMap对象是能用字符串当做key。 根据ES6 Map的规范，可以使用以下方法: has(key)返回map中是否存在这个key，这个方法是可被监听的 set(key, value)设置key对应的value，如果key之前不错在，那么这个key会被添加上 delete(key)删除key和key对应的value get(key)获取key对应的value，如果没找到会返回undefined keys()获取map的所有key，顺序为key的插入顺序 values()获取map的所有key对应的value，顺序为key的插入顺序 entries()返回一个数组，数组中每个元素为一个数组，数组中的元素为map中的key/value对，形式如[key, value]，顺序为key的插入顺序 forEach(callback:(value, key, map) =&gt; void, thisArg?)对map中的每个key/value对调用回调 clear()清除map中的所有key/value对 size()返回map中所有key/value对的数量 ObservableMap对象还提供了以下方法可以使用: toJS()返回一个map的浅拷贝的对象，如果想获得深拷贝的对象，需要使用 mobx.toJS(map) intercept(interceptor)注册一个拦截器，拦截器会在map被修改之前被触发。具体的请看observe &amp; intercept observe(listener, fireImmediately?)注册一个监听，map被修改时会被触发。与Object.observe类似。具体的请看observe &amp; intercept merge(object | map)将对象上所有的属性拷贝到当前map中 Primitive (常量）在javascript中，常量是不可变的，所以也没办法观测。所以如果想要监听一个常量属性的变化，需要使用 observable 函数包装一下。 observable 函数包装后会返回一个ObservablePrimitive对象。这个对象使用get和set方法来获取和改变变量的值。可以使用 .observe 方法来监听值的变化。不过通常使用 mobx.autorun 是更好的选择。 以下是ObservablePrimitive支持的方法： get()返回当前值 set(value)替换当前存储的值，并通知所有的监听器 intercept(interceptor)注册拦截器，当值发生变化前触发。具体的请看observe &amp; intercept observe(callback: (newValue, previousValue) =&gt; void, fireImmediately = false)注册监听器，当值发生变化时触发，返回一个注销函数。具体的请看observe &amp; intercept 12345678910111213import &#123;observable&#125; from "mobx";const cityName = observable("Vienna");console.log(cityName.get());// 'Vienna'cityName.observe(function(newCity, oldCity) &#123; console.log(oldCity, "-&gt;", newCity);&#125;);cityName.set("Amsterdam");// 'Vienna -&gt; Amsterdam' References (引用类型）之前在ObservableObject中提到，observable在转换时会自动用computed包装函数，这个自动转换其实是由限制条件的。mobx只会转换渲染用的函数，既函数不能接受参数，如果接受参数，则认为这个是一个复合函数，就不会自动转化。同样的，如果对象中有属性是通过构造函数或者类创建的对象，也不会自动转化。他们都继续保持着转化之前的引用。 有时我们也会有这一类的需求，要求对象中某个属性不被自动转化。可以使用 asReference 来达到这一目的。 12345678910111213141516var test = observable(&#123; x : 3, doubler: function() &#123; return this.x*2; &#125;, someFunc: asReference(function() &#123; return this.x; &#125;)&#125;);console.log(test.doubler);// 6console.log(test.someFunc);// function() &#123;// return this.x;// &#125; 总结总体感觉上，mobx的api和knockout的api很像，但是在实现原理上，更像rx。mobx实现监听变化调用回调的过程是同步的，通过这种方式就能会自动的分析各个变量间的调用关系，从而减少重复订阅的情况。同时计算最新的值时还是用了memoizing技术，这样就算调用频繁，性能上也能得到保证。 相关文章 Observable Objects Observable Arrays Observable Maps Primitive values and references]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MobX入坑指南(2) -- action]]></title>
      <url>%2F2016%2F11%2F29%2FMobX-simple-entry-2%2F</url>
      <content type="text"><![CDATA[上一篇简单介绍了下mobx常用的几个api(observable、computed、autorun)，以及mobx-react的api(observer)。这次说说action。 action用法： action(fn) action(name, fn) @action classMethod @action(name) classMethod @action boundClassMethod = (args) =&gt; { body } @action(name) boundClassMethod = (args) =&gt; { body } 之前的例子里使用了回调的方式来触发响应，mobx其实也支持使用flux的方式来出发响应，并且在2.2版本提供了action的功能。 action是一个工厂函数，可以接受name和fn两个参数，name是String，主要描述action的作用，fn是Function，是这个action的具体逻辑。action执行后返回一个函数，调用这个函数就会执行action，其实就是调用fn参数。 个人感觉在mobx中，action的作用更多的是用来注释当前的操作……使用的时候在name参数上写操作是干啥的，能够快速的了解action的意图。当然如果安装了devtools，action还能输出调试信息。 需要注意的是，如果使用useStrictapi开启了严格模式，就必须通过action才能修改状态(state)，直接修改值会报错。 举个🌰 123456789101112131415161718192021222324import &#123;observable, useStrict, action, computed, autorun&#125; from 'mobx';useStrict(true);let numbers = observable([1,2,3]);let sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, 0));let disposer1 = autorun(() =&gt; console.log(`sum:$&#123;sum.get()&#125;`));// sum:6let disposer2 = autorun(() =&gt; console.log(`length:$&#123;numbers.length&#125;`));// length:3var pushNumber = action('push number',()=&gt;&#123; numbers.push(4)&#125;)pushNumber(4)// sum:10// length:4numbers.push(5)// Uncaught Error: [mobx] Invariant failed: It is not allowed to create// or change state outside an `action` when MobX is in strict mode. Wrap// the current method in `action` if this state change is intended. 另外，action在执行时是可以接受参数的，而且action在执行后还会返回fn参数的返回值，这一点文档里没有明显的说明，害的我翻源码才翻出来的……┑(￣Д ￣)┍……话说mobx是用typescript写的呢。虽然ts最近很火，而且功能也确实挺实用的，但是我对java一样死板的语法却怎么都都爱不起来……所以更看好WebAssembly一些…… 扯远了扯远了……那么我们再把上面那个例子修改一下： 123456789101112131415161718import &#123;observable, useStrict, action, computed, autorun&#125; from 'mobx';useStrict(true);let numbers = observable([1,2,3]);let sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, 0));// sum:6let disposer = autorun(() =&gt; console.log(`sum:$&#123;sum.get()&#125;`));var pushNumber = action('push number',(number)=&gt;numbers.push(number))console.log(`length:$&#123;pushNumber(6)&#125;`)// sum:12// length:4console.log(`length:$&#123;pushNumber(7)&#125;`)// sum:19// length:5 从上面的例子可以看到，传入pushNumber的参数最后被传入了action的fn中，然后pushNumber返回了push的返回值。 官方文档中的一个例子也能看到调用action返回函数时传递参数的应用场景： 1234567891011121314151617@action createRandomContact() &#123; this.pendingRequestCount++; superagent .get('https://randomuser.me/api/') .set('Accept', 'application/json') .end(action("createRandomContact-callback", (error, results) =&gt; &#123; if (error) console.error(error); else &#123; const data = JSON.parse(results.text).results[0]; const contact = new Contact(this, data.dob, data.name, data.login.username, data.picture) contact.addTag('random-user'); this.contacts.push(contact); this.pendingRequestCount--; &#125; &#125;));&#125; 在这个🌰中可以看到，action的返回值作为superagent.end的回调，接收error和results两个参数，最后传入fn进行处理。这个例子也引出了另一个问题，action中如何处理一步操作。 async action 和 runInActionaction只能影响正在运行的函数，而无法影响当前函数调用的异步操作。也就是说如果fn中有setTimeout，promise.then，async函数，并且这些函数的回调里对state进行了修改，那么这些回调也应该用action包装一下（在非严格模式下，action和直接修改state值都能生效，所以并不会出现异常，如果是严格模式下就会报错）。 还有，如果要使用async函数作为action，不能直接用action包装async函数，这里需要使用一个tricky，将一个async匿名函数赋值给一个变量或者属性再做包装。 12345678@action updateDocument = async () =&gt; &#123; const data = await fetchDataFromUrl(); /* required in strict mode to be allowed to update state: */ runInAction("update state after fetching data", () =&gt; &#123; this.data.replace(data); this.isSaving = true; &#125;)&#125; 上面的例子还用到了runInAction，它其实就是action(name,fn)()的语法糖，调用后action会立即执行，它的用法是：runInAction(name?, fn, scope?)，scope是fn调用时的this指向。注：2.3.0版本以后才能使用。 相关文章 MobX Documentation – action]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React全家桶又填新成员 MobX入坑指南(1)]]></title>
      <url>%2F2016%2F11%2F23%2FMobX-simple-entry-1%2F</url>
      <content type="text"><![CDATA[话说，吐槽被react全家桶坑的文章已经算是各大论坛上的月经贴了吧……行内样式、jsx里html和js混排、依赖太多、学习曲线陡峭……当然其中不乏抱怨redux反人类的…… 当然，这篇文章并不是来黑react不好的，毕竟以后涨工资还得靠它呢哈哈哈(￣▽￣)…… 今天咱们要说的是众多槽点之一，”反人类的redux”和其替代方案。 redux有什么不好？首先，redux绝对是个优秀的库。它体小精悍，api简单优雅，扩展能力强，足以衍生出丰富的工具集和生态系统。在它出现之前，各种flux实现貌似都不能让人如意，以至于有人宁可用 backbone 甚至是 angular 和 react搭配，也不用flux……后来redux出现，解决了flux操作繁琐的问题，开始受到人们的关注，再后来作者也加入了 facebook从事react的开发，redux也顺理成章的成为了react官方推荐状态管理库。 但是，在真正去开发的时候，我发现状态的维护还是有些繁琐，如果你在设计阶段没有考虑周全，开发时就要不停的在action,container,reducer之前修改，穿梭，让人眼花缭乱……嗯，也没准儿是我项目不够大…… 另外，由于redux大量使用函数式编程的思想，门槛有点高呢。当时为了理解redux里面的概念，我大概读了一周的文档…… 按你胃（Anywhere），如果你更熟悉面向对象，羡慕mvvm框架的简单，那你真的应该体验一下mobx mobx是啥？mobx是个新的状态管理库，响应式的，我是看了阮一峰的微博知道的，后来查了资料发现，redux的作者在twitter推荐了这个库，还是作为redex的替代品…… 那么废话少说，让我们现在看看mobx怎么用吧 api简单介绍和redux一样，mobx是一个独立的库，不依赖于react也能自己用，它只有三个概念：观测状态，计算值和反应。这三个概念分别对应三个mobx的api：observable，computed和autorun。 咱们先来个最简单的例子 1234567891011121314151617import &#123; observable, computed, autorun &#125; from 'mobx';let numbers = observable([1,2,3]);let sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, 0));let disposer1 = autorun(() =&gt; console.log(`sum:$&#123;sum.get()&#125;`));let disposer2 = autorun(() =&gt; console.log(`length:$&#123;numbers.length&#125;`));// sum:6// length:3numbers.push(4);// sum:10// length:4disposer2();numbers.push(5);// sum:15 这个例子中，observable用来绑定数据；computed用来绑定计算方法；autorun用来注册数据变化时响应的方法，返回的函数用来取消响应。 下面我们试着来写一个TodoList 12345678910111213141516171819202122232425262728import &#123; observable, computed, autorun &#125; from 'mobx';class Todo &#123; id = Math.random(); @observable content; @observable finished = false; constructor(content) &#123; this.content = content; &#125;&#125;class TodoList &#123; @observable todos = []; @computed get todoListString() &#123; return this.todos.filter(todo =&gt; !todo.finished).map((todo, i) =&gt; `$&#123;i+1&#125;. $&#123;todo.content&#125;`).join('\n'); &#125;&#125;const store = new TodoList();store.todos.push( new Todo("task1"), new Todo("task2"), new Todo("task3"));autorun(() =&gt; console.log(store.todoListString))store.todos[2].finished = true; 从上面的例子可以看到，针对类的属性，可以使用修饰器@observable、@computed来进行绑定，修饰器是ES7的一个提案，目前Babel已经支持。详细的介绍可以看ECMAScript 6 入门中修饰器一章 如果不想用修饰器，也可以使用extendObservable函数，跟修饰器的功能是一样的： 123456789101112131415161718192021222324252627282930313233import &#123; extendObservable, autorun &#125; from 'mobx';class Todo &#123; id = Math.random(); constructor(content) &#123; extendObservable(this, &#123; content: content, finished: false &#125;) &#125;&#125;class TodoList &#123; constructor() &#123; extendObservable(this, &#123; todos: [], todoListString: function() &#123; return this.todos.filter(todo =&gt; !todo.finished).map((todo, i) =&gt; `$&#123;i+1&#125;. $&#123;todo.content&#125;`).join('\n'); &#125; &#125;) &#125;&#125;const store = new TodoList();store.todos.push( new Todo("task1"), new Todo("task2"), new Todo("task3"));autorun(() =&gt; console.log(store.todoListString))store.todos[2].finished = true; mobx-react在跟react配合时，mobx提供了mobx-react包，使用@observer装饰器或者observer函数，可以自动将react组建的render方法包装到mobx.autorun里面。还是以前面的TodoList为例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import &#123; observable, computed &#125; from 'mobx';import &#123; observer &#125; from mobxReact;import &#123; Component &#125; from React;class Todo &#123; id = Math.random(); @observable content; @observable finished = false; constructor(content) &#123; this.content = content; &#125; finish() &#123; this.finished = true &#125;&#125;class TodoList &#123; @observable todos = []; @computed get unFinishedList() &#123; return this.todos.filter(todo =&gt; !todo.finished); &#125; @computed get finishedList() &#123; return this.todos.filter(todo =&gt; todo.finished); &#125; addTodo(content) &#123; if (content)&#123; this.todos.push(new Todo(content)) &#125; &#125;&#125;@observerclass TodoListView extends Component &#123; render() &#123; const &#123; todoList &#125; = this.props; let onChange = (event) =&gt; &#123; this.value = event.target.value &#125; let onClick = () =&gt; &#123; todoList.addTodo(this.value) &#125; return (&lt;div&gt; &lt;h2&gt;添加任务&lt;/h2&gt; &lt;input type="text" value=&#123; this.value &#125; onChange=&#123; onChange &#125;/&gt; &lt;button type="button" onClick=&#123; onClick &#125;&gt;添加&lt;/button&gt; &lt;h2&gt;未完成任务&lt;/h2&gt; &lt;ol&gt; &#123;todoList.unFinishedList.slice(0).map((todo,index) =&gt; &lt;TodoView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt; )&#125; &lt;/ol&gt; Tasks left: &#123;todoList.unFinishedList.length&#125; &lt;h2&gt;已完成任务&lt;/h2&gt; &lt;ol&gt; &#123;todoList.finishedList.map((todo) =&gt; &lt;FinishedView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt; )&#125; &lt;/ol&gt; &lt;/div&gt;) &#125;&#125;const TodoView = observer((props) =&gt;&#123; let &#123; todo &#125; = props; return (&lt;li&gt; &lt;input type="checkbox" checked=&#123;todo.finished&#125; onClick=&#123;todo.finish.bind(todo)&#125; /&gt;&#123;todo.content&#125; &lt;/li&gt;) &#125;);@observerclass FinishedView extends Component&#123; render() &#123; let &#123; todo &#125; = this.props; return (&lt;li&gt; &lt;del&gt;&#123;todo.content&#125;&lt;/del&gt; &lt;/li&gt;) &#125;&#125;const store = new TodoList();React.render(&lt;TodoListView todoList=&#123;store&#125; /&gt;, document.body);store.todos.push( new Todo("Get Coffee"), new Todo("Write simpler code")); 在上面的例子里可以看到，使用mobx-react的不同点只是在编写组件类时observer包装了一下，其他的跟不使用mobx-react没什么区别。另外，如果在stroe里加入方法，就可以做到类似action一样的动作，使用上比redux要简单很多。当然这也引出一个问题，就是当子组件状态变化影响到父组件的状态，如何通知父组件。redux用类似dbus的设计解决了这个问题，mobx怎么解决，我还没有看到，后续看到了再做补充。 简单的总结怎么说呢，总感觉mobx的功能和vue好像……￣ω￣=……特别是computed……这种设计对于写惯了mvc的人来说会感觉非常亲切，stroe其实就是相当于平时常写的model嘛，概念很容易理解。难度上，个人感觉不高，除了一些绑定后的数据需要调用set、get方法，api也不多。 其实mobx还有很多的功能没有介绍到，而且在网上资料也很少，如果有时间的话，打算试着翻译mobx的文档。更多的例子，后续再做详细的补充，今天就先到这里吧，我实在是写不动了……_(:3 」∠)_ 相关文章 MobX Documentation A short introduction to MobX]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浮点数计算为什么不精确]]></title>
      <url>%2F2016%2F11%2F17%2F%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%B2%BE%E7%A1%AE%2F</url>
      <content type="text"><![CDATA[其实这篇博客早就写好了，只不过之前懒一直没有整理完善……哈哈哈…… _(:3 」∠)_ 前几几几几天，在微博上看到寇胖转了一个关于浮点数计算的微博，里面的内容不太准确。正好之前我调查过一些关于浮点数的资料，在这里好好掰吃掰吃，做个记录~(￣▽￣)~* 结论先说结论，嫌又臭又长的看到这里就可以了: 浮点数计算不精确并不是bug，因为标准就是这样的。 原因简单来说是这样：2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。 解决方法：对于需要精确结果的场景，别直接使用浮点数进行计算。现阶段可以使用big.js解决，等以后ecmascript实现decimal了，就可以使用decimal类型计算了。 小数算不准，真的是js的锅吗？说到这个问题，其实这是两个锅，js计算不准确不止会出现在小数的计算上，还会出现在大整数计算上，可以运行下面两行代码查看问题的具体表现： 120.1 + 0.2 == 0.3; // false9999999999999999 + 2 == 10000000000000001; // false 当然，这个锅肯定不是javascript背。事实上，使用了IEEE 754 标准来存储浮点类型的任何编程语言（C/C++/C#/Java 等等）都存在精度丢失问题。 例如在 Java 中，要想算准浮点数，同样不能直接计算，需要使用 BigDecimal 类来进行相应的处理。 当然，javascript也并没有落后于其他语言。ECMAScript 规范中已有 decimal 类型的提案了，但目前尚未被正式采纳。 为什么不算准？要解释这个问题，就得从10进制与2进制的转换说起。 众所周知，计算机做运算是使用二级制的。所以其实咱们在程序中做10进制运算，都是要转换为2进制再进行计算的。10进制整数转换为2进制的方法可能大家都知道： 除以2，商继续除以2，得到0为止，将余数逆序排列例如：22 / 2 11 余 011 / 2 5 余 15 / 2 2 余 12 / 2 1 余 01 / 2 0 余 1所以22的的二进制是10110 那10进制小数转换为2进制的方法呢？ 乘以2，取整，小数部分继续乘以2，取整，得到小数部分0为止，将整数顺序排列0.8125 x 2 1.625 取 10.625 x 2 1.25 取 10.25 x 2 0.5 取 00.5 x 2 1.0 取 1所以0.8125的二进制是0.1101 那么问题就来了，比如你想计算10进制0.2的2进制： 0.2 x 2 0.40.4 x 2 0.80.8 x 2 1.60.6 x 2 1.20.2 x 2 0.4…… 发现了吗？它乘不尽，是无限循环的…… 而 javascript 使用64位双精度浮点数存储数字，类似科学计数法，其中1位用来存储符号，11位用来存储指数值，52位用来存储尾数值（真正的数字），当计算的结果的二进制有效位数超过 52 位时，就会出现精度丢失的问题…… 大整数计算的原因也是一样，有效位数超过 52位时，精度就会丢失 这就解释了下面这种情况： 十进制 0.1 的二进制为 0.0 0011 0011 0011 … （循环 0011）十进制 0.2 的二进制为 0.0011 0011 0011 … （循环 0011） 0.1 + 0.2 相加可表示为： e = -4; m = 1.10011001100…1100（52 位） + e = -3; m = 1.10011001100…1100（52 位）-——————————————– e = -3; m = 0.11001100110…0110 + e = -3; m = 1.10011001100…1100-——————————————– e = -3; m = 10.01100110011…001-——————————————– = 0.01001100110011…001 = 0.30000000000000004（十进制） 但是0.05和0.2用二进制都无法精确表达，0.05 + 0.2 却不会计算错误，0.2 + 0.7 会计算错误，1.2 +1.7 又不会，这又是为什么？ 具体的原因我并没有找到相关的资料…… 貌似这和 IEEE 754 的舍入模式有关系。 IEEE 754 采用的是最近舍入模式，和我们最熟悉的是四舍五入模式有些许不同，也是比较容易引起误解的地方之一。举例比较如下： 最近舍入模式：Round(0.5) = 0; Round(1.5) = 2; Round(2.5) = 2; 四舍五入模式：Round(0.5) = 1; Round(1.5) = 2; Round(2.5) = 3; 既当有两个最接近的可表示的值时首选“偶数”值。 具体的原因我会再调查调查，有了新的资料再补充到这里。 如何解决这个问题？当然，问题的解决方法其实也已经有前人跟咱们铺好路了，毕竟这个在问题在编程领域里其实是个挺常见的问题…… 网上的解决办法五花八门，总的原则就是逐位运算。我推荐 github 上 MikeMcl 开发的 big.js 。这个库不尽支持基础运算，而且还支持各种函数运算和比较运算，相当全面呢。实现上，是将数字按照科学计数法解析成一个包含正负符号、指数、尾数的对象，再做运算。例子就不写了，它的文档很全，而且简单易懂。 有趣的是，这个作者除了 big.js 还开发了另两个计算库 bignumber.js 和 decimal.js，三个库的侧重点不一样，关于这三个的对比，有兴趣的话可以看作者自己写的wiki What is the difference between big.js, bignumber.js and decimal.js? 相关文章: 浮点数为什么不精确？ JavaScript超大整数加法 JavaScript 中小数和大整数的精度丢失 IEEE 754 浮点数的表示精度探讨 IEEE 754]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>%2F2016%2F11%2F16%2F%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
      <content type="text"><![CDATA[哈，距离上次写博客刚好一年了呢，话说我还真是懒呢…… _(:3 」∠)_ 这里不得不感叹下榜样的力量是无穷的。要不是继伟发起每周写博客的活动，估计我现在还在床上躺着呢……读好书，交高人，此言非虚呀~ 总之，希望这是个新的开始，期待能遇见更好的自己~(｡･ω･｡)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Capitan之后JetBrains的产品都不能用了]]></title>
      <url>%2F2015%2F11%2F21%2FCapitan%E4%B9%8B%E5%90%8EJetBrains%E7%9A%84%E4%BA%A7%E5%93%81%E9%83%BD%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86%2F</url>
      <content type="text"><![CDATA[更新了osx升级10.11 EL Capitan之后发现有好多坑啊……限制超多而且JetBrains的产品都不能用了…… 查了一溜够貌似是之前安装的一些系统软件都被清除了，而且还需要接触rootless模式，总之先附上搜索到的资料链接吧 Intellij IDEAやAppCodeが起動しない場合に考えられること（需翻墙）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[邮件链接中加入参数可以给要发送的邮件添加标题和内容，第一次发现唉]]></title>
      <url>%2F2015%2F10%2F21%2F%E9%82%AE%E4%BB%B6%E9%93%BE%E6%8E%A5%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E7%BB%99%E8%A6%81%E5%8F%91%E9%80%81%E7%9A%84%E9%82%AE%E4%BB%B6%E6%B7%BB%E5%8A%A0%E6%A0%87%E9%A2%98%E5%92%8C%E5%86%85%E5%AE%B9%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%91%E7%8E%B0%E5%94%89%2F</url>
      <content type="text"><![CDATA[a标签的href属性值可以是mailto协议的地址，这个比较常见，但是能加参数设置邮件内容我还是第一次见呢。 示例： mailto:xxx@xxx.com?Subject=标题&amp;Body=正文 貌似按照get方式加上参数就行了，Subject代表标题，Body代表正文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[总结下hexo搭建的过程]]></title>
      <url>%2F2015%2F10%2F16%2F%E6%80%BB%E7%BB%93%E4%B8%8Bhexo%E6%90%AD%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[2016-11-16 UPDATE: 距离写下这篇博客已经过了一年了，hexo在这一年里发展的挺快。现在hexo的文档已经齐全，整个工作流程也相当顺畅了。 安装过程中如果 node-gyp 报 error，可以尝试升级xcode，并安装xcode-select 升级 CLT。 下面附上几篇比较好的文章，建站过程中遇到问题可以查阅一下。 Hexo常见问题解决方案收集了很多使用hexo过程中的常见问题 hexo你的博客文章的内容很全，不止写了如何使用hexo，如何使用github，如何找图床等问题也都有描述，如果是使用github pages搭建博客的话，看这篇就够用了 如何搭建一个独立博客——简明Github Pages与Hexo教程和上一篇文章一样，这篇文章的内容也很全面，除了博客的搭建过程，如何在购买域名和服务器也有描述，只不过图片貌似都已经失效了……有些遗憾呢…… 翻译自GitHub Pages的Help页面（仍在更新中）github pages的help页面的翻译，对于英语苦手的人来说，应该会很有帮助吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[总结一下升级OS X El Capitan后brew遇到的问题]]></title>
      <url>%2F2015%2F10%2F15%2F%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%8D%87%E7%BA%A7OS-X-El-Capitan%E5%90%8Ebrew%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[升级了osx之后，先是brew update的时候报错，后来用brew安装jenv的时候又提示说需要root权限 Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo.Error: Failure while executing: /usr/bin/otool -L /usr/bin/install_name_tool 但是sudo brew install又报错 Error: Cowardly refusing to sudo brew installYou can use brew with sudo, but only if the brew executable is owned by root.However, this is both not recommended and completely unsupported so do so at your own risk. 搜了下貌似是新版osx的问题，需要进行权限设置，用chown命令设置一下就好了 以下是一些参考资料 How To Fix Cowardly Refusing to Sudo error in Brew – Mac OS X Failed brew update on El Capitan (OS X 10.11) Beta Mac OS X El Capitan にアップデートした後に brew update が動かない場合の対処方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[啊，我的第一次]]></title>
      <url>%2F2015%2F10%2F14%2Ffirst-love%2F</url>
      <content type="text"><![CDATA[人生第一篇blog，总觉得有点儿小激动呢……⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄ 话说再过生日就30岁了呢，做程序员也是第8个年头，愈发觉得将自己的平时的一些想法、遇到的一些问题记录下来很重要，其实以前也很想，奈何我懒…… 总之，之后会努力多写一些，也算是对自己的一种提升吧，嗯，希望我能一直坚持下去~ &lt;(￣▽￣)&gt; 哈哈哈……]]></content>
    </entry>

    
  
  
</search>
