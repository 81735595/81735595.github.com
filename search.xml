<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[React全家桶又填新成员 MobX入坑指南(1)]]></title>
      <url>%2F2016%2F11%2F23%2FMobX-simple-entry-1%2F</url>
      <content type="text"><![CDATA[话说，吐槽被react全家桶坑的文章已经算是各大论坛上的月经贴了吧……行内样式、jsx里html和js混排、依赖太多、学习曲线陡峭……当然其中不乏抱怨redux反人类的…… 当然，这篇文章并不是来黑react不好的，毕竟以后涨工资还得靠它呢哈哈哈(￣▽￣)…… 今天咱们要说的是众多槽点之一，”反人类的redux”和其替代方案。 redux有什么不好？首先，redux绝对是个优秀的库。它体小精悍，api简单优雅，扩展能力强，足以衍生出丰富的工具集和生态系统。在它出现之前，各种flux实现貌似都不能让人如意，以至于有人宁可用 backbone 甚至是 angular 和 react搭配，也不用flux……后来redux出现，解决了flux操作繁琐的问题，开始受到人们的关注，再后来作者也加入了 facebook从事react的开发，redux也顺理成章的成为了react官方推荐状态管理库。 但是，在真正去开发的时候，我发现状态的维护还是有些繁琐，如果你在设计阶段没有考虑周全，开发时就要不停的在action,container,reducer之前修改，穿梭，让人眼花缭乱……嗯，也没准儿是我项目不够大…… 另外，由于redux大量使用函数式编程的思想，门槛有点高呢。当时为了理解redux里面的概念，我大概读了一周的文档…… 按你胃（Anywhere），如果你更熟悉面向对象，羡慕mvvm框架的简单，那你真的应该体验一下mobx mobx是啥？mobx是个新的状态管理库，响应式的，我是看了阮一峰的微博知道的，后来查了资料发现，redux的作者在twitter推荐了这个库，还是作为redex的替代品…… 那么废话少说，让我们现在看看mobx怎么用吧 api简单介绍和redux一样，mobx是一个独立的库，不依赖于react也能自己用，它只有三个概念：观测状态，计算值和反应。这三个概念分别对应三个mobx的api：observable，computed和autorun。 咱们先来个最简单的例子 1234567891011121314151617import &#123; observable, computed, autorun &#125; from 'mobx';let numbers = observable([1,2,3]);let sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, 0));let disposer1 = autorun(() =&gt; console.log(`sum:$&#123;sum.get()&#125;`));let disposer2 = autorun(() =&gt; console.log(`length:$&#123;numbers.length&#125;`));// sum:6// length:3numbers.push(4);// sum:10// length:4disposer2();numbers.push(5);// sum:15 这个例子中，observable用来绑定数据；computed用来绑定计算方法；autorun用来注册数据变化时响应的方法，返回的函数用来取消响应。 下面我们试着来写一个TodoList 12345678910111213141516171819202122232425262728import &#123; observable, computed, autorun &#125; from 'mobx';class Todo &#123; id = Math.random(); @observable content; @observable finished = false; constructor(content) &#123; this.content = content; &#125;&#125;class TodoList &#123; @observable todos = []; @computed get todoListString() &#123; return this.todos.filter(todo =&gt; !todo.finished).map((todo, i) =&gt; `$&#123;i+1&#125;. $&#123;todo.content&#125;`).join('\n'); &#125;&#125;const store = new TodoList();store.todos.push( new Todo("task1"), new Todo("task2"), new Todo("task3"));autorun(() =&gt; console.log(store.todoListString))store.todos[2].finished = true; 从上面的例子可以看到，针对类的属性，可以使用修饰器@observable、@computed来进行绑定，修饰器是ES7的一个提案，目前Babel已经支持。详细的介绍可以看ECMAScript 6 入门中修饰器一章 如果不想用修饰器，也可以使用extendObservable函数，跟修饰器的功能是一样的： 123456789101112131415161718192021222324252627282930313233import &#123; extendObservable, autorun &#125; from 'mobx';class Todo &#123; id = Math.random(); constructor(content) &#123; extendObservable(this, &#123; content: content, finished: false &#125;) &#125;&#125;class TodoList &#123; constructor() &#123; extendObservable(this, &#123; todos: [], todoListString: function() &#123; return this.todos.filter(todo =&gt; !todo.finished).map((todo, i) =&gt; `$&#123;i+1&#125;. $&#123;todo.content&#125;`).join('\n'); &#125; &#125;) &#125;&#125;const store = new TodoList();store.todos.push( new Todo("task1"), new Todo("task2"), new Todo("task3"));autorun(() =&gt; console.log(store.todoListString))store.todos[2].finished = true; mobx-react在跟react配合时，mobx提供了mobx-react包，使用@observer装饰器或者observer函数，可以自动将react组建的render方法包装到mobx.autorun里面。还是以前面的TodoList为例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import &#123; observable, computed &#125; from 'mobx';import &#123; observer &#125; from mobxReact;import &#123; Component &#125; from React;class Todo &#123; id = Math.random(); @observable content; @observable finished = false; constructor(content) &#123; this.content = content; &#125; finish() &#123; this.finished = true &#125;&#125;class TodoList &#123; @observable todos = []; @computed get unFinishedList() &#123; return this.todos.filter(todo =&gt; !todo.finished); &#125; @computed get finishedList() &#123; return this.todos.filter(todo =&gt; todo.finished); &#125; addTodo(content) &#123; if (content)&#123; this.todos.push(new Todo(content)) &#125; &#125;&#125;@observerclass TodoListView extends Component &#123; render() &#123; const &#123; todoList &#125; = this.props; let onChange = (event) =&gt; &#123; this.value = event.target.value &#125; let onClick = () =&gt; &#123; todoList.addTodo(this.value) &#125; return &lt;div&gt; &lt;h2&gt;添加任务&lt;/h2&gt; &lt;input type="text" value=&#123; this.value &#125; onChange=&#123; onChange &#125;/&gt; &lt;button type="button" onClick=&#123; onClick &#125;&gt;添加&lt;/button&gt; &lt;h2&gt;未完成任务&lt;/h2&gt; &lt;ol&gt; &#123;todoList.unFinishedList.slice(0).map((todo,index) =&gt; &lt;TodoView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt; )&#125; &lt;/ol&gt; Tasks left: &#123;todoList.unFinishedList.length&#125; &lt;h2&gt;已完成任务&lt;/h2&gt; &lt;ol&gt; &#123;todoList.finishedList.map((todo) =&gt; &lt;FinishedView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt; )&#125; &lt;/ol&gt; &lt;/div&gt; &#125;&#125;const TodoView = observer((props) =&gt;&#123; let &#123; todo &#125; = props; return &lt;li&gt; &lt;input type="checkbox" checked=&#123;todo.finished&#125; onClick=&#123;todo.finish.bind(todo)&#125; /&gt;&#123;todo.content&#125; &lt;/li&gt; &#125;);@observerclass FinishedView extends Component&#123; render() &#123; let &#123; todo &#125; = this.props; return &lt;li&gt; &lt;del&gt;&#123;todo.content&#125;&lt;/del&gt; &lt;/li&gt; &#125;&#125;const store = new TodoList();React.render(&lt;TodoListView todoList=&#123;store&#125; /&gt;, document.body);store.todos.push( new Todo("Get Coffee"), new Todo("Write simpler code")); 在上面的例子里可以看到，使用mobx-react的不同点只是在编写组件类时observer包装了一下，其他的跟不使用mobx-react没什么区别。另外，如果在stroe里加入方法，就可以做到类似action一样的动作，使用上比redux要简单很多。当然这也引出一个问题，就是当子组件状态变化影响到父组件的状态，如何通知父组件。redux用类似dbus的设计解决了这个问题，mobx怎么解决，我还没有看到，后续看到了再做补充。 简单的总结怎么说呢，总感觉mobx的功能和vue好像……￣ω￣=……特别是computed……这种设计对于写惯了mvc的人来说会感觉非常亲切，stroe其实就是相当于平时常写的model嘛，概念很容易理解。难度上，个人感觉不高，除了一些绑定后的数据需要调用set、get方法，api也不多。 其实mobx还有很多的功能没有介绍到，而且在网上资料也很少，如果有时间的话，打算试着翻译mobx的文档。更多的例子，后续再做详细的补充，今天就先到这里吧，我实在是写不动了……_(:3 」∠)_ 相关文章 MobX Documentation A short introduction to MobX]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浮点数计算为什么不精确]]></title>
      <url>%2F2016%2F11%2F17%2F%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%B2%BE%E7%A1%AE%2F</url>
      <content type="text"><![CDATA[其实这篇博客早就写好了，只不过之前懒一直没有整理完善……哈哈哈…… _(:3 」∠)_ 前几几几几天，在微博上看到寇胖转了一个关于浮点数计算的微博，里面的内容不太准确。正好之前我调查过一些关于浮点数的资料，在这里好好掰吃掰吃，做个记录~(￣▽￣)~* 结论先说结论，嫌又臭又长的看到这里就可以了: 浮点数计算不精确并不是bug，因为标准就是这样的。 原因简单来说是这样：2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。 解决方法：对于需要精确结果的场景，别直接使用浮点数进行计算。现阶段可以使用big.js解决，等以后ecmascript实现decimal了，就可以使用decimal类型计算了。 小数算不准，真的是js的锅吗？说到这个问题，其实这是两个锅，js计算不准确不止会出现在小数的计算上，还会出现在大整数计算上，可以运行下面两行代码查看问题的具体表现： 120.1 + 0.2 == 0.3; // false9999999999999999 + 2 == 10000000000000001; // false 当然，这个锅肯定不是javascript背。事实上，使用了IEEE 754 标准来存储浮点类型的任何编程语言（C/C++/C#/Java 等等）都存在精度丢失问题。 例如在 Java 中，要想算准浮点数，同样不能直接计算，需要使用 BigDecimal 类来进行相应的处理。 当然，javascript也并没有落后于其他语言。ECMAScript 规范中已有 decimal 类型的提案了，但目前尚未被正式采纳。 为什么不算准？要解释这个问题，就得从10进制与2进制的转换说起。 众所周知，计算机做运算是使用二级制的。所以其实咱们在程序中做10进制运算，都是要转换为2进制再进行计算的。10进制整数转换为2进制的方法可能大家都知道： 除以2，商继续除以2，得到0为止，将余数逆序排列例如：22 / 2 11 余 011 / 2 5 余 15 / 2 2 余 12 / 2 1 余 01 / 2 0 余 1所以22的的二进制是10110 那10进制小数转换为2进制的方法呢？ 乘以2，取整，小数部分继续乘以2，取整，得到小数部分0为止，将整数顺序排列0.8125 x 2 1.625 取 10.625 x 2 1.25 取 10.25 x 2 0.5 取 00.5 x 2 1.0 取 1所以0.8125的二进制是0.1101 那么问题就来了，比如你想计算10进制0.2的2进制： 0.2 x 2 0.40.4 x 2 0.80.8 x 2 1.60.6 x 2 1.20.2 x 2 0.4…… 发现了吗？它乘不尽，是无限循环的…… 而 javascript 使用64位双精度浮点数存储数字，类似科学计数法，其中1位用来存储符号，11位用来存储指数值，52位用来存储尾数值（真正的数字），当计算的结果的二进制有效位数超过 52 位时，就会出现精度丢失的问题…… 大整数计算的原因也是一样，有效位数超过 52位时，精度就会丢失 这就解释了下面这种情况： 十进制 0.1 的二进制为 0.0 0011 0011 0011 … （循环 0011）十进制 0.2 的二进制为 0.0011 0011 0011 … （循环 0011） 0.1 + 0.2 相加可表示为： e = -4; m = 1.10011001100…1100（52 位） + e = -3; m = 1.10011001100…1100（52 位）-——————————————– e = -3; m = 0.11001100110…0110 + e = -3; m = 1.10011001100…1100-——————————————– e = -3; m = 10.01100110011…001-——————————————– = 0.01001100110011…001 = 0.30000000000000004（十进制） 但是0.05和0.2用二进制都无法精确表达，0.05 + 0.2 却不会计算错误，0.2 + 0.7 会计算错误，1.2 +1.7 又不会，这又是为什么？ 具体的原因我并没有找到相关的资料…… 貌似这和 IEEE 754 的舍入模式有关系。 IEEE 754 采用的是最近舍入模式，和我们最熟悉的是四舍五入模式有些许不同，也是比较容易引起误解的地方之一。举例比较如下： 最近舍入模式：Round(0.5) = 0; Round(1.5) = 2; Round(2.5) = 2; 四舍五入模式：Round(0.5) = 1; Round(1.5) = 2; Round(2.5) = 3; 既当有两个最接近的可表示的值时首选“偶数”值。 具体的原因我会再调查调查，有了新的资料再补充到这里。 如何解决这个问题？当然，问题的解决方法其实也已经有前人跟咱们铺好路了，毕竟这个在问题在编程领域里其实是个挺常见的问题…… 网上的解决办法五花八门，总的原则就是逐位运算。我推荐 github 上 MikeMcl 开发的 big.js 。这个库不尽支持基础运算，而且还支持各种函数运算和比较运算，相当全面呢。实现上，是将数字按照科学计数法解析成一个包含正负符号、指数、尾数的对象，再做运算。例子就不写了，它的文档很全，而且简单易懂。 有趣的是，这个作者除了 big.js 还开发了另两个计算库 bignumber.js 和 decimal.js，三个库的侧重点不一样，关于这三个的对比，有兴趣的话可以看作者自己写的wiki What is the difference between big.js, bignumber.js and decimal.js? 相关文章: 浮点数为什么不精确？ JavaScript超大整数加法 JavaScript 中小数和大整数的精度丢失 IEEE 754 浮点数的表示精度探讨 IEEE 754]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>%2F2016%2F11%2F16%2F%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
      <content type="text"><![CDATA[哈，距离上次写博客刚好一年了呢，话说我还真是懒呢…… _(:3 」∠)_ 这里不得不感叹下榜样的力量是无穷的。要不是继伟发起每周写博客的活动，估计我现在还在床上躺着呢……读好书，交高人，此言非虚呀~ 总之，希望这是个新的开始，期待能遇见更好的自己~(｡･ω･｡)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Capitan之后JetBrains的产品都不能用了]]></title>
      <url>%2F2015%2F11%2F21%2FCapitan%E4%B9%8B%E5%90%8EJetBrains%E7%9A%84%E4%BA%A7%E5%93%81%E9%83%BD%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86%2F</url>
      <content type="text"><![CDATA[更新了osx升级10.11 EL Capitan之后发现有好多坑啊……限制超多而且JetBrains的产品都不能用了…… 查了一溜够貌似是之前安装的一些系统软件都被清除了，而且还需要接触rootless模式，总之先附上搜索到的资料链接吧 Intellij IDEAやAppCodeが起動しない場合に考えられること（需翻墙）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[邮件链接中加入参数可以给要发送的邮件添加标题和内容，第一次发现唉]]></title>
      <url>%2F2015%2F10%2F21%2F%E9%82%AE%E4%BB%B6%E9%93%BE%E6%8E%A5%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E7%BB%99%E8%A6%81%E5%8F%91%E9%80%81%E7%9A%84%E9%82%AE%E4%BB%B6%E6%B7%BB%E5%8A%A0%E6%A0%87%E9%A2%98%E5%92%8C%E5%86%85%E5%AE%B9%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%91%E7%8E%B0%E5%94%89%2F</url>
      <content type="text"><![CDATA[a标签的href属性值可以是mailto协议的地址，这个比较常见，但是能加参数设置邮件内容我还是第一次见呢。 示例： mailto:xxx@xxx.com?Subject=标题&amp;Body=正文 貌似按照get方式加上参数就行了，Subject代表标题，Body代表正文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[总结下hexo搭建的过程]]></title>
      <url>%2F2015%2F10%2F16%2F%E6%80%BB%E7%BB%93%E4%B8%8Bhexo%E6%90%AD%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[2016-11-16 UPDATE: 距离写下这篇博客已经过了一年了，hexo在这一年里发展的挺快。现在hexo的文档已经齐全，整个工作流程也相当顺畅了。 安装过程中如果 node-gyp 报 error，可以尝试升级xcode，并安装xcode-select 升级 CLT。 下面附上几篇比较好的文章，建站过程中遇到问题可以查阅一下。 Hexo常见问题解决方案收集了很多使用hexo过程中的常见问题 hexo你的博客文章的内容很全，不止写了如何使用hexo，如何使用github，如何找图床等问题也都有描述，如果是使用github pages搭建博客的话，看这篇就够用了 如何搭建一个独立博客——简明Github Pages与Hexo教程和上一篇文章一样，这篇文章的内容也很全面，除了博客的搭建过程，如何在购买域名和服务器也有描述，只不过图片貌似都已经失效了……有些遗憾呢…… 翻译自GitHub Pages的Help页面（仍在更新中）github pages的help页面的翻译，对于英语苦手的人来说，应该会很有帮助吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[总结一下升级OS X El Capitan后brew遇到的问题]]></title>
      <url>%2F2015%2F10%2F15%2F%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%8D%87%E7%BA%A7OS-X-El-Capitan%E5%90%8Ebrew%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[升级了osx之后，先是brew update的时候报错，后来用brew安装jenv的时候又提示说需要root权限 Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo.Error: Failure while executing: /usr/bin/otool -L /usr/bin/install_name_tool 但是sudo brew install又报错 Error: Cowardly refusing to sudo brew installYou can use brew with sudo, but only if the brew executable is owned by root.However, this is both not recommended and completely unsupported so do so at your own risk. 搜了下貌似是新版osx的问题，需要进行权限设置，用chown命令设置一下就好了 以下是一些参考资料 How To Fix Cowardly Refusing to Sudo error in Brew – Mac OS X Failed brew update on El Capitan (OS X 10.11) Beta Mac OS X El Capitan にアップデートした後に brew update が動かない場合の対処方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[啊，我的第一次]]></title>
      <url>%2F2015%2F10%2F14%2Ffirst-love%2F</url>
      <content type="text"><![CDATA[人生第一篇blog，总觉得有点儿小激动呢……⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄ 话说再过生日就30岁了呢，做程序员也是第8个年头，愈发觉得将自己的平时的一些想法、遇到的一些问题记录下来很重要，其实以前也很想，奈何我懒…… 总之，之后会努力多写一些，也算是对自己的一种提升吧，嗯，希望我能一直坚持下去~ &lt;(￣▽￣)&gt; 哈哈哈……]]></content>
    </entry>

    
  
  
</search>
