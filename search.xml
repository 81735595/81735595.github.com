<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[vue源码阅读笔记(3)]]></title>
      <url>%2F2017%2F04%2F14%2Fvue-source-notes-3%2F</url>
      <content type="text"><![CDATA[啊……写这篇博客的时候我刚上了一宿的线……现在多一个字都不想说了……直接开始吧…… 公共方法模块 shared故名思议，shared模块是放所有公共方法的，里面只有 util.js 一个文件。 util.jsutil.js一共暴露了23个方法，每个函数都非常基础，第一眼看上去感觉没啥可看的，但是仔细看每个函数会发现，这些函数都很实用，而且正是因为基础，很可能会成为以后面试的考题…… 总之过一遍下这些方法吧，记录下我认为有用的知识点，当做事知识储备了： _toString123456789101112// 这个函数可以将任意类型的值转为字符串export function _toString (val: any): string &#123; return val == null // 如果是null就返回空字符串 ? '' : typeof val === 'object' // 如果是object就转成json // 这里比较特殊的是在调用stringify时除了要转换的值，还多传了两个参数，其中第二个参数用来过滤数据，第三个参数用来控制内容的缩进 ? JSON.stringify(val, null, 2) // 其他的都是用String来转换为字符串，其实跟调用对象的toString是一样的吧？ : String(val)&#125; toNumber123456// 将传入的值转换为浮点数，如果转换失败就返回传入值export function toNumber (val: string): number | string &#123; // 浮点数没加 ",10" ，不知道是不是个隐藏的问题 const n = parseFloat(val) return isNaN(n) ? val : n&#125; makeMap123456789101112131415// 这个函数比较有意思，功能有点儿像集合（Set）对象，但是只能存储字符串，最后用来判断值是否已经存在// 貌似是用来快速检索某个值是否存在用的export function makeMap ( str: string, expectsLowerCase?: boolean): (key: string) =&gt; true | void &#123; const map = Object.create(null) const list: Array&lt;string&gt; = str.split(',') for (let i = 0; i &lt; list.length; i++) &#123; map[list[i]] = true &#125; return expectsLowerCase ? val =&gt; map[val.toLowerCase()] : val =&gt; map[val]&#125; isBuiltInTag12// 生成一个用来检索是否是内置标签的函数，用到了之前的makeMap方法export const isBuiltInTag = makeMap('slot,component', true) remove123456789// 一个工具方法，用来删除数组中匹配到的对象export function remove (arr: Array&lt;any&gt;, item: any): Array&lt;any&gt; | void &#123; if (arr.length) &#123; const index = arr.indexOf(item) if (index &gt; -1) &#123; return arr.splice(index, 1) &#125; &#125;&#125; hasOwn12345678910111213// 对Object.prototype.hasOwnProperty的封装，用来判断对象的属性是否是继承自原型的// 顺便复习下instanceof和typeof// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof// 除了三者作用的区别以外，需要注意的是，hasOwnProperty是函数，instanceof和typeof是运算符// 其实MDN上写的instanceof是运算符，typeof是操作符，特意查了一下，在英语中操作符和运算符都叫operator，应该可以认为是一个东西吧// 与函数的区别在于，一个是符号，一个是有名称的，另外，函数有明确定义的参数表，符号没有// 当然，从广义来上来看，任何一个运算符都可看做是一个函数，而它的运算数可看做参数const hasOwnProperty = Object.prototype.hasOwnPropertyexport function hasOwn (obj: Object, key: string): boolean &#123; return hasOwnProperty.call(obj, key)&#125; isPrimitive12345// 判断一个值是否是基础类型？字面上看primitive是原始的意思……// 总之就是判断传入的参数是否是数字或者字符串export function isPrimitive (value: any): boolean &#123; return typeof value === 'string' || typeof value === 'number'&#125; cached12345678910111213// 生成一个带缓存的纯函数// 就是会把每次函数执行的结果缓存起来// 根据纯函数的定义，传入同样的参数值，函数总是求出同样的结果，这样处理之后可以大幅提升函数的运算速度export function cached&lt;F: Function&gt; (fn: F): F &#123; // 定义缓存对象 const cache = Object.create(null) return (function cachedFn (str: string) &#123; // 根据传入的参数取缓存 const hit = cache[str] // 检查缓存是否存在，如果存在就直接返回缓存，缓存不存在就运行函数缓存结果 return hit || (cache[str] = fn(str)) &#125;: any)&#125; camelize123456// 将破折号分割的命名修改为驼峰命名// 感觉是在解析模板时，将tag name转换为 class name用的const camelizeRE = /-(\w)/gexport const camelize = cached((str: string): string =&gt; &#123; return str.replace(camelizeRE, (_, c) =&gt; c ? c.toUpperCase() : '')&#125;) capitalize123456// 将字符串首字母转换为大写的函数// 估计是跟camelize配合一起使用的吧// 最后的效果就是：&lt;my-component&gt; ==&gt; MyComponentexport const capitalize = cached((str: string): string =&gt; &#123; return str.charAt(0).toUpperCase() + str.slice(1)&#125;) hyphenate1234567891011// 将驼峰命名再改回中划线命名……(￣.￣)// 效果类似于：ABCD =&gt; a-b-c-dconst hyphenateRE = /([^-])([A-Z])/gexport const hyphenate = cached((str: string): string =&gt; &#123; return st // 这里要调用两次replace是因为，如果是 ABCD 这种包含三个连续大写字母的字符串， // 只replace一次会变成A-BC-D这样，需要再replace一次…… .replace(hyphenateRE, '$1-$2') .replace(hyphenateRE, '$1-$2') .toLowerCase()&#125;) bind1234567891011121314// 简单实现的bind方法，源码的注释中说比原生的bind快export function bind (fn: Function, ctx: Object): Function &#123; function boundFn (a) &#123; const l: number = arguments.length return l ? l &gt; 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx) &#125; // 记录原始函数的参数个数 boundFn._length = fn.length return boundFn&#125; toArray1234567891011121314151617181920// 将类数组对象转化为一个数组，其实这个操作挺常见的，但是这样用循环处理貌似效率低呢// 测试了一下使用Array.prototype上的方法来做转换会快100倍……// 不知道为啥不用……export function toArray (list: any, start?: number): Array&lt;any&gt; &#123; start = start || 0 let i = list.length - start const ret: Array&lt;any&gt; = new Array(i) while (i--) &#123; ret[i] = list[i + start] &#125; return ret&#125;// 用14年的mac air测试，// 使用concat和slice来做转换的版本，转换10000次耗时10ms，// 用循环的版本耗时1000msexport function toArray (list: any, start?: number): Array&lt;any&gt; &#123; start = start || 0 const ret: Array&lt;any&gt; = [].concat(list) return ret.slice(start)&#125; extend1234567// 简单的浅拷贝，原来用的object.keys来取key，现在改成用循环了，估计用原生API效率低吧export function extend (to: Object, _from: ?Object): Object &#123; for (const key in _from) &#123; to[key] = _from[key] &#125; return to&#125; isObject1234// 超简单的对象检查……export function isObject (obj: mixed): boolean &#123; return obj !== null &amp;&amp; typeof obj === 'object'&#125; isPlainObject123456// 使用Object.prototype.toString做的严格对象检查const toString = Object.prototype.toStringconst OBJECT_STRING = '[object Object]'export function isPlainObject (obj: any): boolean &#123; return toString.call(obj) === OBJECT_STRING&#125; toObject1234567891011121314151617// 讲一个元素都是对象的数组合并成一个对象……// 貌似是用来将标签的属性合并为一个配置对象用的export function toObject (arr: Array&lt;any&gt;): Object &#123; const res = &#123;&#125; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i]) &#123; extend(res, arr[i]) &#125; &#125; return res&#125;// 话说之前看到的使用reduce来遍历对象的方法，其实也能够使在这里的// 比如这样export function toObject (arr: Array&lt;any&gt;): Object &#123; return arr.reduce((res, cur) =&gt; extend(res,cur), &#123;&#125;)&#125;// 是不是简洁多了呢？ noop123// 不执行操作的空函数// 抓要是为了兼容那些需要函数作为参数的函数，有没有可做的操作时用的export function noop () &#123;&#125; no12// 永远返回false的函数，作用跟noop一样的export const no = () =&gt; false identity12// 返回传入的参数，同上，嗯……export const identity = (_: any) =&gt; _ genStaticKeys1234567// 用来将模块数组转换出模块名的一个字符串……// 这个方法也是用了reduce来做遍历赋值，使用这种方法还真是挺简洁的export function genStaticKeys (modules: Array&lt;ModuleOptions&gt;): string &#123; return modules.reduce((keys, m) =&gt; &#123; return keys.concat(m.staticKeys || []) &#125;, []).join(',')&#125; looseEqual123456789101112// 简单比较两个对象是否一致，就是转成字符串然后比较字符串是否一致export function looseEqual (a: mixed, b: mixed): boolean &#123; const isObjectA = isObject(a) const isObjectB = isObject(b) if (isObjectA &amp;&amp; isObjectB) &#123; return JSON.stringify(a) === JSON.stringify(b) &#125; else if (!isObjectA &amp;&amp; !isObjectB) &#123; return String(a) === String(b) &#125; else &#123; return false &#125;&#125; looseIndexOf12345678// 使用了looseEqual的indexOf// 话说这个判断方法的思想就是，只要有同样的结构，那么就是同样的对象export function looseIndexOf (arr: Array&lt;mixed&gt;, val: mixed): number &#123; for (let i = 0; i &lt; arr.length; i++) &#123; if (looseEqual(arr[i], val)) return i &#125; return -1&#125; once123456789101112// 确保只调用一次函数export function once (fn: Function): Function &#123; // called应该算是一个锁吧 let called = false return () =&gt; &#123; if (!called) &#123; // 上锁 called = true fn() &#125; &#125;&#125; 昏昏沉沉的总算是完了……不知道是缺觉还是怎么的，写着技术的文章，心里却想到了很多技术之外的东西。不过今天实在是没精力写了，留个TODO吧，后续整理好了再更新上来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nodejs热更新的方法]]></title>
      <url>%2F2017%2F04%2F07%2Fnodejs-hotreload%2F</url>
      <content type="text"><![CDATA[嗯，没错，我又来要放水了今天……这个周末停休了，没辙没辙的…… 背景话说上周看了朋友的一篇博客 通过 respawn 加强需要即时生效的开发环境构建系统 ，里面说到了用子进程来更新应用的方法，个人感觉就是像Jetty那样的热部署机制吧。但是归根结底，还是要重新启动整个应用才能完成更新，这点上来说感觉并不完美。那么能不能做到真正的0重启热更新代码呢？本文提一个另类的思路给大家参考一下。 思路废话不多说了，认真读过nodejs文档的人都应该注意过这个api require.cache 。文档里写的很清楚，如果这个对象中的引用被清除了，下次再调用就会重新加载，我们可以使用这个机制来热加载更新的模块。 下面有个小栗子可以验证这个思路的可行性： 123456789101112131415161718192021222324252627282930// main.jsvar fs = require('fs');function cleanCache (module) &#123; var path = require.resolve(module); require.cache[path] &amp;&amp; (require.cache[path] = null);&#125;function write (text) &#123; return function () &#123; return new Promise(function(resolve) &#123; setTimeout(function()&#123; fs.writeFileSync("test.js", "module.exports = \"" + text + "\";"); resolve(true) &#125;,1000) &#125;); &#125;&#125;fs.watchFile('test.js',&#123; interval:100&#125;, function () &#123; cleanCache('./test'); console.log(require('./test'));&#125;);write("hello")().then(write("my name is zxc"))// test.jsmodule.exports = ''; 问题当然这种方法看上去挺好，但是存在的问题也挺多的。首先，这个方法没办法更新c\c++模块，另外，原生模块也是没法更新的。然后，由于 node.js 本身缺乏对有效的留存对象的扫描机制，有时会出现老模块的资源无法释放的问题，比如setInterval中引用的模块之类的……╮(￣▽￣)╭。总之，生产环境就别想了，但是用来开发调试些经常修改的简单模块的话，会是个不错的选择，比如router之类的配置文件。 总结怎么说呢，既然是个另类的思路，所以应用场景远没有线程替换那种方法大的。如果是生产环境，依然是推荐使用使用重启或者 PM2 的 hot reload 功能来保证稳定性。另外，webpack也有热替换的功能，HMR嘛，其实这也可以算是一个思路，具体的可以参考这个系列的文章Backend Apps with Webpack 参考资料 Webpack 做 Node.js 代码热替换, 第一步 node-hotswap]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue源码阅读笔记(2)]]></title>
      <url>%2F2017%2F03%2F31%2Fvue-source-notes-2%2F</url>
      <content type="text"><![CDATA[啊，又到deadline了……话说因为之前一直在整理上一篇笔记，所以过了这么长时间一直都没怎么读新的，真是惭愧啊……那么这次就读两个简单的模块吧，把简单的解决了，后续再啃硬骨头。 解析单文件组件 sfc之前在说目录结构的时候说过，sfc模块是用来解析.vue文件的，sfc貌似就是single file component的意思……(￣.￣;) 整个模块只有一个文件，但是逻辑却不简单呢……另外在官方文档中对单文件组件的描述也只有短短一个章节，所以感觉这部分通过源码能更充分的了解细节呢，那么先看下代码逻辑： parser.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// ...// 用来匹配换行的正则表达式const splitRE = /\r?\n/g// 定义了一个判断标签是否是script、style、template标签的函数const isSpecialTag = makeMap('script,style,template', true)// 解析单个.vue文件的函数export function parseComponent ( // 这里特意没有去掉flow的语法，顺便记录下flow的用法 // 参数后面加（: 类型）表示参数的类型 content: string, // 参数后面加（?: 类型）表示可省略参数和类型， (= &#123;&#125;) 是es6语法，表示参数的默认值…… options?: Object = &#123;&#125; // （function(): 类型）表示函数的返回值类型， // 这里的SFCDescriptor是一个自定义类型，定义在flow/complier.js里面 // 感觉有点像结构体(struct)，另外flow还支持interface和class的定义 ): SFCDescriptor &#123; // 最后导出的sfc对象，分为template、script、style和自定义块四部分 // 其中style和自定义块允许多个，template和script只允许一个 const sfc: SFCDescriptor = &#123; template: null, script: null, styles: [], customBlocks: [] &#125; // 因为最后是使用compiler/parser/html-parser模块进行解析的，而html-parser模块会根据dom结构进行递归解析的， // 所以每个代码块都有自己的深度，这里的depth就是用来标记深度的，从后续的代码中可以看出，sfc/parser模块不会处理嵌套的块，只处理一层，这个变量被用来做锁了…… let depth = 0 // 当前处理的代码块 let currentBlock: ?(SFCBlock | SFCCustomBlock) = null // 稍微调整了下代码的顺序，这个parseHTML的调用本来是放到最后的，这样其实也不会报错吧~ // 这个调用也是整个parseComponent函数最核心的部分，使用compiler/parser/html-parser模块的能力来解析模板 // parseHTML函数接收一个options参数（第二个），里面可以设置匹配到标签开始和结束时的钩子，通过钩子来获取自己写想要的内容， // 就是说，比如有个&lt;tag&gt;xxx&lt;/tag&gt;这样的内容，匹配到&lt;tag&gt;时，执行start，匹配到&lt;/tag&gt;时，执行end， // 如果匹配到&lt;tab/&gt;，就只执行start，貌似是这样吧，我只粗略的看了下parseHTML，后续详细看发现错了再纠正。 // 其实直接运行parseHTML不加options也是可以的，只不过不会返回任何的内容，是完全无意义的操作呢……╮(￣▽￣)╭ parseHTML(content, &#123; start, end &#125;) // 匹配到标签开始时的钩子，主要是对标签的属性进行处理 function start ( tag: string, attrs: Array&lt;Attribute&gt;, unary: boolean, start: number, end: number ) &#123; // 根据当前解析深度进行判断 if (depth === 0) &#123; // 如果当前深度是0，也就是说不是嵌套的标签，则进行处理 // 先缓存当前块的信息 currentBlock = &#123; type: tag, content: '', // 这里的start是用来标记标签内的内容的起点的 start: end, // 设置属性列表这个地方有意思，通过函数定义的flow里面可以看到arrts是个数组，这里通过数组的reduce特性直接把一个[&#123;"key","value"&#125;...]形式的数组转换为&#123;"key":"value"...&#125;形式的对象了 attrs: attrs.reduce((cumulated, &#123; name, value &#125;) =&gt; &#123; cumulated[name] = value || true return cumulated &#125;, Object.create(null)) &#125; // 判断是否是特殊标签 if (isSpecialTag(tag)) &#123; // 是特殊标签，则检查标签属性，并对特殊属性进行处理 checkAttrs(currentBlock, attrs) // 检查是否是style标签 if (tag === 'style') &#123; // 是style标签就推进队列 sfc.styles.push(currentBlock) &#125; else &#123; // 不是就直接赋值 sfc[tag] = currentBlock &#125; &#125; else &#123; // 不是特殊标签，则推进自定义标签的队列 sfc.customBlocks.push(currentBlock) &#125; &#125; // 这个属性是根据parseHTML接收的options.isUnaryTag返回的，因为在调用parseHTML时没传，所以unary总是false if (!unary) &#123; // 上锁 depth++ &#125; &#125; // 检查标签的特殊属性，以便做特殊的处理，特殊属性的使用方法貌似文档中都没有写呢， // 貌似这些属性都是给style标签用的，我是从https://github.com/vuejs-templates/webpack 这个项目中看到的相关例子 function checkAttrs (block: SFCBlock, attrs: Array&lt;Attribute&gt;) &#123; for (let i = 0; i &lt; attrs.length; i++) &#123; const attr = attrs[i] // 可以用lang标签设置style标签内用的预处理语法，less，sass之类的 if (attr.name === 'lang') &#123; block.lang = attr.value &#125; // 如果设置了scoped属性，那么这个标签就只对当前组件有作用 if (attr.name === 'scoped') &#123; block.scoped = true &#125; // 没找到这个属性是干嘛使的……╮(￣▽￣)╭有可能是为了配合src来用的，module作为src的前缀， // 具体参考 https://github.com/vuejs-templates/webpack/blob/17351f5e3b1306a117aaa80b7d575b9aa3144866/docs/static.md#asset-resolving-rules URLs prefixed with 这一小节的说明。 if (attr.name === 'module') &#123; block.module = attr.value || true &#125; // 用src属性设置内容对应的文件 if (attr.name === 'src') &#123; block.src = attr.value &#125; &#125; &#125; // 匹配到标签结束时调用的钩子，主要是对标签里的内容进行处理 function end (tag: string, start: number, end: number) &#123; // 检查锁的状态，并且标签不是不对称标签(不是&lt;tag/&gt;这样的) if (depth === 1 &amp;&amp; currentBlock) &#123; // end标记的是标签内的内容结束的位置 currentBlock.end = start // 去除标签内的缩进，deindent是尤大大专门为了去除缩进开发的模块…… let text = deindent(content.slice(currentBlock.start, currentBlock.end)) // 判断是不是template标签，不是统一都要加pad，目的是在lint报错时，报错信息行数能对应上…… if (currentBlock.type !== 'template' &amp;&amp; options.pad) &#123; text = padContent(currentBlock) + ext &#125; // 给content属性赋值 currentBlock.content = text // 至空currentBlock的引用，currentBlock其实已经保存在sfc的属性的引用上了，currentBlock其实只是个临时变量，这里充分的运用了js对象都是引用类型的特性呢…… currentBlock = null &#125; // 解锁 depth-- &#125; // 用来生成能跟.vue文件行数对应上的内容用的……用来对应lint软件或者预编译软件的报错信息的行数…… // 话说做框架可真不容易呢，不止要实现功能，连报错信息能不能对应上都要考虑…… function padContent (block: SFCBlock | SFCCustomBlock) &#123; // 获取当前这段代码到底在多少行 const offset = content.slice(0, block.start).split(splitRE).length // 根据不同的块使用不同的换行…… const padChar = block.type === 'script' &amp;&amp; !block.lang ? '//\n' : '\n' // 最后返回对应行数的换行 return Array(offset).join(padChar) &#125; // 最后返回实例 return sfc&#125; 总结怎么说呢，虽然sfc这个模块很短，但是详细分析起来还是挺费时间的……连读带写花了我4个小时啊……总的来说作用就是将文本解析成对象，话说如果要是自己也准备写dom类文件解析的，可以参考这部分的功能呢。看完这部分我觉得比较有趣的点有： flow真是好用啊，特别是看函数的时候，有了参数类型和返回类型的标注，一下就能理解用途了，连文档都省了，这么看来typescript也没那么那接受了的说……有机会一定要在项目中实践一下 使用reduce把数组转成对象。这个还真是开眼了以前没见过这种方法呢，以后可以借鉴到自己开发中 解析dom文本的方法，话说如果自己也要写解析dom操作的话（比如要写爬虫或者写要读xml、svg之类的？），可以借鉴这部分的代码呢，因为用了钩子的形式来扩展自定义操作，所以扩展性还挺强的 为了对应lint报错而使用pad这种方法……怎么说呢，为了良好的开发体验作者还挺下功夫的呢，如果以后自己也要开发框架，借鉴这类细节肯定会给自己的作品大大加分的~ 以上就是我的感悟，那么你的感悟又是什么呢？有想法就留言告诉我吧，欢迎各路灌水拍砖~(￣▽￣) 好的那么由于时间不足本次的博客就到这里，话说我发觉笔记这种东西就得每天读每天写效果才更好，所以我觉得要不要就改成日更算了~所以如果不出意外的话，大概可能maybe也许明天就会更新了呢~！能不能准时更新，就全看米娜桑点赞打赏转发安利发评论的热情啦~！ 白了个白~！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue源码阅读笔记(1)]]></title>
      <url>%2F2017%2F03%2F17%2Fvue-source-notes-1%2F</url>
      <content type="text"><![CDATA[其实我早就开始读vue的源码了，那会儿还是1.x版本，但是因为懒没有坚持下来，现在都已经更新到2.x了……总之坚持读完吧。vue的源码还是比较好读的，因为注释清楚又有中文文档对照，所以作为读源码练手的对象非常合适。这次我读的2.20的release版本，我阅读的习惯是，不只看大概流程，会把每个函数都看一遍，学习借鉴细节。之后的笔记也会以这个思路来写，希望能给自己和看的人带来帮助吧。 版本分支：mastercommit id：2a19f911dc8631d44b7c7e63c4db57ef28ac5e69版本：2.20 release 目录结构简单写下vue的目录结构，标注下他们都是干嘛用的。 1234567891011121314151617181920/*||-- + benchmarks 基准测试，用来测性能的|-- + build 构建脚本主要都放这里|-- + dist 构建后的web端版本的输出目录|-- + examples 各种vue使用的例子|-- + flow flow的规则文件，flow是facebook出的一套检验js变量类型的框架|-- + packages 构建后server side render和weex版本的输出目录|-- + src 构建前的源码|-- + test 各种测试用例|-- + types 类型检查测试的部分，用typescript写的|-- .babelrc 转es5的配置，vue用的不是babel用的bubble|-- .eslintrc eslint的配置|-- .eslintignore eslint忽略的文件夹|-- .flowconfig flowtype的配置文件|-- BACKERS.md 捐款列表，二百五那栏还没人捐，想排前排的土豪赶紧行动吧|-- circle.yml CircleCI集成测试平台的配置文件|-- package.json 所有工作流的命令都定义在scripts里面|-- yarn.lock yarn生成的依赖文件，估计开发过程中用的yarn替换了npm*/ 虽然这感觉很多余，但是对于小白来说应该很重要吧，我刚看的时候为了搞明白flow和benchmarks是个啥多少浪费了写时间…… 打包构建vue是用npm的scripts来定义工作流命令的，貌似用这种方式取代grunt、gulp已经越来越流行了呢……构建命令大体分为四类，dev、build、test、release，下面列出了所有的命令，并注释了是做啥的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123;//... "scripts": &#123; /*------ develop ------*/ "dev": "TARGET=web-full-dev rollup -w -c build/config.js", "dev:cjs": "TARGET=web-runtime-cjs rollup -w -c build/config.js", "dev:ssr": "TARGET=web-server-renderer rollup -w -c build/config.js", "dev:compiler": "TARGET=web-compiler rollup -w -c build/config.js", "dev:weex": "TARGET=weex-framework rollup -w -c build/config.js", "dev:weex:compiler": "TARGET=weex-compiler rollup -w -c build/config.js", /*------ build ------*/ "build": "node build/build.js", "build:ssr": "npm run build -- vue.runtime.common.js,vue-server-renderer", "build:weex": "npm run build -- weex-vue-framework,weex-template-compiler", /*------ test ------*/ "dev:test": "karma start build/karma.dev.config.js", "test": "npm run lint &amp;&amp; flow check &amp;&amp; npm run test:types &amp;&amp; npm run test:cover &amp;&amp; npm run test:e2e -- --env phantomjs &amp;&amp; npm run test:ssr", "test:unit": "karma start build/karma.unit.config.js", // 单元测试 "test:cover": "karma start build/karma.cover.config.js", // 覆盖率测试 "test:e2e": "npm run build -- vue.min.js &amp;&amp; node test/e2e/runner.js", // e2e(end to end，就是所谓的“用户真实场景”)测试 "test:weex": "npm run build:weex &amp;&amp; jasmine JASMINE_CONFIG_PATH=test/weex/jasmine.json", // weex 的单元测试 "test:ssr": "npm run build:ssr &amp;&amp; jasmine JASMINE_CONFIG_PATH=test/ssr/jasmine.json", // sever side render 的单元测试 "test:sauce": "npm run sauce -- 0 &amp;&amp; npm run sauce -- 1 &amp;&amp; npm run sauce -- 2", "test:types": "tsc -p ./types/test/tsconfig.json", // 类型校验 "lint": "eslint src build test", // 规范校验 "flow": "flow check", // 类型校验 "sauce": "SAUCE=true karma start build/karma.sauce.config.js", // 兼容性测试 "bench:ssr": "npm run build:ssr &amp;&amp; NODE_ENV=production node benchmarks/ssr/renderToString.js &amp;&amp; NODE_ENV=production VUE_ENV=server node benchmarks/ssr/renderToStream.js", // 基准测试，用来测性能的 /*------ release ------*/ "release": "bash build/release.sh", "release:weex": "bash build/release-weex.sh", "install:hooks": "ln -fs ../../build/git-hooks/pre-commit .git/hooks/pre-commit" &#125;//...&#125; dev系列命令是开发框架的时候用的。看完所有命令之后知道了以下这些信息： dev系列命令都是 TARGET=XXX rollup -w -c build/config.js 的形式。可以看出vue打包用的是rollup -w 是watch，-c 是指定config文件，build/config.js是rollup的配置文件。build/config.js 内部根据 TARGET 参数获取不同的构建配置。 话说使用自己的项目也是使用rollup打包的话，build/config.js 可以作为很好的参考或者模板呢。 使用的rollup插件： rollup-plugin-flow-no-whitespace插件用来去掉flow使用的类型检查代码。有趣的是，插件是还是作者自己写的，只是为了想去掉打包后遗留的空格……还真是洁癖呢，噗噗…… rollup-plugin-buble替代babel，用来转换es5用的。 rollup-plugin-alias用来配置打包过程中各个模块的路径映射，具体的配置写在 build/alias.js 中。这样代码中就可以用src作为根目录引用模块了。值得注意的是，src/platforms 目录下的 web 模块和 weex 模块，也都做了映射，所以在看代码时有 import xxx from ‘web/xxx’的引用，就都是从 platforms 下引用的。貌似这是缩短引用路径、区分目录结构和代码逻辑的好方法呢，实际开发中也可以借鉴。 简单查了一些rollup的资料，rollup的特性包括： 打包后的代码没有 require，import的，而是直接插入到文件中 可以生成 AMD，CMD，UMD 甚至 ES6 模块文件 tree-shaking，会移除未使用到的 ES6 exports模块，打包后的文件体积更小 配置简单 没有自带的模块机制，使用es6原生的模块依赖机制 虽然webpack2也支持tree-shaking，但是从rollup的配置简单、功能单一、打包文件没有多余代码这些特点俩看，感觉很适合用来打包独立库或者框架这种都是js并且结构相对简单的项目呢。 相比之前，现在的dev纯粹是按照不同参数做打包并且watch了，我记得1.x版本还带webpack-dev的调试服务器来着，现在的这套比之前的轻了很多，估计打包速度也会快不少，这点和vue本身的理念也有相符吧？ build系列命令用来打包所有配置。总结下看到的知识： build系列命令都是运行 build/build.js 这个文件。这个文件中的逻辑就是通过 build/config.js 获取所有的配置，然后串行用rollup打包。 后面的参数可以用来过滤要打包的配置，获取参数和过滤的逻辑也是写在 build/config.js 里面的。 如果想编写串行执行任务和获取参数做过滤一类的工作流脚本，又不想借助grunt、gulp之类的任务管理库，build/build.js 里部分的这两部分代码可以作为很好的参考。 test系列命令是用来搞自动化测试的，具体的分析： 测试这部分包含的内容很多，现在只是粗略的看了看。先读源码，后续再详细解读这部分的内容 大部分命令是做啥的我都标出来是干嘛的了，其他命令只是对其他命令的一个封装，话说包含的测试还真是全呢…… 其实这些命令也都不是让你自己执行的，这些都是用来搞自动化测试的，自动自动化测试的命令配置在 build/ci.sh 这个脚本文件里面。这个脚本会在CircleCI的hook中被调用。话说想搞持续集成的可以参考这个配置呢。 同时使用了facebook的flow和typescript做类型检查，在类型检查这方面真是费了牛劲了…… release系列命令是用来发布rlease版本的： 调用了build文件下对应的sh文件，对于windows用户还真是不友好呢哈哈哈 脚本里主要做了设置版本、自动化测试、构建、打tag、提交、npm推送这几件事 还提别为weex做了独立的发布脚本，看来还真是深度合作呢 其实如果团队都是用mac或者linux，或者都用开发机，可以用这套脚本作为工作流中的一个环节，自动发布提交。那句话怎么说的来着，“重复七次以上的工作都应该自动化”？大概吧…… 源码 src接下来看具体源码，所有的源码都在src目录下，先看下src目录下文件的结构： 12345678910/*||-- + compiler 解析模板用的？|-- + core vue的核心，|-- + entries 各种入口的封装|-- + platforms 不同平台下自己独特的模块|-- + server server side render的|-- + sfc 用来将.vue文件转坏为sfc(可识别组件)对象的|-- + shared 共享的模块，一个工具集*/ 刚才说到的 build/config.js 文件，里面标记了所有的打包配置，从打包配置中可以看出，所有的入口都在 src/entries 文件夹中，我阅读源码的习惯是从入口开始读。 入口 src/entriessrc/entries 的目录结构如下： 12345678910/*||-- web-compiler.js 只包含vue的模板解析器和.vue解析器|-- web-runtime.js 只包含vue的运行时部分的代码|-- web-runtime-with-compiler.js 这个模块既包含解析器又包含运行时|-- web-server-renderer.js server side render 用的模块，和客户端的不一样，不分解析器和运行时|-- weex-compiler.js weex的解析器|-- weex-factory.js weex的运行时|-- weex-framework.js 这个貌似是weex的框架？因为不了解weex，所以只能靠猜的了*/ 具体每个文件的用途已经在上面简单的标注出来了，主要包含web端，server端，客户端(weex)三部分，下面详细解读各个文件，因为对server端和客户端并不熟悉，所以这部分只能粗浅的猜猜了…… web-compiler.js这个文件比较简单，就是导出了解析sfc模块和compiler模块的接口。compiler模块的作用是用来解析模板的，对应的是 src/compiler 模块，粗略的看了下是使用new Function将字符串转换为js代码，所以对于不支持或者认为这样不安全的环境，vue会给出错误提示。具体的源码后续再继续详细读。 web-runtime.js感觉web-runtime是对core的vue模块做了再加工 大概逻辑如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//...// 添加不同平台下的功能函数，web平台下都有对应的的接口，weex平台下都是空函数// 各函数的具体用途看到了再解释吧Vue.config.mustUseProp = mustUsePropVue.config.isReservedTag = isReservedTagVue.config.getTagNamespace = getTagNamespaceVue.config.isUnknownElement = isUnknownElement// 添加不同平台下的组件和命令extend(Vue.options.directives, platformDirectives)extend(Vue.options.components, platformComponents)// 安装虚拟dom的补丁函数，貌似只有在客户端下才会用到，服务端是没有的，另外weex也有自己的补丁函数，所以这里知识安装浏览器的patch函数Vue.prototype.__patch__ = inBrowser ? patch : noop// 定义$mount函数，只是对核心的mountComponent方法进行了个简单的封装Vue.prototype.$mount = function (el, hydrating) &#123; // ... // core/instance/lifecycle模块下的mountComponent return mountComponent(this, el, hydrating)&#125;// 定义devtool的全局钩子(hook)// vue有自己的chrome插件调试工具，下面这段代码就是启动调试工具的setTimeout(() =&gt; &#123; // 判断是否配置了使用调试工具，其实就是看是不是生产版本…… if (config.devtools) &#123; // 判断是否安装了调试工具，是通过检查全局变量window.__VUE_DEVTOOLS_GLOBAL_HOOK__来判断的 if (devtools) &#123; // 如果有就触发调试工具的init事件，所以如果项目中使用了生产版本的vue或者没有使用vue，调试工具都不会启动的 devtools.emit('init', Vue) &#125; else if (process.env.NODE_ENV !== 'production' &amp;&amp; isChrome) &#123; // 如果没有安装调试工具，并且使用的不是生产版本的vue，用的还是chrome浏览器，就提示用户下载调试工具 console[console.info ? 'info' : 'log']( // ... ) &#125; &#125; // 如果不是生产版本，提示用户现在使用的是开发版本，正式部署的时候用生产版本 // config中的productionTip和devtools其实都是process.env.NODE_ENV，貌似在开发过程中应该可以配置的说 if (process.env.NODE_ENV !== 'production' &amp;&amp; config.productionTip !== false &amp;&amp; inBrowser &amp;&amp; typeof console !== 'undefined') &#123; console[console.info ? 'info' : 'log']( // ... ) &#125;&#125;, 0)// 最后导出Vue模块export default Vue web-runtime-with-compiler.js这个文件最为一个入口，将已经整合好的compiler和runtime再一次整合封装，最终导出浏览器用的vue构造函数。 代码的大概逻辑如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// ...// 定义一个纯函数，之前我在mobx的文章中写过，纯函数的输入、输出都是固定的，所以可以用来做缓存// cached函数虽然表面上看引用自core/util/index，实际是core/util/index引用了shared/util，cached定义在shared/util中// 利用纯函数做缓存的技巧可以应用在自己的项目中，虽然定义个对象也能搞定，但是这么封装真的是很美观呀~const idToTemplate = cached(id =&gt; &#123; const el = query(id) return el &amp;&amp; el.innerHTML&#125;)// 定义了一个工具函数，看名字就知道是获取元素outerHTML的// 之所以这么处理貌似是因为IE在取svg元素的outerHTML时有bugfunction getOuterHTML (el) &#123; // 判断元素是否有outerHTML属性 if (el.outerHTML) &#123; // 有就直接使outerHTML return el.outerHTML &#125; else &#123; // 没有就建个空div把要获取的元素赋值进去，然后取innerHTML const container = document.createElement('div') container.appendChild(el.cloneNode(true)) return container.innerHTML &#125;&#125;// $mount方法是用来挂载实例的// 这里定义的$mount是对之前在web-runtime.js里定义的$mount进行封装// 先做个临时变量保存原来的$mountconst mount = Vue.prototype.$mount// 然后定义新的Vue.prototype.$mount = function (el, hydrating) &#123; // ... // 判断el是否body或者html if (el === document.body || el === document.documentElement) &#123; // ... // 如果是就中断，也就是说vue是无法在dom的根节点上挂载的 return this &#125; // $options当前 Vue 实例的初始化选项 const options = this.$options // 判断$options是否有render函数 if (!options.render) &#123; // 没有就造个render函数出来 // ... // 判断$options是否有template属性 if (template) &#123; // 如果有template属性 // 判断template属性是否是字符串 if (typeof template === 'string') &#123; // 如果template是字符串，则把他当做selector使用 // 判断selector是否是唯一的(是不是id) if (template.charAt(0) === '#') &#123; // 如果selector是唯一的，则使用selector的innerHTML作为模板 // 并且缓存模板内容 template = idToTemplate(template) // ... &#125; // 判断template属性是否是dom节点 &#125; else if (template.nodeType) &#123; // 如果是dom节点则用innerHTML作为template template = template.innerHTML &#125; else &#123; // ... // 如果template不符合要求，则中断程序 return this &#125; &#125; else if (el) &#123; // 如果没有template属性 // 则取挂载dom节点的outerHTML作为template template = getOuterHTML(el) &#125; // 如果经过之前的过程获取到了template // 则根据获取到的template生成render函数 if (template) &#123; // ... // 根据template生成render // 另外在开发版本中，还会利用window.performance统计生成render的时间，分析性能，因为这部分代码不是主要代码，所以我就删掉了 const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; // 用来标记是否需要转换换行符的，为了兼容IE的，貌似IE和其他浏览器在处理换行符时的操作不一样啊 shouldDecodeNewlines: shouldDecodeNewlines, // 对应 https://cn.vuejs.org/v2/api/#delimiters ，纯文本插入分隔符，可在构建时修改 delimiters: options.delimiters &#125;, this) options.render = render options.staticRenderFns = staticRenderFns // ... &#125; &#125; // 调用 web-runtime.js 中定义的$mount return mount.call(this, el, hydrating)&#125;// 将解析compile模块也绑定到Vue上Vue.compile = compileToFunctions// 导出Vue类export default Vue web-server-renderer.js这个是server side render的入口，所以与brower端用到的方法差别很大。server端只是做初步的渲染，所以只有一个生成render的函数，结构比较简单。 123456789// ...// 定义一个生成render对象的函数export function createRenderer (options) &#123; return _createRenderer(&#123; // ... &#125;)&#125;// 定义一个生成render函数的工厂export const createBundleRenderer = createBundleRendererCreator(createRenderer) 这部分的功能划分的很细，做了好多的高阶函数，粗略的看了下看的段点儿晕，后续看到不同平台的代码时再详细看。 weex-compiler.js对应web-compiler.js，导出对应平台下的compiler模块 weex-factory.js对应web-runtime.js，只不过这里没有添加独特的函数，直接导出的对应平台下的runtime模块 weex-framework.js导出了weex/framework这个模块下的所有方法，貌似是给weex提供基础支持用的？具体的还没开始仔细看。 总结总的来说这次记录了整个项目的入口部分的代码。通过这些入口，可以了解所有主要的模块的用途，项目的结构等等基础信息。当然，也能学习借鉴不少知识，我觉得以下这些点值得记录并应用到自己的项目中： npm script的定义规则和分类 flow和typescript做类型检查的方法 打包测试发布整套的工作流定义 通过封装重写的方式不断扩展接口 通过纯函数的特性做缓存 通过高阶函数拆分模块(具体模块的划分思想我还没看出来……) 那么你又从这部分代码中悟到了什么呢？有想法就留言告诉我吧，咱们一起交流交流~(￣▽￣) 好的那么由于时间不足本次的博客就到这里，话说这次时间实在是太仓促了，而且解读源码的表达方法我也还没有探索好……我的感觉就是，虽然我都看懂了，但是却说不明白，下次会尝试着配上些流程图或者思维导图来记录，这样也更容易理解吧。 那么如果不出意外的话，大概可能maybe也许下周五会更新吧~！这次就不别安利了，毕竟我自己都觉得好坑啊……就这样了…… 白了个白~！ update 2017-03-30折腾了两个礼拜，终于想到一个自己比较满意的方式来做记录，把之前的文章大修了一遍，自我感觉还是不错，希望以后自己再看的时候不会觉得尴尬吧，哈哈哈…… 另外我还发现了一个gitbook，也在读vue的源码，不过他在几个月之前断更了……但是这种形式真心不错，后续我也打算用这种形式再整理一遍的说~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[fetch 能做哪些 XHR(XMLHttpRequest) 不能做的事]]></title>
      <url>%2F2017%2F03%2F10%2Fdifference-between-fetch-and-XHR%2F</url>
      <content type="text"><![CDATA[前两天刷微博的时候刷到了紫云飞的一条微博，遂决定好好整理下，方便以后面试别人或者别人面我的时候装逼用~ ╮(￣▽￣)╭ 基础知识关于 Fetch API 和 XHR 的历史、概念、方法、属性等基础知识我就不回顾了，毕竟网上一搜一大片，文档也早就有了中文翻译，想详细了解细节的就仔细读文档吧。 Fetch API的标准 MDN的Fetch API中文文档 XHR的标准 MDN的XHR中文文档 直奔主题总的来说，Fetch API 和 XHR 做的事情很相似，大部分情况我们通过 XHR 就已经能够完成开发任务了。那么为什么还需要新的 Fetch API呢？个人认为 相比 XHR， Fetch API 可以做到以下三点： Fetch API更加现代XHR 和 Fetch API 最显著的区别就是调用方式不同。这一点大家应该都知道吧。 举个例子，下面两端代码完成的是同一功能： 1234567891011121314151617181920212223// 用 XHR 发起一个GET请求var xhr = new XHMHttpRequest();xhr.open('GET', url);xhr.responseType = 'json';xhr.onload = function() &#123; console.log(xhr.response);&#125;;xhr.onerror = function() &#123; console.log('something wrong~ ╮(￣▽￣)╭');&#125;;xhr.send();// 用 Fetch 完成同样的请求fetch(url).then(function(response) &#123; return response.json();&#125;).then(function(jsonData) &#123; console.log(jsonData);&#125;).catch(function() &#123; console.log('something wrong~ ╮(￣▽￣)╭');&#125;); 相比 XHR ，Fetch 结合了现代的编码模式，使用起来更简洁 ，完成工作所需的实际代码量也更少。 Fetch API更底层其实，刚才说到的 Fetch API 并不是指仅仅一个 fetch 方法，还包括 Request、 Response、Headers、Body都一系列原生对象。对于传统的XHR而言，你必须使用它的一个实例来发出请求和处理响应。 但是通过Fetch API，我们还能够通过刚才提到的原生对象，明确的配置请求和响应。这些底层的抽象让 Fetch API 比 XHR 更灵活。 举个例子，现在要下载一个很大的 utf-8 格式的 txt 文件，我们通过流式的响应体而不是文本的形式读取，最后显示在一个div中。(为什么使用流、使用流有什么好处我就不做过多解释了……) 1234567891011121314151617181920212223242526272829303132333435363738394041424344document.addEventListener('DOMContentLoaded', function (e) &#123; var url = 'Test.txt'; var div = document.getElementById('content'); var progress = 0; var contentLength = 0; fetch(url).then(function(response) &#123; // 通过响应头获取文件大小 contentLength = response.headers.get('Content-Length'); var pump = function(reader) &#123; return reader.read().then(function(result) &#123; // 如果流中的内容读取完毕，result.done的值会变为true if (!result.done) &#123; // 获取流中的数据 var chunk = result.value; var text = ''; // 流中的数据是一串字节码，需要做转码 for (var i = 3; i &lt; chunk.byteLength; i++) &#123; text += String.fromCharCode(chunk[i]); &#125; // 添加到页面的div中 div.innerHTML += text; // 还可以用流的长度显示当前进度 progress += chunk.byteLength; console.log(((progress / contentLength) * 100) + '%'); // 开始读取下一个流 return pump(reader); &#125; &#125;); &#125; // 开始读取流中的信息 return pump(response.body.getReader()); &#125;) .catch(function(error) &#123; console.log(error); &#125;);&#125;); 在上面的例子中，我们不止使用了流来下载文件，还通过响应头获取了响应的具体信息，显示了下载的进度。虽然使用XHR也能做到使用流来读取文件，不过现在应该只有IE浏览器支持。但是 Fetch API 提供了访问数据的实际字节的方法，而 XHR 的 responseText 只有文本形式，这意味着在某些场景下它的作用可能非常有限。 Fetch API更接近未来当我们在谈论 Fetch API 时，我们在谈论的不止是这些已经胜过 XHR 的地方，更是在谈论 Fetch API未来的可能性。比如未来基于 Fetch 和 Service Worker 的缓存和请求拦截技术。由于时间关系细节就不展开了，详细的内容可以参考一下链接。 使用 Service Workers Service Worker初体验 最后虽然现在很多Fetch API 的功能还是实验性的，但是虽然现代浏览器的普及，以及诸如promise、async/await等异步语法的实现，相信不久的将来，Fetch 肯定会取代 XHR吧。到时候希望这篇文章能帮助你装逼成功，哈哈~ ╮(￣▽￣)╭ 好的那么由于时间不足本次的博客就到这里，如果不出意外的话，大概可能maybe也许下周五会更新吧~！能不能准时更新，就全看米娜桑点赞打赏转发安利发评论的热情啦~！ 白了个白~！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用rem实现响应式布局的方法]]></title>
      <url>%2F2017%2F03%2F03%2Fa-method-of-using-rem%2F</url>
      <content type="text"><![CDATA[起因前两天小徒弟问我，老看到有人说用rem实现响应式布局，具体要怎么做呢？这可问住我了，之前我只知道rem的概念却不知道要怎么用rem来实现响应式布局……赶紧忽悠她一顿，让她先去各大网站上学习下别人是怎么做的，看不懂了再来问我。自己则私底下恶补了rem实现响应式布局的知识来应付她的问题，这才算糊弄过去…… 话说，临阵磨不能白磨了不是，总结下当时搜索到的资料供大家参考，以后真被问起来嘡嘡嘡一说，就准备接受萌新崇拜的目光吧，哈哈(￣▽￣) 概念在说rem之前不得不先介绍下em，em这种单位最早源自印刷界，一个em表示一种特殊字体的大写字母M的高度。后来到了网页上，em作为一种相对长度单位，相对于当前对象内文本的字体大小。没有被css设置过的网页，一般页面字体的默认大小是16px，所以1em就等于16px。当然em除了可以作为font-size属性值得单位，还能作为width和height属性值的单位。于是前端工程师们就脑洞大开了，如果所有的宽高单位都用em，那么在做响应式布局的时候，只要改变页面上的字体大小不就能直接调整页面各个部分的大小了吗？ 但是事与愿违，em是针对当前对象内文本的，就是说针对的是被设置过字体大小的元素的字体大小。有点绕是不是？举个例子好了，比如现在又这样一个结构，body&gt;div.A&gt;div.B，body的font-size是20px，div.B的width和height都是1em，所以当前页面上div.B的宽高就是20px，这时候如果div.A被设置了font-size为10px，div.B的宽高就是10px了，这个特性让em非常不好被应用，要用em就整个页面所有的font-size都要用em，这在没有node做自动化工具的年代简直是异常噩梦……你想写个页面，还得不停的换算px和em，想想就头疼…… 后来rem出现了，其实rem就是root em，故名思意，rem单位就是相对于根节点（html元素）字体大小的单位。这个单位跟em不一样的区别也在这里，他是不受继承影响的，这样就可以各种单位混用，回避了不停换算的问题。当然要想使用换算的过程还是不能少，不过只是根据根节点的字体大小换算，列个换算表需要的时候查表就好了，当然这个问题在有了前端打包工具之后就彻底解决了，咱们后面再具体说。 方案理解了rem的概念，揭下来说说利用rem实现响应式布局的方案。一般响应式布局分两种： 方案一使用rem定义想要响应式的部分的宽高，使用媒体查询来修改html元素的font-size属性 简单举个例子：1234567891011121314151617html &#123; font-size:16px;&#125;@media screen and (max-width: 480px) &#123; html &#123; font-size:14px; &#125;&#125;@media screen and (max-width: 960px) &#123; html &#123; font-size:15px; &#125;&#125;.some-class &#123; width: 10rem; height: 10rem;&#125; 方案二使用rem定义想要响应式的部分的宽高，在页面resize时动态的改变html的font-size属性。 这个方案也是我觉得比较有趣的一个方案，他可以保证窗口大小在变化时，真个页面也等比例缩放。目前淘宝和饿了么使用的就是这个方案。 本来还想抄一段淘宝计算html元素font-size大小的代码，后来一搜发下阿里无线团队已经把脚本开源了，附上地址好了：lib-flexible 问题除了以上两种方案，其他把root的font-size设死，又使用rem做单位的方案我就真不能理解了……貌似没什么意义吧？希望能白话的同学给我套靠谱的解释，这样以后别人喷我的时候我也好一嘟噜一串儿的喷回去……(￣▽￣)” 自动化刚才提到了，在使用rem的时候不得不对rem和px做转换。我个人是信奉“一切重复工作都应该交给电脑去做”这一理念的，所以我觉得转换的工作也应该交给电脑去做才对。其实前人早的轮子也已经很多了，这件事less、sass、postcss、stylus等预处理器都支持，也可以用px2rem这个npm模块，使用webpack的也有对应的loader可用px2rem-loader 。所以根本不用操心重复劳动的事，某种意义上来说，只要你够勤快，就根本累不着~ 总结在查资料的过程中，也发现有人在说，字体大小自适应是一种错误的想法，因为就算是响应式布局，其实也没必要做到这一步……使用媒体查询、calc、vw单位、flex一样能够完成一个体验优秀的页面。在这件事上，我觉得还是仁者见仁吧，虽然rem实现响应式布局的感觉都有些hack，但是肯定还是有他存在的意义的，屠龙之技学会了，砍谁不是砍不是？何况有的时候，咱们程序员说了真不算，到底要不要做到完全等比例缩放这一步，还是得听产品经理的……毕竟产品小白分分钟就能让技术大牛加班啊~哈哈哈ｂ（￣▽￣）ｄ]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聊聊动态规划(2) -- 特征]]></title>
      <url>%2F2017%2F02%2F24%2Fdynamic-programming-2%2F</url>
      <content type="text"><![CDATA[书接前文，上回咱们说到要如何鉴别动态规划可解问题。我预告说要从计算机工作原理开始讲起……呃……貌似跟原本要讲的东西差的有点儿远呢……那么为啥非要从这么底层的问题开始讲起呢？怎么说呢……就好比我要讲西游记，如果只说一句“唐僧师徒四人去西天取经然后都修成正果了”，对于没看过西游记的人来说，唐僧是谁、师徒四人又是谁、为啥非得跑西天去取经等等一系列问题，不去翻翻原著搜搜资料是肯定不知道怎么回事的。所以还是尽量揉碎了讲吧，不然看完了还得一通翻查资料，怪麻烦的…… 尽管计算机技术自20世纪40年代第一部电子通用计算机诞生以来一直飞速的发展，但是，现代计算机仍然采用冯诺依曼结构来实现。冯诺依曼结构将计算机描述为五部分：输入设备、控制器、运算器、存储器和输出设备。工作流程大概就是，输入设备传入数据，控制器发出指令，运算器根据指令做算数逻辑运算，最后存储或者输出结果。如果咱们只关注计算机的理论原理，在抽象一点的看计算机工作的整个过程，你会发现，刚才我们描述的工作过程可以用数学理论来概括。存储器可以看做一个列举了计算机存在的所有可能状态的集合，控制器指令可以看做一组状态转换函数，运算器使用状态转换函数，从输入的状态和集合的状态，推导出输出的状态。所以计算机的工作原理，可以简单的概括为，利用当前的状态计算出下一个状态（美错儿，我就是在说状态机……）。 我们平时编写程序，是在使用计算机帮我们解决问题。从计算机的本质是状态机这个角度来看，你思考如何编写程序来解决问题，其实就是在思考如何将这个问题表达成状态（用哪些变量，存储哪些数据）以及如何在状态之间中转换（怎样根据一些变量计算出另一些变量）。我们在看算法分析文章时，经常能看到的平时能看到的所谓空间复杂度，就是为了支持你的转换状态所必需存储的状态最多有多少；所谓时间复杂度，就是从初始状态到达最终状态中间需要做多少次状态转换。 还拿我们上一次说的斐波拉契数列做🌰 ： 我要计算第100项，之前的每一项就是这个问题的一个状态。每求新一项（新的一个状态）只需要之前的两个项（之前的两个状态）。所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；每求一个新状态，所需要的时间是常数，而之前的状态是线性递增的，所以时间复杂度就是线性的。 上面这种状态计算很直接，只需要依照固定的模式从旧状态计算出新状态就行（a[i]=a[i-1]+a[i-2]），不需要考虑是不是需要更多的状态，也不需要选择哪些旧状态来计算新状态。对于这样的解法，我们叫递推。 斐波拉契数列这个例子过于简单，以至于让人忽视了阶段的概念。所谓阶段是指随着问题的解决，在同一个时刻可能会得到的不同状态的集合。斐波拉契数列中，每一步会计算得到一个新数字，所以每个阶段只有一个状态。咱们来想象另外一个情景：假如把你放在一个围棋棋盘上的某一点，你每一步只能走一格，因为你可以东南西北随便走，所以你当你同样走四步可能会处于很多个不同的位置。从头开始走了几步就是第几个阶段，走了n步可能处于的位置称为一个状态，走了这n步所有可能到达的位置的集合就是这个阶段下所有可能的状态。 现在问题来了，有了阶段之后，计算新状态可能会遇到各种奇葩的情况，针对不同的情况，就需要不同的算法，下面就分情况来说明一下： 假如问题有n个阶段，每个阶段都有多个状态，不同阶段的状态数不必相同，一个阶段的一个状态可以得到下个阶段的所有状态中的几个。那我们要计算出最终阶段的状态数自然要经历之前每个阶段的某些状态。 好消息是，有时候我们并不需要真的计算所有状态。 比如拿这样一个的棋盘问题举例： 从棋盘的左上角到达右下角最短需要几步。答案很显然，用这样一个简单的问题是为了帮助我们理解阶段和状态。某个阶段确实可以有多个状态，正如这个问题中走n步可以走到很多位置一样。但是同样n步中，有哪些位置可以让我们在第n+1步中走的最远呢？没错，正是第n步中走的最远的位置。换成一句熟悉话叫做“下一步最优是从当前最优得到的”。所以为了计算最终的最优值，只需要存储每一步的最优值即可，解决符合这种性质的问题的算法就叫贪心算法。如果只看最优状态之间的计算过程是不是和斐波拉契数列的计算很像？所以计算的方法也是递推。 既然问题都是可以划分成阶段和状态的。这样一来我们一下子解决了一大类问题：一个阶段的最优可以由前一个阶段的最优得到。 如果一个阶段的最优无法用前一个阶段的最优得到呢？（需要前两个阶段得到当前最优，跟只用前一个阶段并没有本质区别） 最麻烦的情况在于你需要之前所有的情况才行。再举一个探索迷宫的🌰 ： 现在有一个迷宫，我们要计算从起点到终点的最短路线。这时你就不能只保存当前阶段的状态了，因为要求你计算最短路径，所以你必须知道之前走过的所有位置。因为即便你当前在的位置不变，之前的路线不同也会影响你之后走的路线。这时你需要保存的是之前每个阶段所经历的状态，根据之前所有的状态你才能计算出下一个状态！每个阶段的状态或许不多，但是每个状态都可以转移到下一阶段的多个状态，这种记录所有状态计算下一个状态的算法就叫搜索。所以搜索的空间复杂度就是指数级的，时间复杂度也是指数的。 刚才提到的那种令人不开心的情况，就叫做有后效性。 刚刚的情况实在太普遍，我们刚刚说到的解决方法也实在太暴力。那么，有没有哪些情况可以避免如此的暴力呢？契机就在于后效性。 有这么一类问题，看似需要之前所有的状态，其实不用。比如求最长上升子序列（LIS）长度问题： 在一个无序的数组里，找出一组尽可能长的由低到高排列的数，这组数就叫最长上升子序列。 比如，给出[5,4,1,2,3]，LIS 就是 [1,2,3]，长度是3；给出[4,2,4,5,3,7]，LIS 是 [2,4,5,7]，长度是 4。 看到这个问题，第一反应就是用遍历去解决。从头到尾依次枚举是否选择当前的数字，每选定一个数字就要去看看是不是满足“上升”的性质，这里第i个阶段就是去思考是否要选择第i个数，第i个阶段有两个状态，分别是选和不选。哈哈，依稀出现了刚刚搜索迷宫的影子！ 但是当我们仔细思考之后会发现，每次当我决定要选择当前数字的时候，只需要和之前选定的一个数字比较，就能做出判断了！这是和之前迷宫问题的本质不同。这样我们就不需要记录之前所有的状态了。因为最后要求的是序列长度，所以我们只需要记录以某个元素结尾的LIS长度就好。 这种“每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到”的性质就叫做最优子结构；而“不管状态之前是如何得到的”的性质就叫做无后效性。 那么，终于可以说出动态规划问题的两个特点了，这两个特点就是最优子结构和无后效性！只要有这两个特点的问题，就可以用动态规划的方法来解决了。 通过之前的一系列描述我们也能看到，一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间的状态转移方式决定的！ 每个阶段只有一个状态 —— 用递推。 每个阶段的最优状态都是由上一个阶段的最优状态得到 —— 用贪心。 每个阶段的最优状态是由之前所有阶段的状态的组合得到 —— 用搜索。 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的 —— 用动态规划。 另外需要注意的是，一个问题从不同的角度分析，各阶段状态的定义和状态转移方式可能都不相同，存在一个有后效性的定义，并不代表该问题不适用动态规划的方法来解。就像我最早说过的一样：寻找看问题的角度，才是动态规划的核心~ 好的那么由于时间不足本次的博客就到这里，如果不出意外的话，大概可能maybe也许下周五会更新吧~！能不能准时更新，就全看米娜桑点赞打赏转发安利发评论的热情啦~！ 白了个白~！ 相关资料 什么是动态规划？动态规划的意义是什？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聊聊动态规划(1) -- 概念]]></title>
      <url>%2F2017%2F02%2F17%2Fdynamic-programming-1%2F</url>
      <content type="text"><![CDATA[之前某天面试了个年轻的工程师，习惯性的问了几个简单的算法题，冒泡排序二分查找之类的。他没有答上来，解释道这些平时开发中根本不会用到，就算需要，各种开源框架也都封装的烂大街了，根本不用自己写。 听他这么说着，仿佛看到了几年前的自己。当时我也觉得不用了解算法知识，知道冒泡快排能应付面试就得了。前端面向的是界面及交互实现，除非你填游戏或者富文本的坑，不然哪儿用的上什么算法。真需要了，上网搜呗。Max Howell 连个翻转二叉树都不会，不也照样把 Homebrew 做出来了吗。 直到我听了一次之前的领导的分享。他在分享中介绍，面试中考察算法知识，并不是想看你背了多少题，而是想考察你解决复杂问题的能力。算法能力体现的不只是知识储备，还能体现一个人的聪明才智。 听完之后我茅厕顿开。我的理解是，所谓的算法，其实就是你解决问题的方法。所以就算你不知道最佳答案，用你知道的知识解决问题，也算是一种算法。比如你要去个地方，可以坐公交坐地铁，你都不知道怎么坐，走过去也算是一种算法。算法题也并不是跟实际开发没有关联。就好比 “水池能装100L水，进水管每分钟进水10L，出水管每分钟出水5L，多长时间水池能满？” 这种傻逼的问题，如果改成 “一个驴牌的包包1万，你一个月挣5000，花2000，多长时间能买的起？” 不就有了实际的意义了吗……话说我还真是喜欢打比方的(￣▽￣)…… 那么，怎么才算真正具备一定算法能力，入了算法的门儿了呢？显然只会个排序肯定是不行的……当然我并不是说排序算法就简单，各种排序算法优化啥的我觉得也挺难的……我个人觉得，在各种常见的算法中，动态规划应该算是一道坎儿，过去了就算入门儿了。winter大神也说过，写出动态规划，再谈算法。 那么动态规划到底是什么呢？ 动态规划(dynamic programming)是求解多阶段决策过程(multistep decision process)最优化的数学方法。 第一次听到这个定义的时候我脑子里只有 “说人话” 这三个字……ok，让我们来仔细掰吃掰吃。 仔细观察发现，这个定义可以拆分成以下两部分： 动态规划用来求解问题的最优化方案的 问题表现为多阶段决策过程 最优化方案比较好理解。所谓多阶段决策，是将决策问题的全过程恰当地划分为若干个相互联系的子过程（每个子过程为一个阶段），以便按照一定的次序去求解。也就是说，一个大的问题可以被划分为若干个相互联系的子问题。这种相互联系的子问题，又叫交叠子问题。举个例子来说明交叠子问题，以斐波拉契(Fibonacci)数列为例，计算第100项的时候，需要计算第99项和98项；在计算第101项的时候，需要第100项和第99项，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。上述的需要再次计算的“第99项”，就叫交叠子问题。 在理解了上面每个学术名词的概念以后，可以得出一个结论，所谓动态规划，就是对于某一类问题的解决方法……呃……可能会有人觉得这是废话，但其实我们正在一步步接近问题的核心。个人觉得，动态规划的重点就在于如何鉴定“某一类问题”是动态规划可解的，而不是纠结用什么解决方法。因为用什么解决方法，取决于你从什么角度观察问题，拆分子问题。寻找看问题的角度，才是动态规划的核心。 那么，如何鉴定动态规划可解的问题呢？这会是一个 long long story……所以，咱们下期再讲~~(￣▽￣)~~！！！ 好的那么由于时间不足本次的博客就到这里，简单预告一下，下期博客会从计算机是怎么工作的说起了…… 如果不出意外的话，大概可能maybe也许下周五会更新吧~！能不能准时更新，就全看米娜桑点赞打赏转发安利发评论的热情啦~！ 白了个白~！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[年终奖避税程序优化]]></title>
      <url>%2F2017%2F02%2F03%2Fjavascript-year-bonus-evade-tax-2%2F</url>
      <content type="text"><![CDATA[春节前写了个年终奖避税的程序。但是之前的实现上效率有点儿低，这次的博客就写一写如何优化这个程序好了（其实是快到deadline才想起来要写博客临时抓的题目……） 针对这个年终奖避税的程序，优化的主要方向是降低程序运行的速度。之前的实现，最耗时的是getOneMonthBonus和getTwoMonthBonus中的循环。这是在使用穷举搜索最低纳税点。针对穷举的优化，我了解的比较通用的优化方法，一种是增加缓存，一种是对穷举进行剪枝。 经过观察发现，拆分年终奖不可能把年终奖的50%以上拆到工资里，因为年终奖是用商数来确定交税比例的，确定比例所用的表相当于月薪减去起征点。这样我们就减少了一半的计算量。还有，我们还可以用一个对象来存储计算过的拆分方案，如果遇到相同的情况就直接使用对象里面的结果就可以了。 其实在编写其他程序的时候，这两种也是最简单有效的优化方法。概括的说，就是拿空间换时间和减少计算量…… ok，最后放上优化后的程序，这一期的瞎扯就这么愉快的结束了，咱们下期再见~！\（￣︶￣）/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151var baseQuota = 3500;var taxQuota = [1500, 4500, 9000, 35000, 55000, 80000];var taxRat = [0.03, 0.10, 0.20, 0.25, 0.30, 0.35, 0.45];var taxQuick = [0, 105, 555, 1005, 2755, 5505, 13505];var cacheGetOnlyBonusTax = &#123;&#125;;var cacheGetOneMonthBonus = &#123;&#125;;var cacheGetTwoMonthBonus = &#123;&#125;;// 获取不拆分年奖交税总额function getOnlyBonusTax(yearBonus, monthSalary) &#123; var cached = cacheGetOnlyBonusTax[yearBonus + ',' + monthSalary] if (typeof cached != 'undefined') &#123; return cached; &#125; var tax = 0; if (monthSalary &gt; baseQuota) &#123; perMonth = yearBonus / 12; tax = round(yearBonus * getTaxRat(perMonth) - getTaxQuick(perMonth), 2); &#125; else &#123; if (yearBonus &lt; baseQuota - monthSalary) &#123; tax = 0; &#125; else &#123; perMonth = (yearBonus - (baseQuota - monthSalary)) / 10; tax = (yearBonus - (baseQuota - monthSalary)) * getTaxRat(perMonth) - getTaxQuick(perMonth); &#125; &#125; cacheGetOnlyBonusTax[yearBonus + ',' + monthSalary] = tax return tax;&#125;// 获取税率等级function getTaxNum(money)&#123; for (var i = 0, l = taxQuota.length; i &lt; l; i++) &#123; if (money &lt;= taxQuota[i]) &#123; return i; &#125; &#125; return i;&#125;// 获取税率function getTaxRat(money)&#123; return taxRat[getTaxNum(money)];&#125;// 获取速算扣除数function getTaxQuick(money) &#123; return taxQuick[getTaxNum(money)];&#125;// 获取平常月交税金额function getMonthTax(money) &#123; if (money &gt; baseQuota) &#123; return getTax(money - baseQuota); &#125; else &#123; return 0; &#125;&#125;// 获取年奖平均月交税金额function getPerMonthTax(money) &#123; return getTax(money);&#125;// 计算个人所得税金额function getTax(money) &#123; return round(money * getTaxRat(money) - getTaxQuick(money), 2);&#125;// 计算增加的交税金额function getMonthTaxAdd(monthSalary, addNum) &#123; var monthAddSalary = monthSalary + addNum; monthTaxAdd = round(getMonthTax(monthAddSalary) - getMonthTax(monthSalary), 2); return monthTaxAdd;&#125;// 计算金额小数function round(num, toFix) &#123; return parseFloat(num.toFixed(toFix), 10);&#125;// 获取拆分为一个月交税总额function getOneMonthBonus(yearBonus, monthSalary) &#123; var cached = cacheGetOneMonthBonus[yearBonus + ',' + monthSalary] if (typeof cached != 'undefined') &#123; return cached &#125; var nowBonusTax = getOnlyBonusTax(yearBonus, monthSalary); var halfBonus = round(yearBonus/2); for (var i = 1; i &lt; halfBonus; i++) &#123; var bonusRemain = yearBonus - i; var monthTaxAdd = getMonthTaxAdd(monthSalary, i); var bonusTax = round(getOnlyBonusTax(bonusRemain, monthSalary) + monthTaxAdd, 2); if (bonusTax &lt; nowBonusTax) &#123; nowBonusTax = bonusTax; oneMonth = i; &#125; &#125; var result = &#123; tax: nowBonusTax, bonus: i &#125;; cacheGetOneMonthBonus[yearBonus + ',' + monthSalary] = result; return result;&#125;// 获取拆分为两个月交税总额function getTwoMonthBonus(yearBonus, monthSalary) &#123; var cached = cacheGetTwoMonthBonus[yearBonus + ',' + monthSalary] if (typeof cached != 'undefined') &#123; return cached &#125; var nowBonusTax = getOnlyBonusTax(yearBonus, monthSalary); var halfBonus = round(yearBonus/2); for (var i = 1; i &lt; halfBonus; i++) &#123; var bonusRemain = yearBonus - i; var monthTaxAdd = getMonthTaxAdd(monthSalary, (i / 2)) * 2; var bonusTax = round(getOnlyBonusTax(bonusRemain, monthSalary) + monthTaxAdd, 2); if (bonusTax &lt; nowBonusTax) &#123; nowBonusTax = bonusTax; twoMonth = i / 2; &#125; &#125; var result = &#123; tax: nowBonusTax, bonus: i &#125;; cacheGetTwoMonthBonus[yearBonus + ',' + monthSalary] = result return result&#125;function run(yearBonus, monthSalary)&#123; var startTime = (new Date).getTime(); var yearBonusTax = getOnlyBonusTax(yearBonus, monthSalary); var oneMonthTax = getOneMonthBonus(yearBonus, monthSalary); var twoMonthTax = getTwoMonthBonus(yearBonus, monthSalary); var minTax = Math.min(yearBonusTax, oneMonthTax.tax, twoMonthTax.tax); var bonusRemain = yearBonus - minTax; if (minTax == yearBonusTax) &#123; console.log('年终奖发放：' + yearBonus, '第一个月发放：' + 0, '第二个月发放：' + 0, '实际收入：' + bonusRemain); &#125; else if (minTax == oneMonthTax.tax) &#123; console.log('年终奖发放：' + (yearBonus - oneMonthTax.bonus), '第一个月发放：' + oneMonthTax.bonus, '第二个月发放：' + 0, '实际收入：' + bonusRemain); &#125; else if (minTax == twoMonthTax.tax) &#123; console.log('年终奖发放：' + (yearBonus - (twoMonthTax.bonus * 2)), '第一个月发放：' + twoMonthTax.bonus, '第一个月发放：' + twoMonthTax.bonus, '实际收入：' + bonusRemain); &#125; var endTime = (new Date).getTime(); console.log('耗时：' + (endTime - startTime) + 'ms');&#125;run(19000, 9500);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript实现年终奖避税程序]]></title>
      <url>%2F2017%2F01%2F24%2Fjavascript-year-bonus-evade-tax%2F</url>
      <content type="text"><![CDATA[昨天公司发了年终奖，扣了我20%的税…我就操了，肉疼啊…T^T…话说年终奖避税不是没有办法啊，为毛不给整整呢，总觉得肯定有什么不可告人的秘密… 于是我决定写个年终奖避税的程序去去火，不然这口气憋在心里非憋坏了不可… 政策调查调查了下相关的政策，根据现有个人所得税计税办法，个人薪酬计税有两种方式，一种为月工资（含月奖金）计税，一种为年终奖综合计税。在年终奖综合计税发放过程中，在某些区间会出现税前奖金增加，税后实际收入反而减少的情况。 具体的税收办法是这样的， 月工资计税公式： 应纳税额 = 月工资应纳税所得额 * 适用税率 - 速算扣除数 月工资应纳税所得额 = 计税月工资额 - 个人所得税起征点 个人所得税起征点 = 3500 解释两个概念： 个人所得税起征点既税法规定的费用扣除额。 速算扣除数速算扣除数并非税法规定，而是根据税法推算出来的一个方便计算的系数。税法中关于个税的计算应该是分阶段的。不超过1500元的收3%，超过1500元至4500元的部分收10%，超过4500元至9000元的部分20%… 如果某人扣保险后工资10000，怎么计算呢？10000 = 3500 + 1500 + 3000 + 2000。 其中3500免征；1500按3%，征税45元；3000按10%，征300元；2000按20%，征400元。整个算下来征税745元。这么算很麻烦，所以会计们发明了速算扣除数。税率3%对应速算扣除数为0；税率10%对应速算扣除数为 1500 * (10% - 3%) + 0 = 105；税率20%对应速算扣除数为 4500 * (20% - 10%) + 105 = 555；以此类推，得到级别的速算扣除数。 放上汇总之后的个人所得税税率表，之后会用到： 级数 全月应纳税所得额（元） 税率（%） 速算扣除数 1 0 ~ 1500 3 0 2 1500.01 ~ 4500 10 105 3 4500.01 ~ 9000 20 555 4 9000.01 ~ 35000 25 1005 5 35000.01 ~ 55000 30 2755 6 55000.01 ~ 80000 35 5505 7 80000.01 ~ ∞ 45 13505 年终奖综合计税办法： 纳税人取得全年一次性奖金，单独作为一个月工资、薪金所得计算纳税，并按以下办法计税。 (一) 先将雇员当月内取得的全年一次性奖金，除以12个月，按其商数确定适用税率和速算扣除数。 如果在发放年终一次性奖金的当月，雇员当月计税工资额低于税法规定的费用扣除额（个人所得税起征点3500元），应将全年一次性奖金减除”雇员当月计税工资额与费用扣除额的差额”后的余额，按上述办法确定全年一次性奖金的适用税率和速算扣除数。 (二) 将雇员个人当月内取得的全年一次性奖金，按第(一)项确定的适用税率和速算扣除数计算征税，计算公式如下： 如果雇员当月工资薪金所得高于(或等于)税法规定的费用扣除额的，适用公式为： 应纳税额 ＝ 雇员当月取得全年一次性奖金 * 适用税率 - 速算扣除数 如果雇员当月计税工资额低于税法规定的费用扣除额的，适用公式为： 应纳税额 ＝ (雇员当月取得全年一次性奖金 - 雇员当月计税工资额与费用扣除额的差额) * 适用税率 - 速算扣除数 (三) 在一个纳税年度内，对每一个纳税人，该计税办法只允许采用一次。 实例看过刚才的政策，咱们再来看三个例子： 员工A，月薪2500，年终奖为5000，应缴个税为150，计算过程如下： 先算计税基础，(5000 - (3500 - 2500)) / 12 = 333.33，查税率表，适用3%的税率。 再算应纳所得税，5000 * 3% - 0 = 150，税后所得为 5000 - 150 = 4850。 员工B，月薪9000，年终奖18000，应缴个税为540，计算过程如下： 先算计税基础，18000 / 12 = 1500，查税率表，适用3%的税率。 再算应纳所得税，18000 * 3% - 0 = 540，税后所得为 18000 - 540 = 17460。 员工C，月薪9500，年终奖19000，应缴个税为1795，计算过程更上面一样，计算过程如下： 先算计税基础，19000 / 12 = 1583.3，查税率表，适用10%的税率。 再算应纳所得税，19000 * 10% - 105 = 1795，税后所得为 19000 - 1795 = 17205。 看过之前三个例子你发现了吗？员工C虽然账面上比员工B多拿了1000的年终奖，但是实际所得却比员工B还少…这就是之前咱们说到的那个问题…也是年终奖需要避税的主要原因… 造成这个问题的主要原因，是由于税率虽然按照年终奖的12分之1计算了，但是速算扣除数却没有对应的扩大12倍。 假如速算扣除数也相应扩大12倍，那么年终奖19000的应缴个税为19000 * 10% - 105 * 12 = 640，这样和年终奖18000纳所得税540是不是差异就很小了？ 据说之所以没有执行这样的政策，是因为年终奖一般都会超过一个月工资，直接按照个人所得税的税率纳税，肯定是要多缴税的。除以12个月作为计税基础，已经是税务局给予纳税人很大的优惠了，所以速算扣除数不能再给予优惠… 避税常见的年终奖避税方式是将年终奖拆分，一部分按年终奖综合计税发放，一部分随月工资发放，一般1到2个月发完。 比如，月薪9500，年终奖19000，如果不做拆分直接纳税，应缴个税1795。如果拆分为年终发18000，之后月工资多发1000奖金，年终奖部分应缴个税应为18000 * 3% = 540，工资部分应缴个税(9500 + 1000 - 3500) * 20% - 555 = 845，比按月薪9500缴纳个税多缴了 200，所以总共少缴纳个税1795 - (540 + 200) = 1055 按照这个思路就来设计一个程序，来自动计算怎么拆分最好，能让收入最多。 设计首先考虑下这个程序的输入输出，输入月工资和年终奖，然后打印出年终奖发多少，剩余的怎么拆分。 然后考虑具体的功能，缴税额计算都有现成的公式，封装成独立的函数就行了。年终奖的拆分应该会出现三种情况：不拆分最优，拆分入一个月最优，拆分入两个月最优。 因为暂时还没想到什么好算法，所以就不考虑性能，先实现了功能再说，用遍历把所有可能的拆分都试一遍，以后在考虑做剪枝。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129var baseQuota = 3500;var taxQuota = [1500, 4500, 9000, 35000, 55000, 80000];var taxRat = [0.03, 0.10, 0.20, 0.25, 0.30, 0.35, 0.45];var taxQuick = [0, 105, 555, 1005, 2755, 5505, 13505];// 获取不拆分年奖交税总额function getOnlyBonusTax(yearBonus, monthSalary) &#123; var tax = 0; if (monthSalary &gt; baseQuota) &#123; perMonth = yearBonus / 12; tax = round(yearBonus * getTaxRat(perMonth) - getTaxQuick(perMonth), 2); &#125; else &#123; if (yearBonus &lt; baseQuota - monthSalary) &#123; tax = 0; &#125; else &#123; perMonth = (yearBonus - (baseQuota - monthSalary)) / 10; tax = (yearBonus - (baseQuota - monthSalary)) * getTaxRat(perMonth) - getTaxQuick(perMonth); &#125; &#125; return tax;&#125;// 获取税率等级function getTaxNum(money)&#123; for (var i = 0, l = taxQuota.length; i &lt; l; i++) &#123; if (money &lt;= taxQuota[i]) &#123; return i; &#125; &#125; return i;&#125;// 获取税率function getTaxRat(money)&#123; return taxRat[getTaxNum(money)];&#125;// 获取速算扣除数function getTaxQuick(money) &#123; return taxQuick[getTaxNum(money)];&#125;// 获取平常月交税金额function getMonthTax(money) &#123; if (money &gt; baseQuota) &#123; return getTax(money - baseQuota); &#125; else &#123; return 0; &#125;&#125;// 获取年奖平均月交税金额function getPerMonthTax(money) &#123; return getTax(money);&#125;// 计算个人所得税金额function getTax(money) &#123; return round(money * getTaxRat(money) - getTaxQuick(money), 2);&#125;// 计算增加的交税金额function getMonthTaxAdd(monthSalary, addNum) &#123; var monthAddSalary = monthSalary + addNum; monthTaxAdd = round(getMonthTax(monthAddSalary) - getMonthTax(monthSalary), 2); return monthTaxAdd;&#125;// 计算金额小数function round(num, toFix) &#123; return parseFloat(num.toFixed(toFix), 10);&#125;// 获取拆分为一个月交税总额function getOneMonthBonus(yearBonus, monthSalary) &#123; var nowBonusTax = getOnlyBonusTax(yearBonus, monthSalary); for (var i = 1; i &lt; yearBonus; i++) &#123; var bonusRemain = yearBonus - i; var monthTaxAdd = getMonthTaxAdd(monthSalary, i); var bonusTax = round(getOnlyBonusTax(bonusRemain, monthSalary) + monthTaxAdd, 2); if (bonusTax &lt; nowBonusTax) &#123; nowBonusTax = bonusTax; oneMonth = i; &#125; &#125; return &#123; tax: nowBonusTax, bonus: i &#125;&#125;// 获取拆分为两个月交税总额function getTwoMonthBonus(yearBonus, monthSalary) &#123; var nowBonusTax = getOnlyBonusTax(yearBonus, monthSalary); for (var i = 1; i &lt; yearBonus; i++) &#123; var bonusRemain = yearBonus - i; var monthTaxAdd = getMonthTaxAdd(monthSalary, (i / 2)) * 2; var bonusTax = round(getOnlyBonusTax(bonusRemain, monthSalary) + monthTaxAdd, 2); if (bonusTax &lt; nowBonusTax) &#123; nowBonusTax = bonusTax; twoMonth = i / 2; &#125; &#125; return &#123; tax: nowBonusTax, bonus: i &#125;;&#125;function run(yearBonus, monthSalary)&#123; var startTime = (new Date).getTime(); var yearBonusTax = getOnlyBonusTax(yearBonus, monthSalary); var oneMonthTax = getOneMonthBonus(yearBonus, monthSalary); var twoMonthTax = getTwoMonthBonus(yearBonus, monthSalary); var minTax = Math.min(yearBonusTax, oneMonthTax.tax, twoMonthTax.tax); var bonusRemain = yearBonus - minTax; if (minTax == yearBonusTax) &#123; console.log('年终奖发放：' + yearBonus, '第一个月发放：' + 0, '第二个月发放：' + 0, '实际收入：' + bonusRemain); &#125; else if (minTax == oneMonthTax.tax) &#123; console.log('年终奖发放：' + (yearBonus - oneMonthTax.bonus), '第一个月发放：' + oneMonthTax.bonus, '第二个月发放：' + 0, '实际收入：' + bonusRemain); &#125; else if (minTax == twoMonthTax.tax) &#123; console.log('年终奖发放：' + (yearBonus - (twoMonthTax.bonus * 2)), '第一个月发放：' + twoMonthTax.bonus, '第一个月发放：' + twoMonthTax.bonus, '实际收入：' + bonusRemain); &#125; var endTime = (new Date).getTime(); console.log('耗时：' + (endTime - startTime) + 'ms');&#125;run(19000, 9500); ok，这次就先到这里，下次再更新这个程序的优化方案吧。如果不出意外的话，maybe可能大概下周五会更新吧~马上要过年了，这里先祝米娜桑鸡年大吉咯~！\（￣︶￣）/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一场抽奖引发的扯淡]]></title>
      <url>%2F2017%2F01%2F19%2Fgab-draw%2F</url>
      <content type="text"><![CDATA[起因今年年会的抽奖算法写的实在是太烂。整个整个抽奖流程大概是这样的：每次抽奖是抽奖人先说开始，于是开始播放动画遍历队列，然后过一段时间，抽奖人说停，遍历结束，停在哪儿谁就中奖。可是不用看代码我都知道，每次抽奖时没有对队列进行随机排序。因为有动画效果，遍历的速度不可能很快，抽奖人又不会等很久才说停，所以排在后面的怎么可能中奖（我就是排在后面的）……于是我开始思考，如果是我，我会怎么写这个抽奖的程序呢。 实现抽奖可以概括的描述为：从一个指定的集合中，随机选出若干个元素。 ok，用编程语言翻译翻译： 12345678910function draw(list = [], number = 0) &#123; list = list.concat() let result = [] while (number--) &#123; result.push(list.splice(Math.floor(Math.random()*list.length), 1)[0]) &#125; return result&#125;let drawResult = draw(['刘能', '谢大脚', '王长贵', '赵四', '刘英', '李大国', '赵玉田', '刘大脑袋', '王天来', '王大拿', '李秋歌'], 3)console.log(`中奖者为：$&#123;drawResult.join('，')&#125;`) 质疑程序是写好了，但是这个程序真的能保证公平公正的抽奖吗？从上面的程序中一眼就能看出来，我们的抽奖程序是依赖于Math.random生成的随机数的。 但是，可能会有人质疑，Math.random生成的随机数真的是随机的，没有规律的吗？有没有可能通过预测出规律从而控制中奖结果？ Math.random说到javascript的Math.random，ECMAScript是这么规定的： ‘20.2.2.27Math.random ( )’ Returns a Number value with positive sign, greater than or equal to 0 but less than 1, chosen randomly or pseudo randomly with approximately uniform distribution over that range, using an implementation-dependent algorithm or strategy. This function takes no arguments. Each ‘Math.random’ function created for distinct realms must produce a distinct sequence of values from successive calls. 并没有提到是如何实现的。所以各家浏览器实现的方法也都不一样。 比如，V8是这样实现的MathRandom，SpiderMonkey是这样实现的ensureRandomNumberGenerator，webkit是这样实现的WeakRandom。 但是，不管是什么方法生成，基本规则都是基于一个种子（seed），经过一系列计算，最终生成一个值。也就是说，如果种子是确定的，那么最终生成的值也一定是确定的…… 那么种子又是根据什么确定的呢？一般是使用函数调用时的当前时间作为种子的。 结论既然上面说到了，所有的结果都是计算的结果，那么是不是说明抽奖结果并不是随机的是可预测的呢？其实也不是，因为在抽奖的过程中引入了随机的外部输入。没错，抽奖函数的执行时机是由人掌控的，而人的思想是不可掌控的，所以可以把抽奖的时机当做随机事件，这样抽奖的结果也肯定是随机的了……大概吧…… 但是，如果提前确定下了抽奖的时间了，理论上，抽奖的结果就是可预测的了。 那么有没有办法不依赖用户输入来产生随机的结果呢？只要引入一些无法认为控制的元素就可以了，比如使用一些无法预测和控制的物理信息或者自然现象来生成随机数。 例如，Linux中的接口/dev/random就是引入了物理噪音作为输入来产生随机数的。 还有RANDOM.ORG，这个网站使用大气噪音来生成随机数。（他们提供的服务还是免费的，可以再这里查看他们提供的服务列表） P.S.其实所有的伪随机数生成器都长周期相关现象，不过只要这个周期足够长，短时间内是不会出现问题的。之前V8就爆出过乱度不足的问题，后来在49版本改用xorshift128+算法解决了这个问题。xorshift128+算法拥有极长的周期长度： This has been pointed out to us, and having understood the problem and after some research, we decided to reimplement Math.random based on an algorithm called xorshift128+. It uses 128 bits of internal state, has a period length of 2128 - 1, and passes all tests from the TestU01 suite. 应付年会抽奖这种小范围的活动肯定是绰绰有余的了。但是如果要在密码或者安全领域使用伪随机数，最好还是使用CSPRNG（密码学安全伪随机数生成器）来生成。浏览器环境可以使用crypto.getRandomValues，nodejs环境可以使用crypto.randomBytes。 需要注意的是crypto.getRandomValues函数接收的是一个TypedArray（Int8Array，Uint8Array……）而不是普通的数组，然后返回一个随机数队列。crypto.randomBytes函数接受一个字符指定返回值得长度，然后返回一个buffer而不是数字。要想转换为数字的话需要先用toString(‘hex’)转换为16进制字符串，再用parseInt将其转化为数字。 ok，那么这次的扯淡就到这里，感谢您的收看，咱们下次再扯，完结撒花~\（￣︶￣）/ 扩展阅读 伪随机的上位和真随机的逆袭 V8 的 Math.random() 亂度不足的問題 Math.random() 关于随机数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入mobx原理]]></title>
      <url>%2F2017%2F01%2F13%2Fan-in-depthexplanation-of-mobx%2F</url>
      <content type="text"><![CDATA[这篇文章翻译自mobx作者 Michel Weststrate 的一篇博客，虽然我也想做到信达雅，奈何英语水平有限……所以其中掺杂了很多我自己的理解。想了解细节的话可移步原文 看过我之前的博客的看官都知道，mobx的除了能实现响应式的功能，它的运行速度还很快，那么，他是如何做到的呢？我们一起来看看mobx的内部运行机制。 首先，让我们来回顾一下mobx的核心概念： 可观测状态 状态是指任何可以改变并且会引发计算属性变化的值。mobx可以把大多数类型的值(基础类型、数组、各种对象)，都转化成可观测的。而且针对，数组或对象等的结构化的数据类型，这种转化是递归的，数组或对象的所有子节点都会被转化。 计算属性 计算属性是一个函数。这个函数不接收参数，只单纯的依赖的其他可观测状态。依赖的可观测状态发生变化，它的运行结果才会发生变化。 虽然和定义有一定出入，但是从输入输出保持一致这点来看，计算属性应该算是一种纯函数。 很多场景都能用到计算属性，比如字符串的连接，或者生成复杂结构的对象。因为计算属性自身也是可观测的，所以甚至可以使用它从可观测状态导出完整的用户界面。计算属性还可以在惰性和活跃两种状态之间切换。 反应 反应和计算属性有点类似，不同点在于，计算属性的函数是产生一个新的值，而反应是产生一个副作用。所谓副作用，就是指一些跟计算无关的动作，比如打印日志，网络请求，更新界面之类的。总之使用反应可以把数据变化和其他流程关联起来。 动作 动作是修改状态的主要方法。动作本身并不对状态更改做响应，而是修改可观测状态。（如用户触发的事件、web-socket传入消息、或直接对可观测状态的修改） 这四个核心概念对应mobx中最常用的4个api，observable、computed、reaction（autorun）、action。 之后，我们把计算属性和反应都称为派生。 上面的解释可能有点儿不好理解，那我把它说的更形象一些： execl都用过吧？可观测状态 就是里面的单元格。计算属性 就是里面的公式。动作 好比你双击了一个单元格改变了单元格的数据。把修改过后的数据反馈到屏幕上就是 反应 做的事。 这有个使用mobx和react的例子，例子中使用到了这四个概念： 123456789101112131415161718192021222324252627class Person &#123; @observable firstName = "Michel"; @observable lastName = "Weststrate"; @observable nickName; @computed get fullName() &#123; return this.firstName + " " + this.lastName; &#125;&#125;const michel = new Person();// 这里就算是一个反应，用来打印可观测状态变化的日志autorun(() =&gt; console.log(person.nickName ? person.nickName : person.fullName));// 示例的react组件，根据状态变化发生改变，其中observer是来自react-mobx的apiconst profileView = observer(props =&gt; &#123; if (props.person.nickName) return &lt;div&gt;&#123;props.person.nickName&#125;&lt;/div&gt; else return &lt;div&gt;&#123;props.person.fullName&#125;&lt;/div&gt;&#125;);// 动作setTimeout(() =&gt; michel.nickName = "mweststrate", 5000)React.render(React.createElement(profileView, &#123; person: michel &#125;), document.body); 例1:可观测状态、计算属性、反应渲染Reactjs组件和动作 基于上面的例子，我们可以整理出下图的依赖关系树: 图1:profileView组件的依赖关系树。此时fullName处于活跃状态，它同时观察firstName和lastName 蓝色的是可观测状态。绿色的fullName是计算属性，可以通过观测firstName和lastName的状态自动计算。同理，nickName和fullName的变化都会传导到profileView。profileView 的状态变化会产生一个副作用，让react组件树更新。 在mobx中，依赖关系树会被限制在最小限度。例如,一旦person对象有nickName属性，则视图不再受fullName的影响，也不会受firstName和lastName的影响。这些值之间的所有观察者都会被清理，MobX会自动简化依赖关系树： 图 2: 当person对象有nickname属性时的profileView组件的依赖性树，与图1相反，fullName现在处于惰性状态，同事他也不会观测firstName和lastName mobx将总是试图最小化产生一致状态所需的计算的数量。在这篇文章的其余部分,我将描述用来实现这一目标的一些策略。但在探索计算属性和反应保持同步的原理前，我们首先看下MobX背后的原则: 响应状态变化永远比处理状态变化好。 在我们平时的工作中，应用程序在响应状态更改时所触发的操作，通常会创建或更新某些值。我们可以尝试从另一个角度理解，既可以把大多数的动作都理解为对本地缓存的操作。触发用户界面更新?更新某些值?与后端通信?这些都可以认为是缓存失效，我们为了更新缓存所执行的动作。为了让这些缓存保持同步，我们一般会使用观察者模式，订阅缓存的状态变化，缓存失效了，好通知你的动作再次被触发。但是使用这种模式却有个根本的问题：随着你的应用的不断扩大，你要管理的订阅也越来越多，在这个管理过程中，或多或少都会犯一些错误。比如超额订阅(继续订阅一个值不再使用的值)或遗漏订阅(忘记监听数据更新而导致的数据过时的bug)。 也就是说，手动维护订阅关系，应用程序早晚会出现数据和展示不一致的情况。 图3:更新了个人信息之后，Twitter页面上的不一致现象，推文列表中作者的用户名和头像还是旧的值 Twitter用户界面不一致是一个很好的例子的。我在Reactive2015论坛上解释过造成这种情况的两种原因：要么是没有订阅通知推文列表用户信息已经改变，需要重新渲染。要么就是推文作者的数据和当前登陆用户之前没有关联，尽管这两部分的数据描述的是相同的属性相同的对象。 而像Flux那样的粗粒度的订阅很容易造成超额订阅。使用react时，可以使用react提供的开发工具打印调试信息查看是否有浪费的渲染，来简单的判断是否有超额订阅的情况。而MobX可以将这种情况降至零。mobx会自动帮你管理成千上万的订阅。 值得一提的是，超额订阅可能会很隐秘。如果你订阅的数据但并不是在所有情况下都会被使用，那它仍然是超额订阅的。例如例1中，profileView组件订阅了的fullName，但是person对象有nickName属性时，它还是超额订阅的。 所以设计mobx背后的一个重要的原则是: 只有运行时确定下来的订阅，才是最小的订阅集合 mbox背后的第二个重要思想是：尽量使用mobx去创建一个图结构的数据模型去管理你的应用，而不是平时常用的树状结构。 我们真正要开发的应用通常会比TodoList复杂很多。图结构可以有效的保证数据的一致性，并避免数据重复。 mobx如何保持所有派生一致解决方案：用计算代替缓存。有人会问：“那不是非常消耗资源的吗?”其实并没有，而且他效率还挺高的。 原因正如上面所解释的：mobx并不运行所有派生，只同步那些参与到反应中的计算属性和可观测状态。这些派生被称为活跃的。 惰性和活跃那么没有直接或间接被反应调用的派生咋办呢？当然，你仍然可以随时检查计算属性（如fullName）的值。 解决方法也很简单：如果一个计算值不是活跃的，那么它将在需要他的时候重新计算（就是惰性的），就跟一个正常的getter函数一样。如果惰性的派生(从来没有观察到任何东西)从作用域中移除，就会被垃圾收集。还记得计算属性是可观察状态的纯函数吧？这就是为啥他是纯函数的原因:不管什么状态下，相同的可观测状态，计算属性函数计算的结果也一定是相同的。 运行计算mobx中反应和计算属性都是由以同样的方式运行的。当前运行的派生有个函数栈，当有计算触发了派生的函数，这个函数就会被推入栈中。只要计算正在运行，被访问的每个被观测状态都会将其自身注册为派生栈的最顶层函数的依赖。如果需要计算属性的值，并且计算属性已经处于活跃状态，则直接使用最后一次计算出的值。否则就将他推入派生函数栈，切换到活跃状态，并开始计算。 图4:在执行profileView响应函数期间的计算过程。 当计算完成时，派生将获得在执行期间访问的可观测列表。 例如，在profileView中，此列表将只包含nickName属性，或nickName和fullName属性。 每次获得的列表与之前的都可能不同。 任何被废弃的属性都将被忽略（计算属性可能从活跃模式转换到惰性模式），并且任何新添加的可观测状态都将被观测，直到下一次计算。 如果firstname的值以后更改了，观测它的派生就知道fullName需要重新计算。这反过来将导致界面重新渲染。 下一段更详细地解释这个过程。 状态变化的传播 图5：在依赖关系树上更改’1’的值的效果。 虚线边框表示需要被更新的派生。 数字表示计算的顺序。 派生会自动响应状态的变化。所有反应函数都是同步执行的，而且是无干扰的。当一个可观测的值被修改，整个修改算法如下： 被观测对象给所有观察它的派生发送一个过期通知，告诉它们自己需要更新了。任何受到影响的计算属性将递归的把消息传递给其他的观察者。结果，依赖树中的一部分被标记为过期。在图5的示例依赖关系树中，当值’1’改变时变为陈旧的观察者用橙色的虚线标记。这些都是受影响的派生。 发送失效通知并存储新值后，将发送就绪通知。 此消息还将标记值是否真的发生了改变。 一旦派生接收到针对步骤1的就绪通知，它就知道所有的观测值都已经稳定了，然后它会开始重新计算。就绪/失效消息的计数器会保证计算属性’4’将会在计算属性’3’变得稳定之后才重新计算。 如果没有接到就绪通知值，则派生将简单的告诉自己的观察者自己已经准备好了，但是值没变。否则，计算属性将重新计算并给自己的观察者发送就绪通知。在图5中我们可以看到，比如计算属性‘4’重新计算后没有产生新值，那么最后的响应（‘-’表示的那个）永远都不会被执行。 前两段总结了如何在运行时跟踪可观测状态和派生之间的依赖关系，以及如何通过派生来传播变化。 现在，你可能还会意识到，反应其实就是一个总是处于活跃状态的计算属性。 此外，mobx还应用了许多其他优化，不过这超出了本文的范围，暂不讨论。 同步执行人们经常惊讶与mobx所有的动作都是同步运行的（像RxJs和不像knockout）。 这有两大优点：首先，它变得根本不可能观察到过期的派生。 因此，在影响它的值修改之后，可以立即使用派生的值。 其次，它使栈跟踪和调试更容易，因为它避免了无用的栈跟踪。 但是，有些时候我们不得不引入批量操作。比如autocomplate之类的常见功能，会在短时间内连续多次改变值，我们需要在一系列改变之后再发送就绪通知。这就要用mobx中的另一个概念，事务（transaction）。 事务可以推迟就绪通知，整个事务完成。 1234transaction(() =&gt; &#123; michel.firstName = "Mich"; michel.lastName = "W.";&#125;); 例 2: 事务示例。 至此，我们总结了mobx最基本的实现细节。我们还没有覆盖一切，但是剩下的也都很好理解，例如，你可以组合计算属性。 通过组合反应和计算属性，甚至可以自动将一个数据图转换为另一个数据图。通过这些特性，我们还能很容易的实现一些复杂的模式，如map-reduce，时间回溯，或者横向数据加载。 重点概要： 复杂应用程序的应用程序状态最好使用图表来表示，既能保证数据和视图的一致性，又直观好理解 不应该通过手动订阅来同步状态。这将不可避免地导致超额订阅和遗漏订阅 使用运行时分析来确定观察者→可观测状态关系的最小集合。 这样就能达到既保证基本功能，又保持最小计算量的效果。 没有被主动调用的派生都会被优化掉]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript中的进程、线程和协程]]></title>
      <url>%2F2016%2F12%2F30%2Fprocess-thread-and-coroutine-in-javascript%2F</url>
      <content type="text"><![CDATA[这周一直在编前端构建的脚本，用到了多进程去解决一个效率问题。期间差了很多进程、线程、协程的资料，在这里记录回顾一下。 概念关于进程、线程、协程的概念这里就不再赘述了，具体的可以参考wiki百科： 进程 线程 协程 简单概括一下它们间的区别就是相对线程和协程，进程更独立，有自己的内存空间，所以进程间通信比较困难。线程比进程轻量级，属于同一进程的多个线程间可以共享全部资源。协程与线程类似，不同点在于，线程由系统控制切换，协程是由用户控制切换。 那么，控制切换，指的是控制什么的切换呢？ 在一个进程中执行的程序，有时需要同时处理多个工作，这时我们可以创建多个线程，让每个线程处理一个工作。但是，进程只有一个。就好比一个人，你给他分配了多个工作，帮他把每个工作单独拉了一个列表，可还是他一个人干，他只能一会儿干干这一会儿干干那，来模拟多个工作同时进行的状态，这就是所谓的系统控制切换，系统不停的在多个线程间切换来达到并行的效果。你可能会说，那根一件一件干不是一样吗？没错，是一样的，在只有一个cpu的电脑上，用不用多线程程序执行的时间是一样的。但是，如果这个人长了两个脑袋呢？那么他就能同时处理两件工作了。多核cpu就是那个长了好多个脑地的人……而协程的切换是要由用户手动来控制的，所以协程并适合并行计算，而更多的用来优化程序结构。 js都支持吗？这要看js在什么环境运行。 在浏览器中，可以通过webworkers创建进程，可以通过async/await，yield/Generator/GeneratorFunction实现协程，控制程序切换。 在node中，除了可以使用上面浏览器中可以使用的方法，还可以通过cluster，child_process创建进程，通过libuv，tagg创建线程 刚才提到的那些都是啥？怎么用？webworkers简单点儿说就是使用webworkers你可以在全新的环境中运行一个你指定的js文件。这个全新的环境是独立的，既一个全新的进程，有点儿像一个新iframe还没有window.top，window.parent属性，哈哈…… webworkers创建的进程和主进程之间可以通过message事件传递消息，但是消息只能是字符串，所以想要传对象和数组就只能传json了……这也是他不方便的地方。 具体使用方法可以看MDN上的文章：使用 Web Workers async/awaitasync/await是es7中新加的两个关键字，async 可以声明一个异步函数，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果。 其实就是类似汇编的寄存器和跳转指令……呃，通俗的说就是可以根据状态跳转态另一个函数半中间。 由于es7还未在各个环境实现，想要使用的话还的用一些babel-polyfill之类的库做兼容…… 更详细介绍请看阿阮的文章：异步操作和Async函数 yield/Generator/GeneratorFunctiongenerator是es6中新增的函数，本质是可以将一个函数执行暂停，并保存上下文，再次调用时恢复当时的状态。但是用来解决协程切换的问题貌似有点儿滥用特性的感觉呢…… 更详细介绍请看阿阮的文章：Generator 函数 clustercluster是node官方提供的一个多进程模块，效果和C语言的fork函数类似，当前文件完全重新执行一遍，通过cluster.isMaster判断是不是主进程，在区分不同的操作。进程间通过事件回调来通信，NodeJS 0.6.x 以上的版本开始支持。 示例代码就不放了，node官方文档上写的很详细：cluster child_processnode自带的child_process模块里的fork函数可以实现类似浏览器里webworkers的效果，使用方法和webworker一毛一样，都是通过读取新文件开启新进程，通过message通信。 具体介绍请看文档：child_process.fork(modulePath[, args][, options]) 官方文档没有示例，下面给出一个web服务接收参数计算斐波那契数组的例子： index.js1234567891011121314var express = require('express');var fork = require('child_process').fork;var app = express();app.get('/', function(req, res)&#123; var worker = fork('./work_fibo.js') //创建一个工作进程 worker.on('message', function(m) &#123;//接收工作进程计算结果 if('object' === typeof m &amp;&amp; m.type === 'fibo')&#123; worker.kill();//发送杀死进程的信号 res.send(m.result.toString());//将结果返回客户端 &#125; &#125;); worker.send(&#123;type:'fibo',num:~~req.query.n || 1&#125;);//发送给工作进程计算fibo的数量&#125;);app.listen(8124); work_fibo.js123456789101112131415var fibo = function fibo (n) &#123;//定义算法 return n &gt; 1 ? fibo(n - 1) + fibo(n - 2) : 1;&#125;process.on('message', function(m) &#123;//接收主进程发送过来的消息 if(typeof m === 'object' &amp;&amp; m.type === 'fibo')&#123; var num = fibo(~~m.num); //计算jibo process.send(&#123;type: 'fibo',result:num&#125;) //计算完毕返回结果 &#125;&#125;);process.on('SIGHUP', function() &#123; process.exit();//收到kill信息，进程退出&#125;); libuvlibuv是node底层实现使用的c++库……呃，所以如果你想使用这个库来实现多线程，那么你就得编写c++的代码了，不得不说，要想真正理解程序的本质，不多掌握几门语言真是不行啊…… 对c++不了解我就不瞎BB了，推荐两篇文章延伸阅读： libuv多线程处理的简单示例 利用libuv编写异步多线程的addon实例 taggtagg(Threads a gogo for Node.js)是Jorge Chamorro Bieling开发的一个node包。使用c语言phread库实现的多线程。 还是那刚才的斐波那契数组计算为例： 12345678910var Threads = require('threads_a_gogo');//加载tagg包function fibo(n) &#123;//定义斐波那契数组计算函数 return n &gt; 1 ? fibo(n - 1) + fibo(n - 2) : 1;&#125;var t = Threads.create().eval(fibo);t.eval('fibo(35)', function(err, result) &#123;//将fibo(35)丢入子线程运行 if (err) throw err; //线程创建失败 console.log('fibo(35)=' + result);//打印fibo执行35次的结果&#125;);console.log('not block');//打印信息了，表示没有阻塞 最后结果：12not blockfibo(35)=14930352 我们可以看到执行效果与webworker类似，不同的是通信使用了异步回调的方式。 值得一提的是tagg包目前只能在linux下安装运行，这里再推荐一个tagg2包，是跨平台的。 这里需要重点提一下的是，不论tagg还是tagg2包都是利用phtread库和v8的v8::Isolate Class类来实现js多线程功能的。 Isolate代表着一个独立的v8引擎实例，v8的Isolate拥有完全分开的状态，在一个Isolate实例中的对象不能够在另外一个Isolate实例中使用。嵌入式开发者可以在其他线程创建一些额外的Isolate实例并行运行。在任何时刻，一个Isolate实例只能够被一个线程进行访问，可以利用加锁/解锁进行同步操作。 换而言之，我们在进行v8的嵌入式开发时，无法在多线程中访问js变量，这条规则将直接导致我们之前的tagg2里面线程执行的函数无法使用Node.js的核心api，比如fs，crypto等模块。 延伸阅读： tagg tagg2 总结经过以上的学习，我们大概应该了解到进程、线程、协程的使用场景了，进程、线程适合用来处理计算密集型操作，协程适合用来优化代码结构，解决回调函数嵌套问题。线程比进程更轻，更节省资源，但是由于上面提到的线程问题，针对一些可以使用js原生的大量计算或循环还可以用用，涉及到使用nodejs核心api的操作，比如文件处理之类的操作，就要用进程使用解决了。当然，也可以用libuv库写c++模块处理多线程的操作，但是还要学c++啊望天儿…… 相关文章 Node.js的线程和进程 nodejs多线程，真正的非阻塞 协程的好处是什么? 为什么觉得协程是趋势？ p.s. 我的问题我在工作中使用的是fis配合grunt调用打包。由于要同时打包多个项目，grunt和fis都会定义全局变量，各个模块之间的配置可能会相互影响，各个模块在打包过程中又没有相互的通信，同时为了提高效率，非常时候适合使用多进程的方式来运行脚本。所以用cluster实现了多进程打包的。 最后，新年快乐，祝大家在2017年里，都能喝最烈的酒，日最野的狗~ ┑(￣Д ￣)┍]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[响应式react：构建高效易用的react应用]]></title>
      <url>%2F2016%2F12%2F23%2Fmaking-react-reactive-pursuit-high-performing-easily-maintainable-react-apps%2F</url>
      <content type="text"><![CDATA[这篇文章翻译自mobx作者 Michel Weststrate 的一篇博客，虽然我也想做到信达雅，奈何英语水平有限……所以我写的内容自动屏蔽了一些前因后果没营养的话，只翻译我觉得重点的内容。我的原则是，捞干的说，不BB~想了解细节的话可移步原文 使用react开发应用有啥好处，我想是个前端都能数出个十条八条来。但是如果你的项目需要在浏览器中绘制成千上万的对象，而且这些对象之前还有大量的耦合关系，那维护这些对象也够喝一壶的……mobx作者在发明mobx的时候就面临了这样一个项目，一个对象的值可能被其他对象引用，任何变化都可能引起大量的ui更新和重绘。在一些特殊场景，比如拖拽操作，这些动作还必须在40毫秒响应…… 于是，mobx被开发出来了。简单来说，他使用了函数响应式编程的概念 Observables 来解决上述的问题，其实 mobx 并不是第一个使用这一概念的前端库，ember、knockout还有vue其实都使用了这一概念，我个人感觉，mobx就好像把vue和knockout的数据绑定那部分抽出来然后揉到一起一样……真的能发现很多有相似的地方……使用 Observables 的好处就在于，你可以很容易实现自动更新关联数据和sideways data loading，从而解放生产力，提升应用的性能。后面测试数据一章可以看到具体的对比结果。 下面我们以一个简单的购物应用为例： 里面包含商品列表，购物车，结算等部分。完整的例子可以再jsfiddle上看到（需要翻墙）。 数据模型首先，我们先看下数据模型。商品列表（Articles）里的每个商品，有名称（name）和价格（price）属性，购物车（Cart）有已加入购物车列表（Entries）和总价（Total）属性。已加入购物车列表中的每个商品除了名字和价格属性以外，还有数量属性（amount）、根据数量和单价计算出的总价。数据之间的关系如下图所示。 从上图中我们可以看出，如果对一个数据进行修改，那么就会带动其他的数据修改，同时还得修改ui。大概列一下数据联动的逻辑： 如果商品列表里的商品价格发生改变，购物车里的商品价格也需要更新。 ……购物车的总价也得更新。 如果购物车中商品数量变化，总价也得跟着更新。 如果商品列表里的商品被重命名了，商品列表的界面得更新。 ……购物车里对应的商品也得更新。 如果添加新文章合计购物车…… 作为一个程序员，就是这么闹心……你不得不写大量的代码来处理各种可能的状态，处理速度还得快，让用户老爷等着急了你担待得起吗…… 那么，让我们来看看怎么用mobx来日翻这些问题： 123456789101112131415161718192021222324252627function Article(name, price) &#123; mobx.extendObservable(this, &#123; name: name, price: price &#125;);&#125;function ShoppingCartEntry(article) &#123; mobx.extendObservable(this, &#123; article: article, amount: 1, price: function() &#123; return this.article ? this.article.price * this.amount : 0; &#125; &#125;);&#125;function ShoppingCart() &#123; mobx.extendObservable(this, &#123; entries: [], total: function() &#123; return this.entries.reduce(function(sum, entry) &#123; return sum + entry.price; &#125;, 0); &#125; &#125;);&#125; 使用工具函数包装之后，通过构造函数创建的对象都是可观测的，就是说当对象的某一个属性改变，跟他跟他相关联的属性都会自动更新。这样状态变化就不用我们手动维护了，比如添加商品到购物车时总价的变化、物品的价格发生变化时其他关联项的变化等等。 界面模型建好了，该搭界面了。下面的列了一段购物车组件的代码，包含了显示购物车里的商品列表和总价。其他组件请自行脑补，都差不离的。 1234567891011121314151617181920212223242526var CartView = React.createClass(&#123; render: function() &#123; function renderEntry(entry) &#123; return (&lt;CartEntryView entry=&#123;entry&#125; cart=&#123;this.props.cart&#125; key=&#123;entry.id&#125; /&gt;); &#125; return (&lt;div&gt; &lt;ul id="cart"&gt;&#123;this.props.cart.entries.map(renderEntry)&#125;&lt;/ul&gt; &lt;div&gt;&lt;b&gt;Total: &lt;span id="total"&gt;&#123;this.props.cart.total&#125;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt; &lt;/div&gt;) &#125;&#125;);var CartEntryView = React.createClass(&#123; render: function() &#123; return (&lt;li&gt; &lt;button onClick=&#123;this.removeArticle&#125;&gt;&amp;laquo;&lt;/button&gt; &lt;span&gt;&#123;this.props.entry.article.name&#125;&lt;/span&gt; &lt;span&gt;&#123;this.props.entry.amount&#125;&lt;/span&gt; &lt;/li&gt;); &#125;, removeArticle: function() &#123; if (--this.props.entry.amount &lt; 1) this.props.cart.entries.splice(this.props.cart.entries.indexOf(this.props.entry), 1); &#125;&#125;); 组件写完了，但是没跟模型关联还跑不起来，需要用mobx-react库里的 mobxReact.observer 方法把组件都包装装一下，这就算关联上了： 1234var CartEntryView = mobxReact.observer(React.createClass(&#123; render: function() &#123; return (&lt;li&gt; // etc... 然后，就没有然后……是的，这就算齐活了。让我们看下jsfiddle上的演示。 这里 observer 函数为我们做了两件事。首先，它将组件的 render 函数变成一个可观察到的函数。然后，把组件注册到观察者函数，所以每次 render 需要更新了他都会自动更新。mobxReact.observer（如果你使用ES6的话是 @observer）确保每当数据改变，只更新UI的相关部分，就是刚才上面提到的sideways data loading。你可以自己点点试试，注意看下方的日志面板，看看UI更新的数据，你会发现，每次操作，组件的重绘数量都是最低的。 另外，由于每个组件都只跟踪自己的依赖，通常不需要重新渲染子组件。比如，如果购物车的总价重新渲染了，在不必要的情况下就不会重新渲染购物车里的商品列表。 测试数据东西好不好,主要看疗效。这里你可以找到一个一毛一样的应用，但没有使用mobx，而是简单的使用每次替换数据的方法构建的。只有几个商品，不会感觉到有任何区别，但一旦商品数量上升，就会提现出真正意义上的性能差异。 创建大量的数据和组件的时候，基本没啥差别。但是在修改数据时，强弱立分高下力判。如果在有10000个元素的列表中更新其中10个元素的数据，速度大约快了十倍。2.5秒下降到250毫秒……那么这种差别是从哪里来的呢？让我们来瞅瞅不适用mobx时React的渲染报告： 可以看到，ArticleViews 和 CartEntryViews一共渲染了20000次。2433毫秒的渲染时间中，2145毫秒的渲染时间是被浪费的（Wasted time）。Wasted time的意思是：花费在执行渲染函数上的时间，实际上并没有更新任何一个DOM元素。这有力地说明了，无脑更新是一件很浪费cup资源的，组件越多浪费的时间就越多。 相较之下，这是使用mobx的报告： 重绘的只有31个组件，完全没有一点浪费。就是说每个重新渲染的组件都是确实需要修改的。这正是我们想要实现的效果！ 然而，这样你就满足了吗？我们还可以再进一步优化！ 从报告中我们还可以看出，267毫秒的总体渲染时间里，大部分剩余的渲染时间消耗在CartView的渲染上（243毫秒）。那是在更新购物车的总价属性。值得注意的是，要重新渲染CartView，也就意味着要检查购物车中一万个商品是否有修改，是否要更新CartEntryView。而这就浪费了大部分时间。我们可以把总价再单独做一个控件，CartTotalView。通过这个简单的处理，如果只是总价的变化，就可以跳过CartView的重新渲染。这使得渲染时间进一步下降到约60毫秒（见上图中的灰色那一条），这比没有使用Mobx的React应用大约快了40倍! 总结好的，通过上面的例子我们看到了使用mobx和不使用mobx在性能上的区别。这里还需要强调的一点是，使用了mobx还有一个优势，就是不会影响代码的可维护性，对于程序员来说，这点很重要，就算有万般好处，如果代码写出来像屎一样难看，也不会有人想用对吧？在jsfiddle里面可以看到两个例子的完整程序。两段代码基本没啥太大的区别……┑(￣Д ￣)┍ 那么，我们可以用其他技术达到相同的效果吗？也许吧。例如，使用ImmutableJS也能做到sideways data loading。然而，就像我刚才说的，有可能你会收获一坨是一样的代码……毕竟，恕我直言，相对于不可变对象，可变类使用起来会更方便一些。此外，不可变的数据结构不能帮助你保持计算属性。如果使用不可变数据，改变商品的名字ArticleView会重新渲染的很快，但是CartEntryView中引用的相同商品实例就会失效。 另一种优化React应用的方案是为每一个可能发生的操作创建事件，然后在管理这些事件，在恰当的时机恰当的地点（组件）触发（注销）它们。但这将导致编写大量的样板式代码，维护起来相当困难。我不知道人啊，反正我是懒得弄这些……（哥你是不是不会断句……这段看的好纠结啊……） 顺便说一下，我强烈建议使用action来抽象对模型的更新，这样能有效的做到表现和行为分离。 最后，在大型项目中使用mbox配合React是非常好用的。有时我看到数据变化时，界面上某个角落也跟着更新了，我自己都惊呆了……而且还没有任何性能问题，你说气人不……(￣▽￣)”……心动不如行动，让我们把繁重的维护工作都丢给React和Mobx，敬请享受更轻松有趣的coding吧~！ 相关文章 MobX library React performance guide Shopping cart demo, React with Observables Shopping cart demo, React without Observables Shopping cart demo, JQuery with Observables]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MobX入坑指南(4) -- Utility functions]]></title>
      <url>%2F2016%2F12%2F16%2FMobX-simple-entry-4%2F</url>
      <content type="text"><![CDATA[之前几篇大概介绍了mobx最常用的几个方法，这次准备把剩余的公共方法都介绍了。 autorunAsyncautorunAsync(debugName?: string, action: () =&gt; void, minimumDelay?: number, scope?): disposer autorunAsync 的功能与 autorun 相似，功能都是在观测对象发生变化时自动运行回调函数 action。不同点在于 autorun 是在观测对象发生变化时立即执行的，而 autorunAsync是异步的，可以通过 minimumDelay 参数来指定延迟的时间。如果被观测对象的在延迟过程中发生多次变化，action 也只会在延迟结束时触发一次，所以它和后面要介绍到的 transaction 方法效果类似。在某些场景下这个方法很有用，比如他可以被用来防止频繁向服务端发起请求。 如果传了 scope 参数，那么 scope 将作为 action 运行时的this。 如果传了第一个参数 debugName，那么在调试工具中将使用 debugName 作为调试信息。 和 autorun 一样，autorunAsync 也会返回一个销毁函数。 1234567autorunAsync(() =&gt; &#123; // 我们假设 searchBar.keyword 已经被观测, 是搜索输入框的值。当它发生变化时我们要把它发送到服务端请求搜索结果。 // 如果这里使用autorun，那么每次变化都会向调用sendKeywordToServer。 // 使用autorunAsync延迟300ms发送，当发送时，searchBar.keyword会是这300ms内变化的最终值。 // 这样就可以有效的防止频繁请求造成服务抖动。 sendKeywordToServer(searchBar.keyword);&#125;, 300); Atom类 和 Reaction类Atom有些时候，你可能想要有更多的数据结构或其他的东西(比如streams)，也可以用于响应计算。可以使用 Atom 类简单快速的实现这一功能。Atom 实例可以通知mobx观测对象发生了变化，而mobx会在启用和停用观测对象的时候通知 Atom 实例。 下面的例子展示了 Atom 的全部功能，这个例子展示了如何创建一个时钟，这个时钟只有在被观测时才会运行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import &#123;Atom, autorun&#125; from "mobx";class Clock &#123; atom; intervalHandler = null; currentDateTime; constructor() &#123; // 创建一个Atom实例 this.atom = new Atom( // 第一个参数: Atom实例的名字, 调试用的 "Clock", // 第二个参数（可选）: 从不被监听到被监听时的回调函数. () =&gt; this.startTicking(), // 第三个参数（可选）: 从被监听到不被监听时的回调函数 // 注意，atom实例会多次在这两种状态见转换 () =&gt; this.stopTicking() ); &#125; getTime() &#123; // 如果Atom实例被响应函数调用，则reportObserved返回true。 // 同时，reportObserved会通知mobx这个实例在响应回调中被使用了，它还会触发实例的第二个参数（startTicking） if (this.atom.reportObserved()) &#123; return this.currentDateTime; &#125; else &#123; // 当没有响应函数调用Atom实例的时候，就不会触发startTicking。 // 根据不同的情况，这里也可以做不同的处理，比如抛出一个错误，返回一个默认值等等。 return new Date(); &#125; &#125; tick() &#123; this.currentDateTime = new Date(); // 通知mobx当前值发生了变化 this.atom.reportChanged(); &#125; startTicking() &#123; this.tick(); // 初始化时钟 this.intervalHandler = setInterval( () =&gt; this.tick(), 1000 ); &#125; stopTicking() &#123; clearInterval(this.intervalHandler); this.intervalHandler = null; &#125;&#125;const clock = new Clock();const disposer = autorun(() =&gt; console.log(clock.getTime()));// ... 每秒打印时间disposer();// 停止打印。如果没有响应函数调用当前clock实例，那么时钟将停止。会触发stopTicking函数。 Reaction使用 Reaction 可以创建一个自定义的监听器。Reaction 接受一个函数作为参数，他会分析这个函数所依赖的被观测对象，然后追踪他们，当他们发生变化时发出事件。 下面的例子展示了 autorun 是如何用 Reaction 实现的，其实这个例子我没看太懂，貌似必须调用 Reaction 的track方法才能追踪并发出信号，但是例子中是在 Reaction 接收的函数中调用，然后runReaction的时候开始，具体的得等我翻了源码之后才能知道了…… 12345678910111213141516export function autorun(view: Lambda, scope?: any) &#123; if (scope) view = view.bind(scope); const reaction = new Reaction(view.name || "Autorun", function () &#123; this.track(view); &#125;); // 开始或者排入队列 if (isComputingDerivation() || globalState.inTransaction &gt; 0) globalState.pendingReactions.push(reaction); else reaction.runReaction(); return reaction.getDisposer();&#125; createTransformercreateTransformer(transformation: (value: A) =&gt; B, onCleanup?: (result: B, value?: A) =&gt; void): (value: A) =&gt; B createTransformer 可以将一个转换函数（可以将一个值转换为另一个值得函数，比如数组的map方法接收的函数）包装成一个可缓存的响应函数。换句话说, 如果参数transformation接收到一个值A，然后把A转化为了B，那么以后再接收到A，它就会把缓存的B返回。如果A发生了变化，那么transformation会重新计算更新B。如果没有响应函数引用这个转换函数了，那么他将自动清除自己的缓存。 使用 createTransformer 可以方便的对一个完整的数据结构进行转换（原文：it is very easy to transform a complete data graph into another data graph，我个人理解是，作者想表达这种转换方式对图这种数据结构会特别有效……）。转换函数还可以进行嵌套，这样你就可以用很多小的转换函数碎片组成一个树状结构，描述更复杂的模型。最终组成的数据模型不会过期，他会一直与组成他的转换函数碎片保持同步。这个特性能让mobx很容易实现一些强大的功能，比如sideways data loading（react的一个概念，将数据直接推送给某些具体的组件，而非从父级层层传递，数据加载后基本上无需从底层刷新app，而是刷新若干组件中某个具体的部分）、map-reduce（仿佛说的是谷歌三宝之一的MapReduce架构……map-reduce与js相关的资料我没有查到，具体MapReduce的介绍可以看这里）、追踪不可变对象变更历史，等等。 onCleanup 参数会在转换函数不再被使用时被调用，可以用来销毁资源。 转换函数需要用响应函数包装才能起作用，比如放在 @observer 或者 autorun 里。和其他的计算属性一样，如果不再有观察者调用，转换函数也将退好为惰性的，不会自动执行，以保证程序的性能。 上面说的各种概念可能会比较难理解，下面列出了两个例子来解释之前的概念: 追踪数据变化，分享数据结构这个例子是从这里来得（我能从中看出追踪数据状态来，但是分享数据结构没看出来……）: 12345678910111213141516171819202122232425262728293031/* store用来保存boxes和arrows*/const store = observable(&#123; boxes: [], arrows: [], selection: null&#125;);/** states列表用来保存序列化之后的store历史状态*/const states = [];autorun(() =&gt; &#123; states.push(serializeState(store));&#125;);const serializeState = createTransformer(store =&gt; (&#123; boxes: store.boxes.map(serializeBox), arrows: store.arrows.map(serializeArrow), selection: store.selection ? store.selection.id : null&#125;));const serializeBox = createTransformer(box =&gt; (&#123;...box&#125;));const serializeArrow = createTransformer(arrow =&gt; (&#123; id: arrow.id, to: arrow.to.id, from: arrow.from.id&#125;)); 在这个例子中，states中的每个state的序列化，由三个不同的转化函数完成。autorun触发store的序列化，进而序列化所有的boxes和arrows。 让我们用一个假设的例子来看看执行的过程。假设我们往store.boxes中添加一个box，我们叫他box#3。 首先box#3会被 map 方法传入 serializeBox 函数，serializeBox 函数执行将其序列化并将结果添加进自己的缓存列表。 当另一个box别添加进store.boxes，将导致 serializeState 函数重新计算结果，从而产生一个全新的boxes列表。在这个过程中，对于已存在的值，serializeBox都将从缓存列表返回旧值，这样转换函数就不需要再次运行了。 然后，如果有人更改box#3属性，这将导致 serializeBox 重新计算box#3的值。转换函数将产生一个新的box#3的Json对象，所有订阅了这个转换函数的观察者都将再次运行。这个例子中 serializeState 会自动执行。serializeState将产生新值，映射所有的box的。除了box#3，其他所有box的值都将会从缓存列表返回。 最后，如果box#3从 store.boxes 中移除，serializeState 也将重新计算。serializeBox 不再监听box#3，监听它的响应函数也将退化为非响应模式。serializeBox 的缓存列表中也将移除box#3的缓存。 上面的例子中，我们使用不可变的状态跟踪有效的取得了状态变化列表,共享了数据结构。所有box和arrow都会被转化为简单状态树。每次计算的都会给states 中添加一条新的数据。不同的数据之间将共享box和arrow。 将一个数据结构转换为一个可响应的数据结构 这段儿我都看懵逼了……纯凭感觉理解的……下面贴上原文对比着看吧 Instead of returning plain values from a transformation function, it is also possible to return observable objects. This can be used to transform an observable data graph into a another observable data graph, which can be used to transform… you get the idea. 转换函数除了可以返回一般数据类型，还可以返回观测对象。所以也可以使用转换函数完成可观测对象间的转换。 Here is a small example that encodes a reactive file explorer that will update its representation upon each change. Data graphs that are built this way will in general react a lot faster and will consist of much more straight-forward code, compared to derived data graph that are updated using your own code. See the performance tests for some examples. 下面是个自动响应的文件管理器的例子。使用这种方式构建的数据结构，形式上更加简单直接，数据更新时响应速度也比一般的方式快的多。可以看一看这些例子的性能测试。 Unlike the previous example, the transformFolder will only run once as long as a folder remains visible; the DisplayFolder objects track the associated Folder objects themselves. 不像之前的例子，如果文件夹一直可见，那么 transformFolder 只会运行一次；DisplayFolder 对象会追踪 Folder 对象的变化。 In the following example all mutations to the state graph will be processed automatically. Some examples: 下面的例子中，所有对 state 的改变都会自动处理。比如做如下操作： Changing the name of a folder will update it’s own path property and the path property of all its descendants. 改变文件夹的名字将更新它和它的子文件夹的文件路径， Collapsing a folder will remove all descendant DisplayFolders from the tree. 折叠一个文件夹将会移除所有子文件夹的DisplayFolder实例 Expanding a folder will restore them again. 展开文件夹时，子文件夹再都恢复回来 Setting a search filter will remove all nodes that do not match the filter, unless they have a descendant that matches the filter. 如果设置了搜索过滤条件，将会只保留符合条件的子文件夹，其他的都会移除掉。…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123;extendObservable, asFlat, observable, createTransformer, autorun&#125; from mobx;function Folder(parent, name) &#123; this.parent = parent; extendObservable(this, &#123; name: name, children: asFlat([]), &#125;);&#125;function DisplayFolder(folder, state) &#123; this.state = state; this.folder = folder; extendObservable(this, &#123; collapsed: false, name: function() &#123; return this.folder.name; &#125;, isVisible: function() &#123; return !this.state.filter || this.name.indexOf(this.state.filter) !== -1 || this.children.some(child =&gt; child.isVisible); &#125;, children: function() &#123; if (this.collapsed) return []; return this.folder.children.map(transformFolder).filter(function(child) &#123; return child.isVisible; &#125;) &#125;, path: function() &#123; return this.folder.parent === null ? this.name : transformFolder(this.folder.parent).path + "/" + this.name; &#125; &#125;);&#125;var state = observable(&#123; root: new Folder(null, "root"), filter: null, displayRoot: null&#125;);var transformFolder = createTransformer(function (folder) &#123; return new DisplayFolder(folder, state);&#125;);autorun(function() &#123; state.displayRoot = transformFolder(state.root);&#125;); exprexpr(worker: () =&gt; void) expr 可以在计算属性的函数中创建一个临时的计算属性，其实就是computed(func).get()。作者在文档中说设计这个api的意图是为了提升计算属性的性能，比如下面的例子，如果使用 expr 替代直接用比较运算，可以利用计算属性的缓存，减少运算次数。 1234const TodoView = observer((&#123;todo, editorState&#125;) =&gt; &#123; const isSelected = mobx.expr(() =&gt; editorState.selection === todo); return &lt;div className=&#123;isSelected ? "todo todo-selected" : "todo"&#125;&gt;&#123;todo.title&#125;&lt;/div&gt;;&#125;); extendObservableextendObservable(target: object, ...properties: object) 在之前的几篇文章中，我们已经大概见过 extendObservable 应用的实例了。 extendObservable 和 Object.assign 类似，接受多个参数，将 properties 上所有的键值对，都合并到 target 上，同时把它们都转换成可观测的属性。 如果属性值是一个没有参数的函数，那 extendObservable 将用 computed 把它转化为一个计算属性。 所以，observable(object) 其实是 extendObservable(object, object)的别名。 1234567891011121314var Person = function(firstName, lastName) &#123; // 在当前实例为观测对象 extendObservable(this, &#123; firstName: firstName, lastName: lastName &#125;);&#125;var matthew = new Person("Zheng", "Xingcheng");// 向观测对象上添加属性extendObservable(matthew, &#123; age: 30&#125;); isObservableisObservable(testValue:object, propertyName?: string) isObservable 是用来判断一个变量是不是用observable观测对象的，如果是就会返回true，如果想看变量的某个属性是否可观测，直接传入属性的引用是不行的，需要传第二个参数 propertyName 指定要判断哪个属性，如果属性可观测，就返回true 1234567891011var person = observable(&#123; firstName: "Zheng", lastName: "Xingcheng"&#125;);person.age = 30;console.log(isObservable(person)); // trueconsole.log(isObservable(person, "firstName")); // trueconsole.log(isObservable(person.firstName)); // false (just a string)console.log(isObservable(person, "age")); // false 为了细化各种类型的判断，mobx还提供了map，array，object三种类型的判断，比起 isObservable ，他们的判断标准更严格，如果类型不符合就会返回false。 isObservableMapisObservableMap(testValue:object) 如果testValue是用 mobx.map 创建的对象，则返回true。 isObservableArrayisObservableArray(testValue:object) 如果testValue是用 mobx.observable(array) 创建的对象，则返回true。 isObservableObjectisObservableObject(testValue:object) 如果testValue是用 mobx.observable(object) 创建的对象，则返回true。 12345678910var testValue = observable(&#123; arr: [1, 2, 3], obj: &#123; x: 1 &#125;, map: map([['y',2]])&#125;);console.log(isObservableMap(testValue.map)); // trueconsole.log(isObservableArray(testValue.arr)); // trueconsole.log(isObservableObject(testValue.obj)); // true modifiersintercept &amp; observereactionspyspy(listener) spy 可以注册一个全局的监听函数，监听所有的mobx发出的事件，通常是用来做log或者做调试的。 比如以下例子，会打印所有的action： 12345spy((event) =&gt; &#123; if (event.type === 'action') &#123; console.log(`$&#123;event.name&#125; with args: $&#123;event.arguments&#125;`) &#125;&#125;) 不同的操作，event也会不一样，下面的表格是每种事件对应的参数： event event带的属性 是否可以嵌套发生 action name, target (scope), arguments, fn (source function of the action) yes transaction name, target (scope) yes scheduled-reaction object (Reaction instance) no reaction object (Reaction instance), fn (source of the reaction) yes compute object (ComputedValue instance), target (scope), fn (source) no error message no update (array) object (the array), index, newValue, oldValue yes update (map) object (observable map instance), name, newValue, oldValue yes update (object) object (instance), name, newValue, oldValue yes splice (array) object (the array), index, added, removed, addedCount, removedCount yes add (map) object, name, newValue yes add (object) object, name, newValue yes delete (map) object, name, oldValue yes create (boxed observable) object (ObservableValue instance), newValue yes toJStoJS(value: any, supportCycles?=true: boolean) toJS可以将一个observableObject下的转化为javascript原生的对象。他会递归转换array，object，map和基础类型的值，但是不会转换计算属性和其他不可枚举的值。默认情况下，toJS会缓存下每次运行的值，貌似作者设计这个api就是为了输出log用的，可以设置 supportCycles 参数为false来提高toJS的性能。 对于更复杂的序列化反序列化场景，mobx的作者推荐使用他开发的serializr库。 transactiontransaction(worker: () =&gt; void) 在之前的 autorunAsync 有提到过，除了 autorunAsync ，还可以使用 transaction 来做批量处理。 transaction 用来批处理一系列的更新，而不会通知观测对象，当所有更新结束，才会发出通知。transaction 接收一个没有参数的worker函数作为参数，在这个函数执行完成之前，不会通知观察者。transaction 的返回值就是worker函数的返回值。另外 transaction 是同步的，可以被嵌套，只有最外层的 transaction 执行完，才会触发响应。 123456789101112131415import &#123;observable, transaction, autorun&#125; from "mobx";const numbers = observable([]);autorun(() =&gt; console.log(numbers.length, "numbers!"));// Prints: '0 numbers!'transaction(() =&gt; &#123; transaction(() =&gt; &#123; numbers.push(1); numbers.push(2); &#125;); numbers.push(3);&#125;);// Prints: '3 numbers!' untrackeduntracked(fn: () =&gt; void) 使用 untracked 可以创建一个不被观测的代码块，通常 untracked 需要放在 (@)action 里面才有意义，比如以下的例子： 123456789101112131415161718192021const person = observable(&#123; firstName: "Michel", lastName: "Weststrate"&#125;);autorun(() =&gt; &#123; console.log( person.lastName, ",", // person.firstName放在了untracked的回调里面，所以不会跟这个autorun的监听函数绑定到一起 // 在修改person.firstName时就不会触发这个监听函数 untracked(() =&gt; person.firstName) );&#125;);// prints: Weststrate, Michelperson.firstName = "G.K.";// doesn't print!person.lastName = "Chesterton";// prints: Chesterton, G.K. whenwhen(debugName?, predicate: () =&gt; boolean, effect: () =&gt; void, scope?) when 会感测并运行参数predicate，predicate有点类似一个计算属性，当predicate为true的时候，则自动运行effect，然后销毁自己。所以 when 是一个只运行一次的 autorun。 下面这个例子展示了用 when 来实现自动销毁组件的功能： 123456789101112131415161718class MyResource &#123; constructor() &#123; when( // 当断言为真... () =&gt; !this.isVisible, // ... 则运行一次然后销毁 () =&gt; this.dispose() ); &#125; @computed get isVisible() &#123; // 返回组件是否可见 &#125; dispose() &#123; // 销毁组件 &#125;&#125; 总结本篇整理了下mobx的公共方法和作用。就此，基础api算是都介绍完了。之后会再着重写些使用方法和介绍mobx原理的内容。 话说最近懒癌又开始发作了……_(:3 」∠)_……看着朋友们跟打了鸡血一样写那么多blog好着急的说……希望以后能迎头赶上吧……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MobX入坑指南(3) -- Observable Types]]></title>
      <url>%2F2016%2F12%2F09%2FMobX-simple-entry-3%2F</url>
      <content type="text"><![CDATA[这周阅读了一部分mobx的源码，和作者写的几篇介绍文章，发现这个库有些特性还挺有趣的。以下的内容大部分翻译自mobx文档中 Observable Types 一节，奈何小生英文水平有限，没有划词软件帮忙就看不懂句子……所以翻的很渣，基本上都是掺杂了一些我的理解在里边，连蒙带猜拼出来的，有啥写的不对的，也请多指教了~(￣▽￣)~* 在mobx中，如果你想监听某个变量的变化，需要先使用 observable 函数将其转化为生成Observable对象才行。这个章节主要讲的是 observable 函数生成的不同Observable对象 Observable Objects当 observable 函数接受的参数是个普通的javascript object（普通javascript对象是指不是通过构造函数生成的对象，mobx的判断方式是，通过getPrototypeOf获取原型，检查是不是Object.prototype或者null）时，这个对象中的所有属性都将被传入 observable 函数进行转换，如果属性值是object或者array，则会递归的转化内部的元素。 123456789101112131415161718192021222324252627282930313233import &#123;observable, autorun, action&#125; from "mobx";var person = observable(&#123; // 常量会自动使用observable转化: name: "John", age: 42, showAge: false, // 有get描述符的属性会自动使用computed转化: get labelText() &#123; return this.showAge ? `$&#123;this.name&#125; (age: $&#123;this.age&#125;)` : this.name; &#125;, // 如果直接写 // labelText: function () &#123; // return this.showAge ? `$&#123;this.name&#125; (age: $&#123;this.age&#125;)` : this.name; // &#125; // 在自动转化时会报一个warning，mobx认为渲染函数需要用computed显式调动一下 // labelText: computed(function () &#123; // return this.showAge ? `$&#123;this.name&#125; (age: $&#123;this.age&#125;)` : this.name; // &#125;) // 同理，action也需要显式调动一下: setAge: action(function(age) &#123; this.age = age; &#125;)&#125;);autorun(() =&gt; console.log(person.labelText));person.name = "Dave";// 'Dave'person.setAge(21);console.log(person.age);// 21 需要注意的点： 当对象传入 observable 函数时，只有当时对象上已经存在的属性才能被监听，后添加的属性是不能的，如果想要往已经生成的Observable对象上添加属性，需要使用extendObservable函数进行类似merge的操作。 123456//接上面的例子extendObservable(person, &#123; sex: 'male'&#125;);console.log(person.sex);// 'male' 只有普通对象能够被转化为Observable对象。使用构造函数创建的对象，需要在构造函数初始化时使用extendObservable函数合并属性。使用类创建的对象，需要使用 @observable装饰器包装类的属性。 123456789101112131415161718192021var Person = function(firstName, lastName) &#123; // 在一个新的对象里写要监听的属性，然后merge和当前实例merge extendObservable(this, &#123; firstName: firstName, lastName: lastName &#125;);&#125;var zxc = new Person("Zheng", "Xingcheng");// 或者class Person &#123; @observable firstName:string = ""; @observable lastName:string = ""; constructor(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125;var zxc = new Person("Zheng", "Xingcheng"); 带有get描述符的属性会自动被@computed转化，第一个例子中已经展示了。 如果对象的属性值是一个构造函数生成的对象（我真是不想把它叫成”非普通对象”……），那这个属性也不会被 observable 函数自动转化。 基本上使用observable 函数自动转化已经能解决绝大部分的使用场景了（原文写的是”95% of the cases”……）。如果想要了解更详细的设定每个属性的方法，请看 modifiers 一章（本来这一章的内容也想发到这里的，但是实在是没时间写了只能拉倒……等下次吧）。 Observable Arrays和 object 类似，array 也可以使用 observable函数转化为ObservableArray对象。当然，也是递归转化每个元素的，所以数组的所有元素也会被转化。 123456789101112131415161718192021222324import &#123;observable, autorun&#125; from "mobx";var todos = observable([ &#123; title: "吃午饭", completed: true &#125;, &#123; title: "喝咖啡", completed: false &#125;]);autorun(() =&gt; &#123; console.log("代办:", todos .filter(todo =&gt; !todo.completed) .map(todo =&gt; todo.title) .join(", ") );&#125;);// '代办: 喝咖啡'todos[0].completed = false;// '代办: 吃午饭, 喝咖啡'todos[2] = &#123; title: "睡午觉", completed: false &#125;;// '代办: 吃午饭, 喝咖啡, 睡午觉'todos.shift();// '代办: 喝咖啡, 睡午觉' 由于ES5中原生数组的限制（array.observe到ES7中才有，而且数组不能扩展），observable函数基于原始数组克隆了一个新的数组，这个新数组支持所有原生数组的方法和功能，同时还有监听值变化的能力。 不过，当使用Array.isArray检查包装后数组时返回的是false。所以在跟其他库联合使用时，如果想把ObservableArray对象当做数组传递给其他库，最好使用浅拷贝生成新数组，或者使用 array.slice 方法生成新数组，就是说 Array.isArray(observable([]).slice()) 返回的是true。 由于不喜欢原生的 array.sort 和 array.reverse 方法，ObservableArray对象的 sort 和 reverse 方法是并不会改变自身的，而是返回一个新的ObservableArray对象。 除了原生数组支持的方法，ObservableArray对象还可以使用以下的方法： intercept(interceptor)这个方法可以在所有数组的操作被应用之前，将操作拦截。具体的请看observe &amp; intercept observe(listener, fireImmediately? = false)这个方法可以监听数组的变化，回调函数会接收数组新增或者修改的元素，符合ES7的规范。这个方法返回一个注销函数用来停止监听。 clear()清空数组。 replace(newItems)替换数组里的所有元素。 find(predicate: (item, index, array) =&gt; boolean, thisArg?, fromIndex?)使用方法与ES7的 array.find 一致，但是增加了formIndex参数。 remove(value)移除数组中第一个值等于value的元素，如果移除成功会返回true。 peek()与 slice 类似，会返回一个包含所有元素的数组。它与 slice 的区别在于 peek 不会进行保护性拷贝，所以性能更好。 Observable Mapsobservable(asMap(values?, modifier?)) 和 map(values?, modifier?)) 方法可以创建一个ObservableMap对象。如果你不想响应特定属性的变化，还要添加删除属性，那么使用ObservableMap对象很合适。不同于ES6的Map对象，ObservableMap对象是能用字符串当做key。 根据ES6 Map的规范，可以使用以下方法: has(key)返回map中是否存在这个key，这个方法是可被监听的 set(key, value)设置key对应的value，如果key之前不错在，那么这个key会被添加上 delete(key)删除key和key对应的value get(key)获取key对应的value，如果没找到会返回undefined keys()获取map的所有key，顺序为key的插入顺序 values()获取map的所有key对应的value，顺序为key的插入顺序 entries()返回一个数组，数组中每个元素为一个数组，数组中的元素为map中的key/value对，形式如[key, value]，顺序为key的插入顺序 forEach(callback:(value, key, map) =&gt; void, thisArg?)对map中的每个key/value对调用回调 clear()清除map中的所有key/value对 size()返回map中所有key/value对的数量 ObservableMap对象还提供了以下方法可以使用: toJS()返回一个map的浅拷贝的对象，如果想获得深拷贝的对象，需要使用 mobx.toJS(map) intercept(interceptor)注册一个拦截器，拦截器会在map被修改之前被触发。具体的请看observe &amp; intercept observe(listener, fireImmediately?)注册一个监听，map被修改时会被触发。与Object.observe类似。具体的请看observe &amp; intercept merge(object | map)将对象上所有的属性拷贝到当前map中 Primitive (常量）在javascript中，常量是不可变的，所以也没办法观测。所以如果想要监听一个常量属性的变化，需要使用 observable 函数包装一下。 observable 函数包装后会返回一个ObservablePrimitive对象。这个对象使用get和set方法来获取和改变变量的值。可以使用 .observe 方法来监听值的变化。不过通常使用 mobx.autorun 是更好的选择。 以下是ObservablePrimitive支持的方法： get()返回当前值 set(value)替换当前存储的值，并通知所有的监听器 intercept(interceptor)注册拦截器，当值发生变化前触发。具体的请看observe &amp; intercept observe(callback: (newValue, previousValue) =&gt; void, fireImmediately = false)注册监听器，当值发生变化时触发，返回一个注销函数。具体的请看observe &amp; intercept 12345678910111213import &#123;observable&#125; from "mobx";const cityName = observable("Vienna");console.log(cityName.get());// 'Vienna'cityName.observe(function(newCity, oldCity) &#123; console.log(oldCity, "-&gt;", newCity);&#125;);cityName.set("Amsterdam");// 'Vienna -&gt; Amsterdam' References (引用类型）之前在ObservableObject中提到，observable在转换时会自动用computed包装函数，这个自动转换其实是由限制条件的。mobx只会转换渲染用的函数，既函数不能接受参数，如果接受参数，则认为这个是一个复合函数，就不会自动转化。同样的，如果对象中有属性是通过构造函数或者类创建的对象，也不会自动转化。他们都继续保持着转化之前的引用。 有时我们也会有这一类的需求，要求对象中某个属性不被自动转化。可以使用 asReference 来达到这一目的。 12345678910111213141516var test = observable(&#123; x : 3, doubler: function() &#123; return this.x*2; &#125;, someFunc: asReference(function() &#123; return this.x; &#125;)&#125;);console.log(test.doubler);// 6console.log(test.someFunc);// function() &#123;// return this.x;// &#125; 总结总体感觉上，mobx的api和knockout的api很像，但是在实现原理上，更像rx。mobx实现监听变化调用回调的过程是同步的，通过这种方式就能会自动的分析各个变量间的调用关系，从而减少重复订阅的情况。同时计算最新的值时还是用了memoizing技术，这样就算调用频繁，性能上也能得到保证。 相关文章 Observable Objects Observable Arrays Observable Maps Primitive values and references]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MobX入坑指南(2) -- action]]></title>
      <url>%2F2016%2F11%2F29%2FMobX-simple-entry-2%2F</url>
      <content type="text"><![CDATA[上一篇简单介绍了下mobx常用的几个api(observable、computed、autorun)，以及mobx-react的api(observer)。这次说说action。 action用法： action(fn) action(name, fn) @action classMethod @action(name) classMethod @action boundClassMethod = (args) =&gt; { body } @action(name) boundClassMethod = (args) =&gt; { body } 之前的例子里使用了回调的方式来触发响应，mobx其实也支持使用flux的方式来出发响应，并且在2.2版本提供了action的功能。 action是一个工厂函数，可以接受name和fn两个参数，name是String，主要描述action的作用，fn是Function，是这个action的具体逻辑。action执行后返回一个函数，调用这个函数就会执行action，其实就是调用fn参数。 个人感觉在mobx中，action的作用更多的是用来注释当前的操作……使用的时候在name参数上写操作是干啥的，能够快速的了解action的意图。当然如果安装了devtools，action还能输出调试信息。 需要注意的是，如果使用useStrictapi开启了严格模式，就必须通过action才能修改状态(state)，直接修改值会报错。 举个🌰 123456789101112131415161718192021222324import &#123;observable, useStrict, action, computed, autorun&#125; from 'mobx';useStrict(true);let numbers = observable([1,2,3]);let sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, 0));let disposer1 = autorun(() =&gt; console.log(`sum:$&#123;sum.get()&#125;`));// sum:6let disposer2 = autorun(() =&gt; console.log(`length:$&#123;numbers.length&#125;`));// length:3var pushNumber = action('push number',()=&gt;&#123; numbers.push(4)&#125;)pushNumber(4)// sum:10// length:4numbers.push(5)// Uncaught Error: [mobx] Invariant failed: It is not allowed to create// or change state outside an `action` when MobX is in strict mode. Wrap// the current method in `action` if this state change is intended. 另外，action在执行时是可以接受参数的，而且action在执行后还会返回fn参数的返回值，这一点文档里没有明显的说明，害的我翻源码才翻出来的……┑(￣Д ￣)┍……话说mobx是用typescript写的呢。虽然ts最近很火，而且功能也确实挺实用的，但是我对java一样死板的语法却怎么都都爱不起来……所以更看好WebAssembly一些…… 扯远了扯远了……那么我们再把上面那个例子修改一下： 123456789101112131415161718import &#123;observable, useStrict, action, computed, autorun&#125; from 'mobx';useStrict(true);let numbers = observable([1,2,3]);let sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, 0));// sum:6let disposer = autorun(() =&gt; console.log(`sum:$&#123;sum.get()&#125;`));var pushNumber = action('push number',(number)=&gt;numbers.push(number))console.log(`length:$&#123;pushNumber(6)&#125;`)// sum:12// length:4console.log(`length:$&#123;pushNumber(7)&#125;`)// sum:19// length:5 从上面的例子可以看到，传入pushNumber的参数最后被传入了action的fn中，然后pushNumber返回了push的返回值。 官方文档中的一个例子也能看到调用action返回函数时传递参数的应用场景： 1234567891011121314151617@action createRandomContact() &#123; this.pendingRequestCount++; superagent .get('https://randomuser.me/api/') .set('Accept', 'application/json') .end(action("createRandomContact-callback", (error, results) =&gt; &#123; if (error) console.error(error); else &#123; const data = JSON.parse(results.text).results[0]; const contact = new Contact(this, data.dob, data.name, data.login.username, data.picture) contact.addTag('random-user'); this.contacts.push(contact); this.pendingRequestCount--; &#125; &#125;));&#125; 在这个🌰中可以看到，action的返回值作为superagent.end的回调，接收error和results两个参数，最后传入fn进行处理。这个例子也引出了另一个问题，action中如何处理一步操作。 async action 和 runInActionaction只能影响正在运行的函数，而无法影响当前函数调用的异步操作。也就是说如果fn中有setTimeout，promise.then，async函数，并且这些函数的回调里对state进行了修改，那么这些回调也应该用action包装一下（在非严格模式下，action和直接修改state值都能生效，所以并不会出现异常，如果是严格模式下就会报错）。 还有，如果要使用async函数作为action，不能直接用action包装async函数，这里需要使用一个tricky，将一个async匿名函数赋值给一个变量或者属性再做包装。 12345678@action updateDocument = async () =&gt; &#123; const data = await fetchDataFromUrl(); /* required in strict mode to be allowed to update state: */ runInAction("update state after fetching data", () =&gt; &#123; this.data.replace(data); this.isSaving = true; &#125;)&#125; 上面的例子还用到了runInAction，它其实就是action(name,fn)()的语法糖，调用后action会立即执行，它的用法是：runInAction(name?, fn, scope?)，scope是fn调用时的this指向。注：2.3.0版本以后才能使用。 相关文章 MobX Documentation – action]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React全家桶又填新成员 MobX入坑指南(1)]]></title>
      <url>%2F2016%2F11%2F23%2FMobX-simple-entry-1%2F</url>
      <content type="text"><![CDATA[话说，吐槽被react全家桶坑的文章已经算是各大论坛上的月经贴了吧……行内样式、jsx里html和js混排、依赖太多、学习曲线陡峭……当然其中不乏抱怨redux反人类的…… 当然，这篇文章并不是来黑react不好的，毕竟以后涨工资还得靠它呢哈哈哈(￣▽￣)…… 今天咱们要说的是众多槽点之一，”反人类的redux”和其替代方案。 redux有什么不好？首先，redux绝对是个优秀的库。它体小精悍，api简单优雅，扩展能力强，足以衍生出丰富的工具集和生态系统。在它出现之前，各种flux实现貌似都不能让人如意，以至于有人宁可用 backbone 甚至是 angular 和 react搭配，也不用flux……后来redux出现，解决了flux操作繁琐的问题，开始受到人们的关注，再后来作者也加入了 facebook从事react的开发，redux也顺理成章的成为了react官方推荐状态管理库。 但是，在真正去开发的时候，我发现状态的维护还是有些繁琐，如果你在设计阶段没有考虑周全，开发时就要不停的在action,container,reducer之前修改，穿梭，让人眼花缭乱……嗯，也没准儿是我项目不够大…… 另外，由于redux大量使用函数式编程的思想，门槛有点高呢。当时为了理解redux里面的概念，我大概读了一周的文档…… 按你胃（Anywhere），如果你更熟悉面向对象，羡慕mvvm框架的简单，那你真的应该体验一下mobx mobx是啥？mobx是个新的状态管理库，响应式的，我是看了阮一峰的微博知道的，后来查了资料发现，redux的作者在twitter推荐了这个库，还是作为redex的替代品…… 那么废话少说，让我们现在看看mobx怎么用吧 api简单介绍和redux一样，mobx是一个独立的库，不依赖于react也能自己用，它只有三个概念：观测状态，计算值和反应。这三个概念分别对应三个mobx的api：observable，computed和autorun。 咱们先来个最简单的例子 1234567891011121314151617import &#123; observable, computed, autorun &#125; from 'mobx';let numbers = observable([1,2,3]);let sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, 0));let disposer1 = autorun(() =&gt; console.log(`sum:$&#123;sum.get()&#125;`));let disposer2 = autorun(() =&gt; console.log(`length:$&#123;numbers.length&#125;`));// sum:6// length:3numbers.push(4);// sum:10// length:4disposer2();numbers.push(5);// sum:15 这个例子中，observable用来绑定数据；computed用来绑定计算方法；autorun用来注册数据变化时响应的方法，返回的函数用来取消响应。 下面我们试着来写一个TodoList 12345678910111213141516171819202122232425262728import &#123; observable, computed, autorun &#125; from 'mobx';class Todo &#123; id = Math.random(); @observable content; @observable finished = false; constructor(content) &#123; this.content = content; &#125;&#125;class TodoList &#123; @observable todos = []; @computed get todoListString() &#123; return this.todos.filter(todo =&gt; !todo.finished).map((todo, i) =&gt; `$&#123;i+1&#125;. $&#123;todo.content&#125;`).join('\n'); &#125;&#125;const store = new TodoList();store.todos.push( new Todo("task1"), new Todo("task2"), new Todo("task3"));autorun(() =&gt; console.log(store.todoListString))store.todos[2].finished = true; 从上面的例子可以看到，针对类的属性，可以使用修饰器@observable、@computed来进行绑定，修饰器是ES7的一个提案，目前Babel已经支持。详细的介绍可以看ECMAScript 6 入门中修饰器一章 如果不想用修饰器，也可以使用extendObservable函数，跟修饰器的功能是一样的： 123456789101112131415161718192021222324252627282930313233import &#123; extendObservable, autorun &#125; from 'mobx';class Todo &#123; id = Math.random(); constructor(content) &#123; extendObservable(this, &#123; content: content, finished: false &#125;) &#125;&#125;class TodoList &#123; constructor() &#123; extendObservable(this, &#123; todos: [], todoListString: function() &#123; return this.todos.filter(todo =&gt; !todo.finished).map((todo, i) =&gt; `$&#123;i+1&#125;. $&#123;todo.content&#125;`).join('\n'); &#125; &#125;) &#125;&#125;const store = new TodoList();store.todos.push( new Todo("task1"), new Todo("task2"), new Todo("task3"));autorun(() =&gt; console.log(store.todoListString))store.todos[2].finished = true; mobx-react在跟react配合时，mobx提供了mobx-react包，使用@observer装饰器或者observer函数，可以自动将react组建的render方法包装到mobx.autorun里面。还是以前面的TodoList为例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import &#123; observable, computed &#125; from 'mobx';import &#123; observer &#125; from mobxReact;import &#123; Component &#125; from React;class Todo &#123; id = Math.random(); @observable content; @observable finished = false; constructor(content) &#123; this.content = content; &#125; finish() &#123; this.finished = true &#125;&#125;class TodoList &#123; @observable todos = []; @computed get unFinishedList() &#123; return this.todos.filter(todo =&gt; !todo.finished); &#125; @computed get finishedList() &#123; return this.todos.filter(todo =&gt; todo.finished); &#125; addTodo(content) &#123; if (content)&#123; this.todos.push(new Todo(content)) &#125; &#125;&#125;@observerclass TodoListView extends Component &#123; render() &#123; const &#123; todoList &#125; = this.props; let onChange = (event) =&gt; &#123; this.value = event.target.value &#125; let onClick = () =&gt; &#123; todoList.addTodo(this.value) &#125; return (&lt;div&gt; &lt;h2&gt;添加任务&lt;/h2&gt; &lt;input type="text" value=&#123; this.value &#125; onChange=&#123; onChange &#125;/&gt; &lt;button type="button" onClick=&#123; onClick &#125;&gt;添加&lt;/button&gt; &lt;h2&gt;未完成任务&lt;/h2&gt; &lt;ol&gt; &#123;todoList.unFinishedList.slice(0).map((todo,index) =&gt; &lt;TodoView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt; )&#125; &lt;/ol&gt; Tasks left: &#123;todoList.unFinishedList.length&#125; &lt;h2&gt;已完成任务&lt;/h2&gt; &lt;ol&gt; &#123;todoList.finishedList.map((todo) =&gt; &lt;FinishedView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt; )&#125; &lt;/ol&gt; &lt;/div&gt;) &#125;&#125;const TodoView = observer((props) =&gt;&#123; let &#123; todo &#125; = props; return (&lt;li&gt; &lt;input type="checkbox" checked=&#123;todo.finished&#125; onClick=&#123;todo.finish.bind(todo)&#125; /&gt;&#123;todo.content&#125; &lt;/li&gt;) &#125;);@observerclass FinishedView extends Component&#123; render() &#123; let &#123; todo &#125; = this.props; return (&lt;li&gt; &lt;del&gt;&#123;todo.content&#125;&lt;/del&gt; &lt;/li&gt;) &#125;&#125;const store = new TodoList();React.render(&lt;TodoListView todoList=&#123;store&#125; /&gt;, document.body);store.todos.push( new Todo("Get Coffee"), new Todo("Write simpler code")); 在上面的例子里可以看到，使用mobx-react的不同点只是在编写组件类时observer包装了一下，其他的跟不使用mobx-react没什么区别。另外，如果在stroe里加入方法，就可以做到类似action一样的动作，使用上比redux要简单很多。当然这也引出一个问题，就是当子组件状态变化影响到父组件的状态，如何通知父组件。redux用类似dbus的设计解决了这个问题，mobx怎么解决，我还没有看到，后续看到了再做补充。 简单的总结怎么说呢，总感觉mobx的功能和vue好像……￣ω￣=……特别是computed……这种设计对于写惯了mvc的人来说会感觉非常亲切，stroe其实就是相当于平时常写的model嘛，概念很容易理解。难度上，个人感觉不高，除了一些绑定后的数据需要调用set、get方法，api也不多。 其实mobx还有很多的功能没有介绍到，而且在网上资料也很少，如果有时间的话，打算试着翻译mobx的文档。更多的例子，后续再做详细的补充，今天就先到这里吧，我实在是写不动了……_(:3 」∠)_ 相关文章 MobX Documentation A short introduction to MobX]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浮点数计算为什么不精确]]></title>
      <url>%2F2016%2F11%2F17%2F%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%B2%BE%E7%A1%AE%2F</url>
      <content type="text"><![CDATA[其实这篇博客早就写好了，只不过之前懒一直没有整理完善……哈哈哈…… _(:3 」∠)_ 前几几几几天，在微博上看到寇胖转了一个关于浮点数计算的微博，里面的内容不太准确。正好之前我调查过一些关于浮点数的资料，在这里好好掰吃掰吃，做个记录~(￣▽￣)~* 结论先说结论，嫌又臭又长的看到这里就可以了: 浮点数计算不精确并不是bug，因为标准就是这样的。 原因简单来说是这样：2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。 解决方法：对于需要精确结果的场景，别直接使用浮点数进行计算。现阶段可以使用big.js解决，等以后ecmascript实现decimal了，就可以使用decimal类型计算了。 小数算不准，真的是js的锅吗？说到这个问题，其实这是两个锅，js计算不准确不止会出现在小数的计算上，还会出现在大整数计算上，可以运行下面两行代码查看问题的具体表现： 120.1 + 0.2 == 0.3; // false9999999999999999 + 2 == 10000000000000001; // false 当然，这个锅肯定不是javascript背。事实上，使用了IEEE 754 标准来存储浮点类型的任何编程语言（C/C++/C#/Java 等等）都存在精度丢失问题。 例如在 Java 中，要想算准浮点数，同样不能直接计算，需要使用 BigDecimal 类来进行相应的处理。 当然，javascript也并没有落后于其他语言。ECMAScript 规范中已有 decimal 类型的提案了，但目前尚未被正式采纳。 为什么不算准？要解释这个问题，就得从10进制与2进制的转换说起。 众所周知，计算机做运算是使用二级制的。所以其实咱们在程序中做10进制运算，都是要转换为2进制再进行计算的。10进制整数转换为2进制的方法可能大家都知道： 除以2，商继续除以2，得到0为止，将余数逆序排列例如：22 / 2 11 余 011 / 2 5 余 15 / 2 2 余 12 / 2 1 余 01 / 2 0 余 1所以22的的二进制是10110 那10进制小数转换为2进制的方法呢？ 乘以2，取整，小数部分继续乘以2，取整，得到小数部分0为止，将整数顺序排列0.8125 x 2 1.625 取 10.625 x 2 1.25 取 10.25 x 2 0.5 取 00.5 x 2 1.0 取 1所以0.8125的二进制是0.1101 那么问题就来了，比如你想计算10进制0.2的2进制： 0.2 x 2 0.40.4 x 2 0.80.8 x 2 1.60.6 x 2 1.20.2 x 2 0.4…… 发现了吗？它乘不尽，是无限循环的…… 而 javascript 使用64位双精度浮点数存储数字，类似科学计数法，其中1位用来存储符号，11位用来存储指数值，52位用来存储尾数值（真正的数字），当计算的结果的二进制有效位数超过 52 位时，就会出现精度丢失的问题…… 大整数计算的原因也是一样，有效位数超过 52位时，精度就会丢失 这就解释了下面这种情况： 十进制 0.1 的二进制为 0.0 0011 0011 0011 … （循环 0011）十进制 0.2 的二进制为 0.0011 0011 0011 … （循环 0011） 0.1 + 0.2 相加可表示为： e = -4; m = 1.10011001100…1100（52 位） + e = -3; m = 1.10011001100…1100（52 位）-——————————————– e = -3; m = 0.11001100110…0110 + e = -3; m = 1.10011001100…1100-——————————————– e = -3; m = 10.01100110011…001-——————————————– = 0.01001100110011…001 = 0.30000000000000004（十进制） 但是0.05和0.2用二进制都无法精确表达，0.05 + 0.2 却不会计算错误，0.2 + 0.7 会计算错误，1.2 +1.7 又不会，这又是为什么？ 具体的原因我并没有找到相关的资料…… 貌似这和 IEEE 754 的舍入模式有关系。 IEEE 754 采用的是最近舍入模式，和我们最熟悉的是四舍五入模式有些许不同，也是比较容易引起误解的地方之一。举例比较如下： 最近舍入模式：Round(0.5) = 0; Round(1.5) = 2; Round(2.5) = 2; 四舍五入模式：Round(0.5) = 1; Round(1.5) = 2; Round(2.5) = 3; 既当有两个最接近的可表示的值时首选“偶数”值。 具体的原因我会再调查调查，有了新的资料再补充到这里。 如何解决这个问题？当然，问题的解决方法其实也已经有前人跟咱们铺好路了，毕竟这个在问题在编程领域里其实是个挺常见的问题…… 网上的解决办法五花八门，总的原则就是逐位运算。我推荐 github 上 MikeMcl 开发的 big.js 。这个库不尽支持基础运算，而且还支持各种函数运算和比较运算，相当全面呢。实现上，是将数字按照科学计数法解析成一个包含正负符号、指数、尾数的对象，再做运算。例子就不写了，它的文档很全，而且简单易懂。 有趣的是，这个作者除了 big.js 还开发了另两个计算库 bignumber.js 和 decimal.js，三个库的侧重点不一样，关于这三个的对比，有兴趣的话可以看作者自己写的wiki What is the difference between big.js, bignumber.js and decimal.js? 相关文章: 浮点数为什么不精确？ JavaScript超大整数加法 JavaScript 中小数和大整数的精度丢失 IEEE 754 浮点数的表示精度探讨 IEEE 754]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>%2F2016%2F11%2F16%2F%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
      <content type="text"><![CDATA[哈，距离上次写博客刚好一年了呢，话说我还真是懒呢…… _(:3 」∠)_ 这里不得不感叹下榜样的力量是无穷的。要不是继伟发起每周写博客的活动，估计我现在还在床上躺着呢……读好书，交高人，此言非虚呀~ 总之，希望这是个新的开始，期待能遇见更好的自己~(｡･ω･｡)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Capitan之后JetBrains的产品都不能用了]]></title>
      <url>%2F2015%2F11%2F21%2FCapitan%E4%B9%8B%E5%90%8EJetBrains%E7%9A%84%E4%BA%A7%E5%93%81%E9%83%BD%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86%2F</url>
      <content type="text"><![CDATA[更新了osx升级10.11 EL Capitan之后发现有好多坑啊……限制超多而且JetBrains的产品都不能用了…… 查了一溜够貌似是之前安装的一些系统软件都被清除了，而且还需要接触rootless模式，总之先附上搜索到的资料链接吧 Intellij IDEAやAppCodeが起動しない場合に考えられること（需翻墙）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[邮件链接中加入参数可以给要发送的邮件添加标题和内容，第一次发现唉]]></title>
      <url>%2F2015%2F10%2F21%2F%E9%82%AE%E4%BB%B6%E9%93%BE%E6%8E%A5%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E7%BB%99%E8%A6%81%E5%8F%91%E9%80%81%E7%9A%84%E9%82%AE%E4%BB%B6%E6%B7%BB%E5%8A%A0%E6%A0%87%E9%A2%98%E5%92%8C%E5%86%85%E5%AE%B9%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%91%E7%8E%B0%E5%94%89%2F</url>
      <content type="text"><![CDATA[a标签的href属性值可以是mailto协议的地址，这个比较常见，但是能加参数设置邮件内容我还是第一次见呢。 示例： mailto:xxx@xxx.com?Subject=标题&amp;Body=正文 貌似按照get方式加上参数就行了，Subject代表标题，Body代表正文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[总结下hexo搭建的过程]]></title>
      <url>%2F2015%2F10%2F16%2F%E6%80%BB%E7%BB%93%E4%B8%8Bhexo%E6%90%AD%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[2016-11-16 UPDATE: 距离写下这篇博客已经过了一年了，hexo在这一年里发展的挺快。现在hexo的文档已经齐全，整个工作流程也相当顺畅了。 安装过程中如果 node-gyp 报 error，可以尝试升级xcode，并安装xcode-select 升级 CLT。 下面附上几篇比较好的文章，建站过程中遇到问题可以查阅一下。 Hexo常见问题解决方案收集了很多使用hexo过程中的常见问题 hexo你的博客文章的内容很全，不止写了如何使用hexo，如何使用github，如何找图床等问题也都有描述，如果是使用github pages搭建博客的话，看这篇就够用了 如何搭建一个独立博客——简明Github Pages与Hexo教程和上一篇文章一样，这篇文章的内容也很全面，除了博客的搭建过程，如何在购买域名和服务器也有描述，只不过图片貌似都已经失效了……有些遗憾呢…… 翻译自GitHub Pages的Help页面（仍在更新中）github pages的help页面的翻译，对于英语苦手的人来说，应该会很有帮助吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[总结一下升级OS X El Capitan后brew遇到的问题]]></title>
      <url>%2F2015%2F10%2F15%2F%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%8D%87%E7%BA%A7OS-X-El-Capitan%E5%90%8Ebrew%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[升级了osx之后，先是brew update的时候报错，后来用brew安装jenv的时候又提示说需要root权限 Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo.Error: Failure while executing: /usr/bin/otool -L /usr/bin/install_name_tool 但是sudo brew install又报错 Error: Cowardly refusing to sudo brew installYou can use brew with sudo, but only if the brew executable is owned by root.However, this is both not recommended and completely unsupported so do so at your own risk. 搜了下貌似是新版osx的问题，需要进行权限设置，用chown命令设置一下就好了 以下是一些参考资料 How To Fix Cowardly Refusing to Sudo error in Brew – Mac OS X Failed brew update on El Capitan (OS X 10.11) Beta Mac OS X El Capitan にアップデートした後に brew update が動かない場合の対処方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[啊，我的第一次]]></title>
      <url>%2F2015%2F10%2F14%2Ffirst-love%2F</url>
      <content type="text"><![CDATA[人生第一篇blog，总觉得有点儿小激动呢……⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄ 话说再过生日就30岁了呢，做程序员也是第8个年头，愈发觉得将自己的平时的一些想法、遇到的一些问题记录下来很重要，其实以前也很想，奈何我懒…… 总之，之后会努力多写一些，也算是对自己的一种提升吧，嗯，希望我能一直坚持下去~ &lt;(￣▽￣)&gt; 哈哈哈……]]></content>
    </entry>

    
  
  
</search>
