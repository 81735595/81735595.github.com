<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[javascript中的进程、线程和协程]]></title>
      <url>%2F2016%2F12%2F30%2Fprocess-thread-and-coroutine-in-javascript%2F</url>
      <content type="text"><![CDATA[这周一直在编前端构建的脚本，用到了多进程去解决一个效率问题。期间差了很多进程、线程、协程的资料，在这里记录回顾一下。 概念关于进程、线程、协程的概念这里就不再赘述了，具体的可以参考wiki百科： 进程 线程 协程 简单概括一下它们间的区别就是相对线程和协程，进程更独立，有自己的内存空间，所以进程间通信比较困难。线程比进程轻量级，属于同一进程的多个线程间可以共享全部资源。协程与线程类似，不同点在于，线程由系统控制切换，协程是由用户控制切换。 那么，控制切换，指的是控制什么的切换呢？ 在一个进程中执行的程序，有时需要同时处理多个工作，这时我们可以创建多个线程，让每个线程处理一个工作。但是，进程只有一个。就好比一个人，你给他分配了多个工作，帮他把每个工作单独拉了一个列表，可还是他一个人干，他只能一会儿干干这一会儿干干那，来模拟多个工作同时进行的状态，这就是所谓的系统控制切换，系统不停的在多个线程间切换来达到并行的效果。你可能会说，那根一件一件干不是一样吗？没错，是一样的，在只有一个cpu的电脑上，用不用多线程程序执行的时间是一样的。但是，如果这个人长了两个脑袋呢？那么他就能同时处理两件工作了。多核cpu就是那个长了好多个脑地的人……而协程的切换是要由用户手动来控制的，所以协程并适合并行计算，而更多的用来优化程序结构。 js都支持吗？这要看js在什么环境运行。 在浏览器中，可以通过webworkers创建进程，可以通过async/await，yield/Generator/GeneratorFunction实现协程，控制程序切换。 在node中，除了可以使用上面浏览器中可以使用的方法，还可以通过cluster，child_process创建进程，通过libuv，tagg创建线程 刚才提到的那些都是啥？怎么用？webworkers简单点儿说就是使用webworkers你可以在全新的环境中运行一个你指定的js文件。这个全新的环境是独立的，既一个全新的进程，有点儿像一个新iframe还没有window.top，window.parent属性，哈哈…… webworkers创建的进程和主进程之间可以通过message事件传递消息，但是消息只能是字符串，所以想要传对象和数组就只能传json了……这也是他不方便的地方。 具体使用方法可以看MDN上的文章：使用 Web Workers async/awaitasync/await是es7中新加的两个关键字，async 可以声明一个异步函数，此函数需要返回一个 Promise 对象。await 可以等待一个 Promise 对象 resolve，并拿到结果。 其实就是类似汇编的寄存器和跳转指令……呃，通俗的说就是可以根据状态跳转态另一个函数半中间。 由于es7还未在各个环境实现，想要使用的话还的用一些babel-polyfill之类的库做兼容…… 更详细介绍请看阿阮的文章：异步操作和Async函数 yield/Generator/GeneratorFunctiongenerator是es6中新增的函数，本质是可以将一个函数执行暂停，并保存上下文，再次调用时恢复当时的状态。但是用来解决协程切换的问题貌似有点儿滥用特性的感觉呢…… 更详细介绍请看阿阮的文章：Generator 函数 clustercluster是node官方提供的一个多进程模块，效果和C语言的fork函数类似，当前文件完全重新执行一遍，通过cluster.isMaster判断是不是主进程，在区分不同的操作。进程间通过事件回调来通信，NodeJS 0.6.x 以上的版本开始支持。 示例代码就不放了，node官方文档上写的很详细：cluster child_processnode自带的child_process模块里的fork函数可以实现类似浏览器里webworkers的效果，使用方法和webworker一毛一样，都是通过读取新文件开启新进程，通过message通信。 具体介绍请看文档：child_process.fork(modulePath[, args][, options]) 官方文档没有示例，下面给出一个web服务接收参数计算斐波那契数组的例子： index.js1234567891011121314var express = require('express');var fork = require('child_process').fork;var app = express();app.get('/', function(req, res)&#123; var worker = fork('./work_fibo.js') //创建一个工作进程 worker.on('message', function(m) &#123;//接收工作进程计算结果 if('object' === typeof m &amp;&amp; m.type === 'fibo')&#123; worker.kill();//发送杀死进程的信号 res.send(m.result.toString());//将结果返回客户端 &#125; &#125;); worker.send(&#123;type:'fibo',num:~~req.query.n || 1&#125;);//发送给工作进程计算fibo的数量&#125;);app.listen(8124); work_fibo.js123456789101112131415var fibo = function fibo (n) &#123;//定义算法 return n &gt; 1 ? fibo(n - 1) + fibo(n - 2) : 1;&#125;process.on('message', function(m) &#123;//接收主进程发送过来的消息 if(typeof m === 'object' &amp;&amp; m.type === 'fibo')&#123; var num = fibo(~~m.num); //计算jibo process.send(&#123;type: 'fibo',result:num&#125;) //计算完毕返回结果 &#125;&#125;);process.on('SIGHUP', function() &#123; process.exit();//收到kill信息，进程退出&#125;); libuvlibuv是node底层实现使用的c++库……呃，所以如果你想使用这个库来实现多线程，那么你就得编写c++的代码了，不得不说，要想真正理解程序的本质，不多掌握几门语言真是不行啊…… 对c++不了解我就不瞎BB了，推荐两篇文章延伸阅读： libuv多线程处理的简单示例 利用libuv编写异步多线程的addon实例 taggtagg(Threads a gogo for Node.js)是Jorge Chamorro Bieling开发的一个node包。使用c语言phread库实现的多线程。 还是那刚才的斐波那契数组计算为例： 12345678910var Threads = require('threads_a_gogo');//加载tagg包function fibo(n) &#123;//定义斐波那契数组计算函数 return n &gt; 1 ? fibo(n - 1) + fibo(n - 2) : 1;&#125;var t = Threads.create().eval(fibo);t.eval('fibo(35)', function(err, result) &#123;//将fibo(35)丢入子线程运行 if (err) throw err; //线程创建失败 console.log('fibo(35)=' + result);//打印fibo执行35次的结果&#125;);console.log('not block');//打印信息了，表示没有阻塞 最后结果：12not blockfibo(35)=14930352 我们可以看到执行效果与webworker类似，不同的是通信使用了异步回调的方式。 值得一提的是tagg包目前只能在linux下安装运行，这里再推荐一个tagg2包，是跨平台的。 这里需要重点提一下的是，不论tagg还是tagg2包都是利用phtread库和v8的v8::Isolate Class类来实现js多线程功能的。 Isolate代表着一个独立的v8引擎实例，v8的Isolate拥有完全分开的状态，在一个Isolate实例中的对象不能够在另外一个Isolate实例中使用。嵌入式开发者可以在其他线程创建一些额外的Isolate实例并行运行。在任何时刻，一个Isolate实例只能够被一个线程进行访问，可以利用加锁/解锁进行同步操作。 换而言之，我们在进行v8的嵌入式开发时，无法在多线程中访问js变量，这条规则将直接导致我们之前的tagg2里面线程执行的函数无法使用Node.js的核心api，比如fs，crypto等模块。 延伸阅读： tagg tagg2 总结经过以上的学习，我们大概应该了解到进程、线程、协程的使用场景了，进程、线程适合用来处理计算密集型操作，协程适合用来优化代码结构，解决回调函数嵌套问题。线程比进程更轻，更节省资源，但是由于上面提到的线程问题，针对一些可以使用js原生的大量计算或循环还可以用用，涉及到使用nodejs核心api的操作，就要用进程解决了。 p.s. 我的问题我在工作中使用的是fis配合grunt调用打包。由于要同时打包多个项目，grunt和fis都会定义全局变量，各个模块之间的配置可能会相互影响，各个模块在打包过程中又没有相互的通信，同时为了提高效率，非常时候适合使用多进程的方式来运行脚本。所以用cluster实现了多进程打包的。 最后，祝大家新年快乐，1号胖三斤，3号金三胖~ ┑(￣Д ￣)┍]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[响应式react：构建高效易用的react应用]]></title>
      <url>%2F2016%2F12%2F23%2Fmaking-react-reactive-pursuit-high-performing-easily-maintainable-react-apps%2F</url>
      <content type="text"><![CDATA[这篇文章翻译自mobx作者 Michel Weststrate 的一篇博客，虽然我也想做到信达雅，奈何英语水平有限……所以我写的内容自动屏蔽了一些前因后果没营养的话，只翻译我觉得重点的内容。我的原则是，捞干的说，不BB~想了解细节的话可移步原文 使用react开发应用有啥好处，我想是个前端都能数出个十条八条来。但是如果你的项目需要在浏览器中绘制成千上万的对象，而且这些对象之前还有大量的耦合关系，那维护这些对象也够喝一壶的……mobx作者在发明mobx的时候就面临了这样一个项目，一个对象的值可能被其他对象引用，任何变化都可能引起大量的ui更新和重绘。在一些特殊场景，比如拖拽操作，这些动作还必须在40毫秒响应…… 于是，mobx被开发出来了。简单来说，他使用了函数响应式编程的概念 Observables 来解决上述的问题，其实 mobx 并不是第一个使用这一概念的前端库，ember、knockout还有vue其实都使用了这一概念，我个人感觉，mobx就好像把vue和knockout的数据绑定那部分抽出来然后揉到一起一样……真的能发现很多有相似的地方……使用 Observables 的好处就在于，你可以很容易实现自动更新关联数据和sideways data loading，从而解放生产力，提升应用的性能。后面测试数据一章可以看到具体的对比结果。 下面我们以一个简单的购物应用为例： 里面包含商品列表，购物车，结算等部分。完整的例子可以再jsfiddle上看到（需要翻墙）。 数据模型首先，我们先看下数据模型。商品列表（Articles）里的每个商品，有名称（name）和价格（price）属性，购物车（Cart）有已加入购物车列表（Entries）和总价（Total）属性。已加入购物车列表中的每个商品除了名字和价格属性以外，还有数量属性（amount）、根据数量和单价计算出的总价。数据之间的关系如下图所示。 从上图中我们可以看出，如果对一个数据进行修改，那么就会带动其他的数据修改，同时还得修改ui。大概列一下数据联动的逻辑： 如果商品列表里的商品价格发生改变，购物车里的商品价格也需要更新。 ……购物车的总价也得更新。 如果购物车中商品数量变化，总价也得跟着更新。 如果商品列表里的商品被重命名了，商品列表的界面得更新。 ……购物车里对应的商品也得更新。 如果添加新文章合计购物车…… 作为一个程序员，就是这么闹心……你不得不写大量的代码来处理各种可能的状态，处理速度还得快，让用户老爷等着急了你担待得起吗…… 那么，让我们来看看怎么用mobx来日翻这些问题： 123456789101112131415161718192021222324252627function Article(name, price) &#123; mobx.extendObservable(this, &#123; name: name, price: price &#125;);&#125;function ShoppingCartEntry(article) &#123; mobx.extendObservable(this, &#123; article: article, amount: 1, price: function() &#123; return this.article ? this.article.price * this.amount : 0; &#125; &#125;);&#125;function ShoppingCart() &#123; mobx.extendObservable(this, &#123; entries: [], total: function() &#123; return this.entries.reduce(function(sum, entry) &#123; return sum + entry.price; &#125;, 0); &#125; &#125;);&#125; 使用工具函数包装之后，通过构造函数创建的对象都是可观测的，就是说当对象的某一个属性改变，跟他跟他相关联的属性都会自动更新。这样状态变化就不用我们手动维护了，比如添加商品到购物车时总价的变化、物品的价格发生变化时其他关联项的变化等等。 界面模型建好了，该搭界面了。下面的列了一段购物车组件的代码，包含了显示购物车里的商品列表和总价。其他组件请自行脑补，都差不离的。 1234567891011121314151617181920212223242526var CartView = React.createClass(&#123; render: function() &#123; function renderEntry(entry) &#123; return (&lt;CartEntryView entry=&#123;entry&#125; cart=&#123;this.props.cart&#125; key=&#123;entry.id&#125; /&gt;); &#125; return (&lt;div&gt; &lt;ul id="cart"&gt;&#123;this.props.cart.entries.map(renderEntry)&#125;&lt;/ul&gt; &lt;div&gt;&lt;b&gt;Total: &lt;span id="total"&gt;&#123;this.props.cart.total&#125;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt; &lt;/div&gt;) &#125;&#125;);var CartEntryView = React.createClass(&#123; render: function() &#123; return (&lt;li&gt; &lt;button onClick=&#123;this.removeArticle&#125;&gt;&amp;laquo;&lt;/button&gt; &lt;span&gt;&#123;this.props.entry.article.name&#125;&lt;/span&gt; &lt;span&gt;&#123;this.props.entry.amount&#125;&lt;/span&gt; &lt;/li&gt;); &#125;, removeArticle: function() &#123; if (--this.props.entry.amount &lt; 1) this.props.cart.entries.splice(this.props.cart.entries.indexOf(this.props.entry), 1); &#125;&#125;); 组件写完了，但是没跟模型关联还跑不起来，需要用mobx-react库里的 mobxReact.observer 方法把组件都包装装一下，这就算关联上了： 1234var CartEntryView = mobxReact.observer(React.createClass(&#123; render: function() &#123; return (&lt;li&gt; // etc... 然后，就没有然后……是的，这就算齐活了。让我们看下jsfiddle上的演示。 这里 observer 函数为我们做了两件事。首先，它将组件的 render 函数变成一个可观察到的函数。然后，把组件注册到观察者函数，所以每次 render 需要更新了他都会自动更新。mobxReact.observer（如果你使用ES6的话是 @observer）确保每当数据改变，只更新UI的相关部分，就是刚才上面提到的sideways data loading。你可以自己点点试试，注意看下方的日志面板，看看UI更新的数据，你会发现，每次操作，组件的重绘数量都是最低的。 另外，由于每个组件都只跟踪自己的依赖，通常不需要重新渲染子组件。比如，如果购物车的总价重新渲染了，在不必要的情况下就不会重新渲染购物车里的商品列表。 测试数据东西好不好,主要看疗效。这里你可以找到一个一毛一样的应用，但没有使用mobx，而是简单的使用每次替换数据的方法构建的。只有几个商品，不会感觉到有任何区别，但一旦商品数量上升，就会提现出真正意义上的性能差异。 创建大量的数据和组件的时候，基本没啥差别。但是在修改数据时，强弱立分高下力判。如果在有10000个元素的列表中更新其中10个元素的数据，速度大约快了十倍。2.5秒下降到250毫秒……那么这种差别是从哪里来的呢？让我们来瞅瞅不适用mobx时React的渲染报告： 可以看到，ArticleViews 和 CartEntryViews一共渲染了20000次。2433毫秒的渲染时间中，2145毫秒的渲染时间是被浪费的（Wasted time）。Wasted time的意思是：花费在执行渲染函数上的时间，实际上并没有更新任何一个DOM元素。这有力地说明了，无脑更新是一件很浪费cup资源的，组件越多浪费的时间就越多。 相较之下，这是使用mobx的报告： 重绘的只有31个组件，完全没有一点浪费。就是说每个重新渲染的组件都是确实需要修改的。这正是我们想要实现的效果！ 然而，这样你就满足了吗？我们还可以再进一步优化！ 从报告中我们还可以看出，267毫秒的总体渲染时间里，大部分剩余的渲染时间消耗在CartView的渲染上（243毫秒）。那是在更新购物车的总价属性。值得注意的是，要重新渲染CartView，也就意味着要检查购物车中一万个商品是否有修改，是否要更新CartEntryView。而这就浪费了大部分时间。我们可以把总价再单独做一个控件，CartTotalView。通过这个简单的处理，如果只是总价的变化，就可以跳过CartView的重新渲染。这使得渲染时间进一步下降到约60毫秒（见上图中的灰色那一条），这比没有使用Mobx的React应用大约快了40倍! 总结好的，通过上面的例子我们看到了使用mobx和不使用mobx在性能上的区别。这里还需要强调的一点是，使用了mobx还有一个优势，就是不会影响代码的可维护性，对于程序员来说，这点很重要，就算有万般好处，如果代码写出来像屎一样难看，也不会有人想用对吧？在jsfiddle里面可以看到两个例子的完整程序。两段代码基本没啥太大的区别……┑(￣Д ￣)┍ 那么，我们可以用其他技术达到相同的效果吗？也许吧。例如，使用ImmutableJS也能做到sideways data loading。然而，就像我刚才说的，有可能你会收获一坨是一样的代码……毕竟，恕我直言，相对于不可变对象，可变类使用起来会更方便一些。此外，不可变的数据结构不能帮助你保持计算属性。如果使用不可变数据，改变商品的名字ArticleView会重新渲染的很快，但是CartEntryView中引用的相同商品实例就会失效。 另一种优化React应用的方案是为每一个可能发生的操作创建事件，然后在管理这些事件，在恰当的时机恰当的地点（组件）触发（注销）它们。但这将导致编写大量的样板式代码，维护起来相当困难。我不知道人啊，反正我是懒得弄这些……（哥你是不是不会断句……这段看的好纠结啊……） 顺便说一下，我强烈建议使用action来抽象对模型的更新，这样能有效的做到表现和行为分离。 最后，在大型项目中使用mbox配合React是非常好用的。有时我看到数据变化时，界面上某个角落也跟着更新了，我自己都惊呆了……而且还没有任何性能问题，你说气人不……(￣▽￣)”……心动不如行动，让我们把繁重的维护工作都丢给React和Mobx，敬请享受更轻松有趣的coding吧~！ 相关文章 MobX library React performance guide Shopping cart demo, React with Observables Shopping cart demo, React without Observables Shopping cart demo, JQuery with Observables]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MobX入坑指南(4) -- Utility functions]]></title>
      <url>%2F2016%2F12%2F16%2FMobX-simple-entry-4%2F</url>
      <content type="text"><![CDATA[之前几篇大概介绍了mobx最常用的几个方法，这次准备把剩余的公共方法都介绍了。 autorunAsyncautorunAsync(debugName?: string, action: () =&gt; void, minimumDelay?: number, scope?): disposer autorunAsync 的功能与 autorun 相似，功能都是在观测对象发生变化时自动运行回调函数 action。不同点在于 autorun 是在观测对象发生变化时立即执行的，而 autorunAsync是异步的，可以通过 minimumDelay 参数来指定延迟的时间。如果被观测对象的在延迟过程中发生多次变化，action 也只会在延迟结束时触发一次，所以它和后面要介绍到的 transaction 方法效果类似。在某些场景下这个方法很有用，比如他可以被用来防止频繁向服务端发起请求。 如果传了 scope 参数，那么 scope 将作为 action 运行时的this。 如果传了第一个参数 debugName，那么在调试工具中将使用 debugName 作为调试信息。 和 autorun 一样，autorunAsync 也会返回一个销毁函数。 1234567autorunAsync(() =&gt; &#123; // 我们假设 searchBar.keyword 已经被观测, 是搜索输入框的值。当它发生变化时我们要把它发送到服务端请求搜索结果。 // 如果这里使用autorun，那么每次变化都会向调用sendKeywordToServer。 // 使用autorunAsync延迟300ms发送，当发送时，searchBar.keyword会是这300ms内变化的最终值。 // 这样就可以有效的防止频繁请求造成服务抖动。 sendKeywordToServer(searchBar.keyword);&#125;, 300); Atom类 和 Reaction类Atom有些时候，你可能想要有更多的数据结构或其他的东西(比如streams)，也可以用于响应计算。可以使用 Atom 类简单快速的实现这一功能。Atom 实例可以通知mobx观测对象发生了变化，而mobx会在启用和停用观测对象的时候通知 Atom 实例。 下面的例子展示了 Atom 的全部功能，这个例子展示了如何创建一个时钟，这个时钟只有在被观测时才会运行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import &#123;Atom, autorun&#125; from "mobx";class Clock &#123; atom; intervalHandler = null; currentDateTime; constructor() &#123; // 创建一个Atom实例 this.atom = new Atom( // 第一个参数: Atom实例的名字, 调试用的 "Clock", // 第二个参数（可选）: 从不被监听到被监听时的回调函数. () =&gt; this.startTicking(), // 第三个参数（可选）: 从被监听到不被监听时的回调函数 // 注意，atom实例会多次在这两种状态见转换 () =&gt; this.stopTicking() ); &#125; getTime() &#123; // 如果Atom实例被响应函数调用，则reportObserved返回true。 // 同时，reportObserved会通知mobx这个实例在响应回调中被使用了，它还会触发实例的第二个参数（startTicking） if (this.atom.reportObserved()) &#123; return this.currentDateTime; &#125; else &#123; // 当没有响应函数调用Atom实例的时候，就不会触发startTicking。 // 根据不同的情况，这里也可以做不同的处理，比如抛出一个错误，返回一个默认值等等。 return new Date(); &#125; &#125; tick() &#123; this.currentDateTime = new Date(); // 通知mobx当前值发生了变化 this.atom.reportChanged(); &#125; startTicking() &#123; this.tick(); // 初始化时钟 this.intervalHandler = setInterval( () =&gt; this.tick(), 1000 ); &#125; stopTicking() &#123; clearInterval(this.intervalHandler); this.intervalHandler = null; &#125;&#125;const clock = new Clock();const disposer = autorun(() =&gt; console.log(clock.getTime()));// ... 每秒打印时间disposer();// 停止打印。如果没有响应函数调用当前clock实例，那么时钟将停止。会触发stopTicking函数。 Reaction使用 Reaction 可以创建一个自定义的监听器。Reaction 接受一个函数作为参数，他会分析这个函数所依赖的被观测对象，然后追踪他们，当他们发生变化时发出事件。 下面的例子展示了 autorun 是如何用 Reaction 实现的，其实这个例子我没看太懂，貌似必须调用 Reaction 的track方法才能追踪并发出信号，但是例子中是在 Reaction 接收的函数中调用，然后runReaction的时候开始，具体的得等我翻了源码之后才能知道了…… 12345678910111213141516export function autorun(view: Lambda, scope?: any) &#123; if (scope) view = view.bind(scope); const reaction = new Reaction(view.name || "Autorun", function () &#123; this.track(view); &#125;); // 开始或者排入队列 if (isComputingDerivation() || globalState.inTransaction &gt; 0) globalState.pendingReactions.push(reaction); else reaction.runReaction(); return reaction.getDisposer();&#125; createTransformercreateTransformer(transformation: (value: A) =&gt; B, onCleanup?: (result: B, value?: A) =&gt; void): (value: A) =&gt; B createTransformer 可以将一个转换函数（可以将一个值转换为另一个值得函数，比如数组的map方法接收的函数）包装成一个可缓存的响应函数。换句话说, 如果参数transformation接收到一个值A，然后把A转化为了B，那么以后再接收到A，它就会把缓存的B返回。如果A发生了变化，那么transformation会重新计算更新B。如果没有响应函数引用这个转换函数了，那么他将自动清除自己的缓存。 使用 createTransformer 可以方便的对一个完整的数据结构进行转换（原文：it is very easy to transform a complete data graph into another data graph，我个人理解是，作者想表达这种转换方式对图这种数据结构会特别有效……）。转换函数还可以进行嵌套，这样你就可以用很多小的转换函数碎片组成一个树状结构，描述更复杂的模型。最终组成的数据模型不会过期，他会一直与组成他的转换函数碎片保持同步。这个特性能让mobx很容易实现一些强大的功能，比如sideways data loading（react的一个概念，将数据直接推送给某些具体的组件，而非从父级层层传递，数据加载后基本上无需从底层刷新app，而是刷新若干组件中某个具体的部分）、map-reduce（仿佛说的是谷歌三宝之一的MapReduce架构……map-reduce与js相关的资料我没有查到，具体MapReduce的介绍可以看这里）、追踪不可变对象变更历史，等等。 onCleanup 参数会在转换函数不再被使用时被调用，可以用来销毁资源。 转换函数需要用响应函数包装才能起作用，比如放在 @observer 或者 autorun 里。和其他的计算属性一样，如果不再有观察者调用，转换函数也将退好为惰性的，不会自动执行，以保证程序的性能。 上面说的各种概念可能会比较难理解，下面列出了两个例子来解释之前的概念: 追踪数据变化，分享数据结构这个例子是从这里来得（我能从中看出追踪数据状态来，但是分享数据结构没看出来……）: 12345678910111213141516171819202122232425262728293031/* store用来保存boxes和arrows*/const store = observable(&#123; boxes: [], arrows: [], selection: null&#125;);/** states列表用来保存序列化之后的store历史状态*/const states = [];autorun(() =&gt; &#123; states.push(serializeState(store));&#125;);const serializeState = createTransformer(store =&gt; (&#123; boxes: store.boxes.map(serializeBox), arrows: store.arrows.map(serializeArrow), selection: store.selection ? store.selection.id : null&#125;));const serializeBox = createTransformer(box =&gt; (&#123;...box&#125;));const serializeArrow = createTransformer(arrow =&gt; (&#123; id: arrow.id, to: arrow.to.id, from: arrow.from.id&#125;)); 在这个例子中，states中的每个state的序列化，由三个不同的转化函数完成。autorun触发store的序列化，进而序列化所有的boxes和arrows。 让我们用一个假设的例子来看看执行的过程。假设我们往store.boxes中添加一个box，我们叫他box#3。 首先box#3会被 map 方法传入 serializeBox 函数，serializeBox 函数执行将其序列化并将结果添加进自己的缓存列表。 当另一个box别添加进store.boxes，将导致 serializeState 函数重新计算结果，从而产生一个全新的boxes列表。在这个过程中，对于已存在的值，serializeBox都将从缓存列表返回旧值，这样转换函数就不需要再次运行了。 然后，如果有人更改box#3属性，这将导致 serializeBox 重新计算box#3的值。转换函数将产生一个新的box#3的Json对象，所有订阅了这个转换函数的观察者都将再次运行。这个例子中 serializeState 会自动执行。serializeState将产生新值，映射所有的box的。除了box#3，其他所有box的值都将会从缓存列表返回。 最后，如果box#3从 store.boxes 中移除，serializeState 也将重新计算。serializeBox 不再监听box#3，监听它的响应函数也将退化为非响应模式。serializeBox 的缓存列表中也将移除box#3的缓存。 上面的例子中，我们使用不可变的状态跟踪有效的取得了状态变化列表,共享了数据结构。所有box和arrow都会被转化为简单状态树。每次计算的都会给states 中添加一条新的数据。不同的数据之间将共享box和arrow。 将一个数据结构转换为一个可响应的数据结构 这段儿我都看懵逼了……纯凭感觉理解的……下面贴上原文对比着看吧 Instead of returning plain values from a transformation function, it is also possible to return observable objects. This can be used to transform an observable data graph into a another observable data graph, which can be used to transform… you get the idea. 转换函数除了可以返回一般数据类型，还可以返回观测对象。所以也可以使用转换函数完成可观测对象间的转换。 Here is a small example that encodes a reactive file explorer that will update its representation upon each change. Data graphs that are built this way will in general react a lot faster and will consist of much more straight-forward code, compared to derived data graph that are updated using your own code. See the performance tests for some examples. 下面是个自动响应的文件管理器的例子。使用这种方式构建的数据结构，形式上更加简单直接，数据更新时响应速度也比一般的方式快的多。可以看一看这些例子的性能测试。 Unlike the previous example, the transformFolder will only run once as long as a folder remains visible; the DisplayFolder objects track the associated Folder objects themselves. 不像之前的例子，如果文件夹一直可见，那么 transformFolder 只会运行一次；DisplayFolder 对象会追踪 Folder 对象的变化。 In the following example all mutations to the state graph will be processed automatically. Some examples: 下面的例子中，所有对 state 的改变都会自动处理。比如做如下操作： Changing the name of a folder will update it’s own path property and the path property of all its descendants. 改变文件夹的名字将更新它和它的子文件夹的文件路径， Collapsing a folder will remove all descendant DisplayFolders from the tree. 折叠一个文件夹将会移除所有子文件夹的DisplayFolder实例 Expanding a folder will restore them again. 展开文件夹时，子文件夹再都恢复回来 Setting a search filter will remove all nodes that do not match the filter, unless they have a descendant that matches the filter. 如果设置了搜索过滤条件，将会只保留符合条件的子文件夹，其他的都会移除掉。…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123;extendObservable, asFlat, observable, createTransformer, autorun&#125; from mobx;function Folder(parent, name) &#123; this.parent = parent; extendObservable(this, &#123; name: name, children: asFlat([]), &#125;);&#125;function DisplayFolder(folder, state) &#123; this.state = state; this.folder = folder; extendObservable(this, &#123; collapsed: false, name: function() &#123; return this.folder.name; &#125;, isVisible: function() &#123; return !this.state.filter || this.name.indexOf(this.state.filter) !== -1 || this.children.some(child =&gt; child.isVisible); &#125;, children: function() &#123; if (this.collapsed) return []; return this.folder.children.map(transformFolder).filter(function(child) &#123; return child.isVisible; &#125;) &#125;, path: function() &#123; return this.folder.parent === null ? this.name : transformFolder(this.folder.parent).path + "/" + this.name; &#125; &#125;);&#125;var state = observable(&#123; root: new Folder(null, "root"), filter: null, displayRoot: null&#125;);var transformFolder = createTransformer(function (folder) &#123; return new DisplayFolder(folder, state);&#125;);autorun(function() &#123; state.displayRoot = transformFolder(state.root);&#125;); exprexpr(worker: () =&gt; void) expr 可以在计算属性的函数中创建一个临时的计算属性，其实就是computed(func).get()。作者在文档中说设计这个api的意图是为了提升计算属性的性能，比如下面的例子，如果使用 expr 替代直接用比较运算，可以利用计算属性的缓存，减少运算次数。 1234const TodoView = observer((&#123;todo, editorState&#125;) =&gt; &#123; const isSelected = mobx.expr(() =&gt; editorState.selection === todo); return &lt;div className=&#123;isSelected ? "todo todo-selected" : "todo"&#125;&gt;&#123;todo.title&#125;&lt;/div&gt;;&#125;); extendObservableextendObservable(target: object, ...properties: object) 在之前的几篇文章中，我们已经大概见过 extendObservable 应用的实例了。 extendObservable 和 Object.assign 类似，接受多个参数，将 properties 上所有的键值对，都合并到 target 上，同时把它们都转换成可观测的属性。 如果属性值是一个没有参数的函数，那 extendObservable 将用 computed 把它转化为一个计算属性。 所以，observable(object) 其实是 extendObservable(object, object)的别名。 1234567891011121314var Person = function(firstName, lastName) &#123; // 在当前实例为观测对象 extendObservable(this, &#123; firstName: firstName, lastName: lastName &#125;);&#125;var matthew = new Person("Zheng", "Xingcheng");// 向观测对象上添加属性extendObservable(matthew, &#123; age: 30&#125;); isObservableisObservable(testValue:object, propertyName?: string) isObservable 是用来判断一个变量是不是用observable观测对象的，如果是就会返回true，如果想看变量的某个属性是否可观测，直接传入属性的引用是不行的，需要传第二个参数 propertyName 指定要判断哪个属性，如果属性可观测，就返回true 1234567891011var person = observable(&#123; firstName: "Zheng", lastName: "Xingcheng"&#125;);person.age = 30;console.log(isObservable(person)); // trueconsole.log(isObservable(person, "firstName")); // trueconsole.log(isObservable(person.firstName)); // false (just a string)console.log(isObservable(person, "age")); // false 为了细化各种类型的判断，mobx还提供了map，array，object三种类型的判断，比起 isObservable ，他们的判断标准更严格，如果类型不符合就会返回false。 isObservableMapisObservableMap(testValue:object) 如果testValue是用 mobx.map 创建的对象，则返回true。 isObservableArrayisObservableArray(testValue:object) 如果testValue是用 mobx.observable(array) 创建的对象，则返回true。 isObservableObjectisObservableObject(testValue:object) 如果testValue是用 mobx.observable(object) 创建的对象，则返回true。 12345678910var testValue = observable(&#123; arr: [1, 2, 3], obj: &#123; x: 1 &#125;, map: map([['y',2]])&#125;);console.log(isObservableMap(testValue.map)); // trueconsole.log(isObservableArray(testValue.arr)); // trueconsole.log(isObservableObject(testValue.obj)); // true modifiersintercept &amp; observereactionspyspy(listener) spy 可以注册一个全局的监听函数，监听所有的mobx发出的事件，通常是用来做log或者做调试的。 比如以下例子，会打印所有的action： 12345spy((event) =&gt; &#123; if (event.type === 'action') &#123; console.log(`$&#123;event.name&#125; with args: $&#123;event.arguments&#125;`) &#125;&#125;) 不同的操作，event也会不一样，下面的表格是每种事件对应的参数： event event带的属性 是否可以嵌套发生 action name, target (scope), arguments, fn (source function of the action) yes transaction name, target (scope) yes scheduled-reaction object (Reaction instance) no reaction object (Reaction instance), fn (source of the reaction) yes compute object (ComputedValue instance), target (scope), fn (source) no error message no update (array) object (the array), index, newValue, oldValue yes update (map) object (observable map instance), name, newValue, oldValue yes update (object) object (instance), name, newValue, oldValue yes splice (array) object (the array), index, added, removed, addedCount, removedCount yes add (map) object, name, newValue yes add (object) object, name, newValue yes delete (map) object, name, oldValue yes create (boxed observable) object (ObservableValue instance), newValue yes toJStoJS(value: any, supportCycles?=true: boolean) toJS可以将一个observableObject下的转化为javascript原生的对象。他会递归转换array，object，map和基础类型的值，但是不会转换计算属性和其他不可枚举的值。默认情况下，toJS会缓存下每次运行的值，貌似作者设计这个api就是为了输出log用的，可以设置 supportCycles 参数为false来提高toJS的性能。 对于更复杂的序列化反序列化场景，mobx的作者推荐使用他开发的serializr库。 transactiontransaction(worker: () =&gt; void) 在之前的 autorunAsync 有提到过，除了 autorunAsync ，还可以使用 transaction 来做批量处理。 transaction 用来批处理一系列的更新，而不会通知观测对象，当所有更新结束，才会发出通知。transaction 接收一个没有参数的worker函数作为参数，在这个函数执行完成之前，不会通知观察者。transaction 的返回值就是worker函数的返回值。另外 transaction 是同步的，可以被嵌套，只有最外层的 transaction 执行完，才会触发响应。 123456789101112131415import &#123;observable, transaction, autorun&#125; from "mobx";const numbers = observable([]);autorun(() =&gt; console.log(numbers.length, "numbers!"));// Prints: '0 numbers!'transaction(() =&gt; &#123; transaction(() =&gt; &#123; numbers.push(1); numbers.push(2); &#125;); numbers.push(3);&#125;);// Prints: '3 numbers!' untrackeduntracked(fn: () =&gt; void) 使用 untracked 可以创建一个不被观测的代码块，通常 untracked 需要放在 (@)action 里面才有意义，比如以下的例子： 123456789101112131415161718192021const person = observable(&#123; firstName: "Michel", lastName: "Weststrate"&#125;);autorun(() =&gt; &#123; console.log( person.lastName, ",", // person.firstName放在了untracked的回调里面，所以不会跟这个autorun的监听函数绑定到一起 // 在修改person.firstName时就不会触发这个监听函数 untracked(() =&gt; person.firstName) );&#125;);// prints: Weststrate, Michelperson.firstName = "G.K.";// doesn't print!person.lastName = "Chesterton";// prints: Chesterton, G.K. whenwhen(debugName?, predicate: () =&gt; boolean, effect: () =&gt; void, scope?) when 会感测并运行参数predicate，predicate有点类似一个计算属性，当predicate为true的时候，则自动运行effect，然后销毁自己。所以 when 是一个只运行一次的 autorun。 下面这个例子展示了用 when 来实现自动销毁组件的功能： 123456789101112131415161718class MyResource &#123; constructor() &#123; when( // 当断言为真... () =&gt; !this.isVisible, // ... 则运行一次然后销毁 () =&gt; this.dispose() ); &#125; @computed get isVisible() &#123; // 返回组件是否可见 &#125; dispose() &#123; // 销毁组件 &#125;&#125; 总结本篇整理了下mobx的公共方法和作用。就此，基础api算是都介绍完了。之后会再着重写些使用方法和介绍mobx原理的内容。 话说最近懒癌又开始发作了……_(:3 」∠)_……看着朋友们跟打了鸡血一样写那么多blog好着急的说……希望以后能迎头赶上吧……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MobX入坑指南(3) -- Observable Types]]></title>
      <url>%2F2016%2F12%2F09%2FMobX-simple-entry-3%2F</url>
      <content type="text"><![CDATA[这周阅读了一部分mobx的源码，和作者写的几篇介绍文章，发现这个库有些特性还挺有趣的。以下的内容大部分翻译自mobx文档中 Observable Types 一节，奈何小生英文水平有限，没有划词软件帮忙就看不懂句子……所以翻的很渣，基本上都是掺杂了一些我的理解在里边，连蒙带猜拼出来的，有啥写的不对的，也请多指教了~(￣▽￣)~* 在mobx中，如果你想监听某个变量的变化，需要先使用 observable 函数将其转化为生成Observable对象才行。这个章节主要讲的是 observable 函数生成的不同Observable对象 Observable Objects当 observable 函数接受的参数是个普通的javascript object（普通javascript对象是指不是通过构造函数生成的对象，mobx的判断方式是，通过getPrototypeOf获取原型，检查是不是Object.prototype或者null）时，这个对象中的所有属性都将被传入 observable 函数进行转换，如果属性值是object或者array，则会递归的转化内部的元素。 123456789101112131415161718192021222324252627282930313233import &#123;observable, autorun, action&#125; from "mobx";var person = observable(&#123; // 常量会自动使用observable转化: name: "John", age: 42, showAge: false, // 有get描述符的属性会自动使用computed转化: get labelText() &#123; return this.showAge ? `$&#123;this.name&#125; (age: $&#123;this.age&#125;)` : this.name; &#125;, // 如果直接写 // labelText: function () &#123; // return this.showAge ? `$&#123;this.name&#125; (age: $&#123;this.age&#125;)` : this.name; // &#125; // 在自动转化时会报一个warning，mobx认为渲染函数需要用computed显式调动一下 // labelText: computed(function () &#123; // return this.showAge ? `$&#123;this.name&#125; (age: $&#123;this.age&#125;)` : this.name; // &#125;) // 同理，action也需要显式调动一下: setAge: action(function(age) &#123; this.age = age; &#125;)&#125;);autorun(() =&gt; console.log(person.labelText));person.name = "Dave";// 'Dave'person.setAge(21);console.log(person.age);// 21 需要注意的点： 当对象传入 observable 函数时，只有当时对象上已经存在的属性才能被监听，后添加的属性是不能的，如果想要往已经生成的Observable对象上添加属性，需要使用extendObservable函数进行类似merge的操作。 123456//接上面的例子extendObservable(person, &#123; sex: 'male'&#125;);console.log(person.sex);// 'male' 只有普通对象能够被转化为Observable对象。使用构造函数创建的对象，需要在构造函数初始化时使用extendObservable函数合并属性。使用类创建的对象，需要使用 @observable装饰器包装类的属性。 123456789101112131415161718192021var Person = function(firstName, lastName) &#123; // 在一个新的对象里写要监听的属性，然后merge和当前实例merge extendObservable(this, &#123; firstName: firstName, lastName: lastName &#125;);&#125;var zxc = new Person("Zheng", "Xingcheng");// 或者class Person &#123; @observable firstName:string = ""; @observable lastName:string = ""; constructor(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125;var zxc = new Person("Zheng", "Xingcheng"); 带有get描述符的属性会自动被@computed转化，第一个例子中已经展示了。 如果对象的属性值是一个构造函数生成的对象（我真是不想把它叫成”非普通对象”……），那这个属性也不会被 observable 函数自动转化。 基本上使用observable 函数自动转化已经能解决绝大部分的使用场景了（原文写的是”95% of the cases”……）。如果想要了解更详细的设定每个属性的方法，请看 modifiers 一章（本来这一章的内容也想发到这里的，但是实在是没时间写了只能拉倒……等下次吧）。 Observable Arrays和 object 类似，array 也可以使用 observable函数转化为ObservableArray对象。当然，也是递归转化每个元素的，所以数组的所有元素也会被转化。 123456789101112131415161718192021222324import &#123;observable, autorun&#125; from "mobx";var todos = observable([ &#123; title: "吃午饭", completed: true &#125;, &#123; title: "喝咖啡", completed: false &#125;]);autorun(() =&gt; &#123; console.log("代办:", todos .filter(todo =&gt; !todo.completed) .map(todo =&gt; todo.title) .join(", ") );&#125;);// '代办: 喝咖啡'todos[0].completed = false;// '代办: 吃午饭, 喝咖啡'todos[2] = &#123; title: "睡午觉", completed: false &#125;;// '代办: 吃午饭, 喝咖啡, 睡午觉'todos.shift();// '代办: 喝咖啡, 睡午觉' 由于ES5中原生数组的限制（array.observe到ES7中才有，而且数组不能扩展），observable函数基于原始数组克隆了一个新的数组，这个新数组支持所有原生数组的方法和功能，同时还有监听值变化的能力。 不过，当使用Array.isArray检查包装后数组时返回的是false。所以在跟其他库联合使用时，如果想把ObservableArray对象当做数组传递给其他库，最好使用浅拷贝生成新数组，或者使用 array.slice 方法生成新数组，就是说 Array.isArray(observable([]).slice()) 返回的是true。 由于不喜欢原生的 array.sort 和 array.reverse 方法，ObservableArray对象的 sort 和 reverse 方法是并不会改变自身的，而是返回一个新的ObservableArray对象。 除了原生数组支持的方法，ObservableArray对象还可以使用以下的方法： intercept(interceptor)这个方法可以在所有数组的操作被应用之前，将操作拦截。具体的请看observe &amp; intercept observe(listener, fireImmediately? = false)这个方法可以监听数组的变化，回调函数会接收数组新增或者修改的元素，符合ES7的规范。这个方法返回一个注销函数用来停止监听。 clear()清空数组。 replace(newItems)替换数组里的所有元素。 find(predicate: (item, index, array) =&gt; boolean, thisArg?, fromIndex?)使用方法与ES7的 array.find 一致，但是增加了formIndex参数。 remove(value)移除数组中第一个值等于value的元素，如果移除成功会返回true。 peek()与 slice 类似，会返回一个包含所有元素的数组。它与 slice 的区别在于 peek 不会进行保护性拷贝，所以性能更好。 Observable Mapsobservable(asMap(values?, modifier?)) 和 map(values?, modifier?)) 方法可以创建一个ObservableMap对象。如果你不想响应特定属性的变化，还要添加删除属性，那么使用ObservableMap对象很合适。不同于ES6的Map对象，ObservableMap对象是能用字符串当做key。 根据ES6 Map的规范，可以使用以下方法: has(key)返回map中是否存在这个key，这个方法是可被监听的 set(key, value)设置key对应的value，如果key之前不错在，那么这个key会被添加上 delete(key)删除key和key对应的value get(key)获取key对应的value，如果没找到会返回undefined keys()获取map的所有key，顺序为key的插入顺序 values()获取map的所有key对应的value，顺序为key的插入顺序 entries()返回一个数组，数组中每个元素为一个数组，数组中的元素为map中的key/value对，形式如[key, value]，顺序为key的插入顺序 forEach(callback:(value, key, map) =&gt; void, thisArg?)对map中的每个key/value对调用回调 clear()清除map中的所有key/value对 size()返回map中所有key/value对的数量 ObservableMap对象还提供了以下方法可以使用: toJS()返回一个map的浅拷贝的对象，如果想获得深拷贝的对象，需要使用 mobx.toJS(map) intercept(interceptor)注册一个拦截器，拦截器会在map被修改之前被触发。具体的请看observe &amp; intercept observe(listener, fireImmediately?)注册一个监听，map被修改时会被触发。与Object.observe类似。具体的请看observe &amp; intercept merge(object | map)将对象上所有的属性拷贝到当前map中 Primitive (常量）在javascript中，常量是不可变的，所以也没办法观测。所以如果想要监听一个常量属性的变化，需要使用 observable 函数包装一下。 observable 函数包装后会返回一个ObservablePrimitive对象。这个对象使用get和set方法来获取和改变变量的值。可以使用 .observe 方法来监听值的变化。不过通常使用 mobx.autorun 是更好的选择。 以下是ObservablePrimitive支持的方法： get()返回当前值 set(value)替换当前存储的值，并通知所有的监听器 intercept(interceptor)注册拦截器，当值发生变化前触发。具体的请看observe &amp; intercept observe(callback: (newValue, previousValue) =&gt; void, fireImmediately = false)注册监听器，当值发生变化时触发，返回一个注销函数。具体的请看observe &amp; intercept 12345678910111213import &#123;observable&#125; from "mobx";const cityName = observable("Vienna");console.log(cityName.get());// 'Vienna'cityName.observe(function(newCity, oldCity) &#123; console.log(oldCity, "-&gt;", newCity);&#125;);cityName.set("Amsterdam");// 'Vienna -&gt; Amsterdam' References (引用类型）之前在ObservableObject中提到，observable在转换时会自动用computed包装函数，这个自动转换其实是由限制条件的。mobx只会转换渲染用的函数，既函数不能接受参数，如果接受参数，则认为这个是一个复合函数，就不会自动转化。同样的，如果对象中有属性是通过构造函数或者类创建的对象，也不会自动转化。他们都继续保持着转化之前的引用。 有时我们也会有这一类的需求，要求对象中某个属性不被自动转化。可以使用 asReference 来达到这一目的。 12345678910111213141516var test = observable(&#123; x : 3, doubler: function() &#123; return this.x*2; &#125;, someFunc: asReference(function() &#123; return this.x; &#125;)&#125;);console.log(test.doubler);// 6console.log(test.someFunc);// function() &#123;// return this.x;// &#125; 总结总体感觉上，mobx的api和knockout的api很像，但是在实现原理上，更像rx。mobx实现监听变化调用回调的过程是同步的，通过这种方式就能会自动的分析各个变量间的调用关系，从而减少重复订阅的情况。同时计算最新的值时还是用了memoizing技术，这样就算调用频繁，性能上也能得到保证。 相关文章 Observable Objects Observable Arrays Observable Maps Primitive values and references]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MobX入坑指南(2) -- action]]></title>
      <url>%2F2016%2F11%2F29%2FMobX-simple-entry-2%2F</url>
      <content type="text"><![CDATA[上一篇简单介绍了下mobx常用的几个api(observable、computed、autorun)，以及mobx-react的api(observer)。这次说说action。 action用法： action(fn) action(name, fn) @action classMethod @action(name) classMethod @action boundClassMethod = (args) =&gt; { body } @action(name) boundClassMethod = (args) =&gt; { body } 之前的例子里使用了回调的方式来触发响应，mobx其实也支持使用flux的方式来出发响应，并且在2.2版本提供了action的功能。 action是一个工厂函数，可以接受name和fn两个参数，name是String，主要描述action的作用，fn是Function，是这个action的具体逻辑。action执行后返回一个函数，调用这个函数就会执行action，其实就是调用fn参数。 个人感觉在mobx中，action的作用更多的是用来注释当前的操作……使用的时候在name参数上写操作是干啥的，能够快速的了解action的意图。当然如果安装了devtools，action还能输出调试信息。 需要注意的是，如果使用useStrictapi开启了严格模式，就必须通过action才能修改状态(state)，直接修改值会报错。 举个🌰 123456789101112131415161718192021222324import &#123;observable, useStrict, action, computed, autorun&#125; from 'mobx';useStrict(true);let numbers = observable([1,2,3]);let sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, 0));let disposer1 = autorun(() =&gt; console.log(`sum:$&#123;sum.get()&#125;`));// sum:6let disposer2 = autorun(() =&gt; console.log(`length:$&#123;numbers.length&#125;`));// length:3var pushNumber = action('push number',()=&gt;&#123; numbers.push(4)&#125;)pushNumber(4)// sum:10// length:4numbers.push(5)// Uncaught Error: [mobx] Invariant failed: It is not allowed to create// or change state outside an `action` when MobX is in strict mode. Wrap// the current method in `action` if this state change is intended. 另外，action在执行时是可以接受参数的，而且action在执行后还会返回fn参数的返回值，这一点文档里没有明显的说明，害的我翻源码才翻出来的……┑(￣Д ￣)┍……话说mobx是用typescript写的呢。虽然ts最近很火，而且功能也确实挺实用的，但是我对java一样死板的语法却怎么都都爱不起来……所以更看好WebAssembly一些…… 扯远了扯远了……那么我们再把上面那个例子修改一下： 123456789101112131415161718import &#123;observable, useStrict, action, computed, autorun&#125; from 'mobx';useStrict(true);let numbers = observable([1,2,3]);let sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, 0));// sum:6let disposer = autorun(() =&gt; console.log(`sum:$&#123;sum.get()&#125;`));var pushNumber = action('push number',(number)=&gt;numbers.push(number))console.log(`length:$&#123;pushNumber(6)&#125;`)// sum:12// length:4console.log(`length:$&#123;pushNumber(7)&#125;`)// sum:19// length:5 从上面的例子可以看到，传入pushNumber的参数最后被传入了action的fn中，然后pushNumber返回了push的返回值。 官方文档中的一个例子也能看到调用action返回函数时传递参数的应用场景： 1234567891011121314151617@action createRandomContact() &#123; this.pendingRequestCount++; superagent .get('https://randomuser.me/api/') .set('Accept', 'application/json') .end(action("createRandomContact-callback", (error, results) =&gt; &#123; if (error) console.error(error); else &#123; const data = JSON.parse(results.text).results[0]; const contact = new Contact(this, data.dob, data.name, data.login.username, data.picture) contact.addTag('random-user'); this.contacts.push(contact); this.pendingRequestCount--; &#125; &#125;));&#125; 在这个🌰中可以看到，action的返回值作为superagent.end的回调，接收error和results两个参数，最后传入fn进行处理。这个例子也引出了另一个问题，action中如何处理一步操作。 async action 和 runInActionaction只能影响正在运行的函数，而无法影响当前函数调用的异步操作。也就是说如果fn中有setTimeout，promise.then，async函数，并且这些函数的回调里对state进行了修改，那么这些回调也应该用action包装一下（在非严格模式下，action和直接修改state值都能生效，所以并不会出现异常，如果是严格模式下就会报错）。 还有，如果要使用async函数作为action，不能直接用action包装async函数，这里需要使用一个tricky，将一个async匿名函数赋值给一个变量或者属性再做包装。 12345678@action updateDocument = async () =&gt; &#123; const data = await fetchDataFromUrl(); /* required in strict mode to be allowed to update state: */ runInAction("update state after fetching data", () =&gt; &#123; this.data.replace(data); this.isSaving = true; &#125;)&#125; 上面的例子还用到了runInAction，它其实就是action(name,fn)()的语法糖，调用后action会立即执行，它的用法是：runInAction(name?, fn, scope?)，scope是fn调用时的this指向。注：2.3.0版本以后才能使用。 相关文章 MobX Documentation – action]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React全家桶又填新成员 MobX入坑指南(1)]]></title>
      <url>%2F2016%2F11%2F23%2FMobX-simple-entry-1%2F</url>
      <content type="text"><![CDATA[话说，吐槽被react全家桶坑的文章已经算是各大论坛上的月经贴了吧……行内样式、jsx里html和js混排、依赖太多、学习曲线陡峭……当然其中不乏抱怨redux反人类的…… 当然，这篇文章并不是来黑react不好的，毕竟以后涨工资还得靠它呢哈哈哈(￣▽￣)…… 今天咱们要说的是众多槽点之一，”反人类的redux”和其替代方案。 redux有什么不好？首先，redux绝对是个优秀的库。它体小精悍，api简单优雅，扩展能力强，足以衍生出丰富的工具集和生态系统。在它出现之前，各种flux实现貌似都不能让人如意，以至于有人宁可用 backbone 甚至是 angular 和 react搭配，也不用flux……后来redux出现，解决了flux操作繁琐的问题，开始受到人们的关注，再后来作者也加入了 facebook从事react的开发，redux也顺理成章的成为了react官方推荐状态管理库。 但是，在真正去开发的时候，我发现状态的维护还是有些繁琐，如果你在设计阶段没有考虑周全，开发时就要不停的在action,container,reducer之前修改，穿梭，让人眼花缭乱……嗯，也没准儿是我项目不够大…… 另外，由于redux大量使用函数式编程的思想，门槛有点高呢。当时为了理解redux里面的概念，我大概读了一周的文档…… 按你胃（Anywhere），如果你更熟悉面向对象，羡慕mvvm框架的简单，那你真的应该体验一下mobx mobx是啥？mobx是个新的状态管理库，响应式的，我是看了阮一峰的微博知道的，后来查了资料发现，redux的作者在twitter推荐了这个库，还是作为redex的替代品…… 那么废话少说，让我们现在看看mobx怎么用吧 api简单介绍和redux一样，mobx是一个独立的库，不依赖于react也能自己用，它只有三个概念：观测状态，计算值和反应。这三个概念分别对应三个mobx的api：observable，computed和autorun。 咱们先来个最简单的例子 1234567891011121314151617import &#123; observable, computed, autorun &#125; from 'mobx';let numbers = observable([1,2,3]);let sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, 0));let disposer1 = autorun(() =&gt; console.log(`sum:$&#123;sum.get()&#125;`));let disposer2 = autorun(() =&gt; console.log(`length:$&#123;numbers.length&#125;`));// sum:6// length:3numbers.push(4);// sum:10// length:4disposer2();numbers.push(5);// sum:15 这个例子中，observable用来绑定数据；computed用来绑定计算方法；autorun用来注册数据变化时响应的方法，返回的函数用来取消响应。 下面我们试着来写一个TodoList 12345678910111213141516171819202122232425262728import &#123; observable, computed, autorun &#125; from 'mobx';class Todo &#123; id = Math.random(); @observable content; @observable finished = false; constructor(content) &#123; this.content = content; &#125;&#125;class TodoList &#123; @observable todos = []; @computed get todoListString() &#123; return this.todos.filter(todo =&gt; !todo.finished).map((todo, i) =&gt; `$&#123;i+1&#125;. $&#123;todo.content&#125;`).join('\n'); &#125;&#125;const store = new TodoList();store.todos.push( new Todo("task1"), new Todo("task2"), new Todo("task3"));autorun(() =&gt; console.log(store.todoListString))store.todos[2].finished = true; 从上面的例子可以看到，针对类的属性，可以使用修饰器@observable、@computed来进行绑定，修饰器是ES7的一个提案，目前Babel已经支持。详细的介绍可以看ECMAScript 6 入门中修饰器一章 如果不想用修饰器，也可以使用extendObservable函数，跟修饰器的功能是一样的： 123456789101112131415161718192021222324252627282930313233import &#123; extendObservable, autorun &#125; from 'mobx';class Todo &#123; id = Math.random(); constructor(content) &#123; extendObservable(this, &#123; content: content, finished: false &#125;) &#125;&#125;class TodoList &#123; constructor() &#123; extendObservable(this, &#123; todos: [], todoListString: function() &#123; return this.todos.filter(todo =&gt; !todo.finished).map((todo, i) =&gt; `$&#123;i+1&#125;. $&#123;todo.content&#125;`).join('\n'); &#125; &#125;) &#125;&#125;const store = new TodoList();store.todos.push( new Todo("task1"), new Todo("task2"), new Todo("task3"));autorun(() =&gt; console.log(store.todoListString))store.todos[2].finished = true; mobx-react在跟react配合时，mobx提供了mobx-react包，使用@observer装饰器或者observer函数，可以自动将react组建的render方法包装到mobx.autorun里面。还是以前面的TodoList为例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import &#123; observable, computed &#125; from 'mobx';import &#123; observer &#125; from mobxReact;import &#123; Component &#125; from React;class Todo &#123; id = Math.random(); @observable content; @observable finished = false; constructor(content) &#123; this.content = content; &#125; finish() &#123; this.finished = true &#125;&#125;class TodoList &#123; @observable todos = []; @computed get unFinishedList() &#123; return this.todos.filter(todo =&gt; !todo.finished); &#125; @computed get finishedList() &#123; return this.todos.filter(todo =&gt; todo.finished); &#125; addTodo(content) &#123; if (content)&#123; this.todos.push(new Todo(content)) &#125; &#125;&#125;@observerclass TodoListView extends Component &#123; render() &#123; const &#123; todoList &#125; = this.props; let onChange = (event) =&gt; &#123; this.value = event.target.value &#125; let onClick = () =&gt; &#123; todoList.addTodo(this.value) &#125; return (&lt;div&gt; &lt;h2&gt;添加任务&lt;/h2&gt; &lt;input type="text" value=&#123; this.value &#125; onChange=&#123; onChange &#125;/&gt; &lt;button type="button" onClick=&#123; onClick &#125;&gt;添加&lt;/button&gt; &lt;h2&gt;未完成任务&lt;/h2&gt; &lt;ol&gt; &#123;todoList.unFinishedList.slice(0).map((todo,index) =&gt; &lt;TodoView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt; )&#125; &lt;/ol&gt; Tasks left: &#123;todoList.unFinishedList.length&#125; &lt;h2&gt;已完成任务&lt;/h2&gt; &lt;ol&gt; &#123;todoList.finishedList.map((todo) =&gt; &lt;FinishedView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt; )&#125; &lt;/ol&gt; &lt;/div&gt;) &#125;&#125;const TodoView = observer((props) =&gt;&#123; let &#123; todo &#125; = props; return (&lt;li&gt; &lt;input type="checkbox" checked=&#123;todo.finished&#125; onClick=&#123;todo.finish.bind(todo)&#125; /&gt;&#123;todo.content&#125; &lt;/li&gt;) &#125;);@observerclass FinishedView extends Component&#123; render() &#123; let &#123; todo &#125; = this.props; return (&lt;li&gt; &lt;del&gt;&#123;todo.content&#125;&lt;/del&gt; &lt;/li&gt;) &#125;&#125;const store = new TodoList();React.render(&lt;TodoListView todoList=&#123;store&#125; /&gt;, document.body);store.todos.push( new Todo("Get Coffee"), new Todo("Write simpler code")); 在上面的例子里可以看到，使用mobx-react的不同点只是在编写组件类时observer包装了一下，其他的跟不使用mobx-react没什么区别。另外，如果在stroe里加入方法，就可以做到类似action一样的动作，使用上比redux要简单很多。当然这也引出一个问题，就是当子组件状态变化影响到父组件的状态，如何通知父组件。redux用类似dbus的设计解决了这个问题，mobx怎么解决，我还没有看到，后续看到了再做补充。 简单的总结怎么说呢，总感觉mobx的功能和vue好像……￣ω￣=……特别是computed……这种设计对于写惯了mvc的人来说会感觉非常亲切，stroe其实就是相当于平时常写的model嘛，概念很容易理解。难度上，个人感觉不高，除了一些绑定后的数据需要调用set、get方法，api也不多。 其实mobx还有很多的功能没有介绍到，而且在网上资料也很少，如果有时间的话，打算试着翻译mobx的文档。更多的例子，后续再做详细的补充，今天就先到这里吧，我实在是写不动了……_(:3 」∠)_ 相关文章 MobX Documentation A short introduction to MobX]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浮点数计算为什么不精确]]></title>
      <url>%2F2016%2F11%2F17%2F%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%B2%BE%E7%A1%AE%2F</url>
      <content type="text"><![CDATA[其实这篇博客早就写好了，只不过之前懒一直没有整理完善……哈哈哈…… _(:3 」∠)_ 前几几几几天，在微博上看到寇胖转了一个关于浮点数计算的微博，里面的内容不太准确。正好之前我调查过一些关于浮点数的资料，在这里好好掰吃掰吃，做个记录~(￣▽￣)~* 结论先说结论，嫌又臭又长的看到这里就可以了: 浮点数计算不精确并不是bug，因为标准就是这样的。 原因简单来说是这样：2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。 解决方法：对于需要精确结果的场景，别直接使用浮点数进行计算。现阶段可以使用big.js解决，等以后ecmascript实现decimal了，就可以使用decimal类型计算了。 小数算不准，真的是js的锅吗？说到这个问题，其实这是两个锅，js计算不准确不止会出现在小数的计算上，还会出现在大整数计算上，可以运行下面两行代码查看问题的具体表现： 120.1 + 0.2 == 0.3; // false9999999999999999 + 2 == 10000000000000001; // false 当然，这个锅肯定不是javascript背。事实上，使用了IEEE 754 标准来存储浮点类型的任何编程语言（C/C++/C#/Java 等等）都存在精度丢失问题。 例如在 Java 中，要想算准浮点数，同样不能直接计算，需要使用 BigDecimal 类来进行相应的处理。 当然，javascript也并没有落后于其他语言。ECMAScript 规范中已有 decimal 类型的提案了，但目前尚未被正式采纳。 为什么不算准？要解释这个问题，就得从10进制与2进制的转换说起。 众所周知，计算机做运算是使用二级制的。所以其实咱们在程序中做10进制运算，都是要转换为2进制再进行计算的。10进制整数转换为2进制的方法可能大家都知道： 除以2，商继续除以2，得到0为止，将余数逆序排列例如：22 / 2 11 余 011 / 2 5 余 15 / 2 2 余 12 / 2 1 余 01 / 2 0 余 1所以22的的二进制是10110 那10进制小数转换为2进制的方法呢？ 乘以2，取整，小数部分继续乘以2，取整，得到小数部分0为止，将整数顺序排列0.8125 x 2 1.625 取 10.625 x 2 1.25 取 10.25 x 2 0.5 取 00.5 x 2 1.0 取 1所以0.8125的二进制是0.1101 那么问题就来了，比如你想计算10进制0.2的2进制： 0.2 x 2 0.40.4 x 2 0.80.8 x 2 1.60.6 x 2 1.20.2 x 2 0.4…… 发现了吗？它乘不尽，是无限循环的…… 而 javascript 使用64位双精度浮点数存储数字，类似科学计数法，其中1位用来存储符号，11位用来存储指数值，52位用来存储尾数值（真正的数字），当计算的结果的二进制有效位数超过 52 位时，就会出现精度丢失的问题…… 大整数计算的原因也是一样，有效位数超过 52位时，精度就会丢失 这就解释了下面这种情况： 十进制 0.1 的二进制为 0.0 0011 0011 0011 … （循环 0011）十进制 0.2 的二进制为 0.0011 0011 0011 … （循环 0011） 0.1 + 0.2 相加可表示为： e = -4; m = 1.10011001100…1100（52 位） + e = -3; m = 1.10011001100…1100（52 位）-——————————————– e = -3; m = 0.11001100110…0110 + e = -3; m = 1.10011001100…1100-——————————————– e = -3; m = 10.01100110011…001-——————————————– = 0.01001100110011…001 = 0.30000000000000004（十进制） 但是0.05和0.2用二进制都无法精确表达，0.05 + 0.2 却不会计算错误，0.2 + 0.7 会计算错误，1.2 +1.7 又不会，这又是为什么？ 具体的原因我并没有找到相关的资料…… 貌似这和 IEEE 754 的舍入模式有关系。 IEEE 754 采用的是最近舍入模式，和我们最熟悉的是四舍五入模式有些许不同，也是比较容易引起误解的地方之一。举例比较如下： 最近舍入模式：Round(0.5) = 0; Round(1.5) = 2; Round(2.5) = 2; 四舍五入模式：Round(0.5) = 1; Round(1.5) = 2; Round(2.5) = 3; 既当有两个最接近的可表示的值时首选“偶数”值。 具体的原因我会再调查调查，有了新的资料再补充到这里。 如何解决这个问题？当然，问题的解决方法其实也已经有前人跟咱们铺好路了，毕竟这个在问题在编程领域里其实是个挺常见的问题…… 网上的解决办法五花八门，总的原则就是逐位运算。我推荐 github 上 MikeMcl 开发的 big.js 。这个库不尽支持基础运算，而且还支持各种函数运算和比较运算，相当全面呢。实现上，是将数字按照科学计数法解析成一个包含正负符号、指数、尾数的对象，再做运算。例子就不写了，它的文档很全，而且简单易懂。 有趣的是，这个作者除了 big.js 还开发了另两个计算库 bignumber.js 和 decimal.js，三个库的侧重点不一样，关于这三个的对比，有兴趣的话可以看作者自己写的wiki What is the difference between big.js, bignumber.js and decimal.js? 相关文章: 浮点数为什么不精确？ JavaScript超大整数加法 JavaScript 中小数和大整数的精度丢失 IEEE 754 浮点数的表示精度探讨 IEEE 754]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>%2F2016%2F11%2F16%2F%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
      <content type="text"><![CDATA[哈，距离上次写博客刚好一年了呢，话说我还真是懒呢…… _(:3 」∠)_ 这里不得不感叹下榜样的力量是无穷的。要不是继伟发起每周写博客的活动，估计我现在还在床上躺着呢……读好书，交高人，此言非虚呀~ 总之，希望这是个新的开始，期待能遇见更好的自己~(｡･ω･｡)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Capitan之后JetBrains的产品都不能用了]]></title>
      <url>%2F2015%2F11%2F21%2FCapitan%E4%B9%8B%E5%90%8EJetBrains%E7%9A%84%E4%BA%A7%E5%93%81%E9%83%BD%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%86%2F</url>
      <content type="text"><![CDATA[更新了osx升级10.11 EL Capitan之后发现有好多坑啊……限制超多而且JetBrains的产品都不能用了…… 查了一溜够貌似是之前安装的一些系统软件都被清除了，而且还需要接触rootless模式，总之先附上搜索到的资料链接吧 Intellij IDEAやAppCodeが起動しない場合に考えられること（需翻墙）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[邮件链接中加入参数可以给要发送的邮件添加标题和内容，第一次发现唉]]></title>
      <url>%2F2015%2F10%2F21%2F%E9%82%AE%E4%BB%B6%E9%93%BE%E6%8E%A5%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E7%BB%99%E8%A6%81%E5%8F%91%E9%80%81%E7%9A%84%E9%82%AE%E4%BB%B6%E6%B7%BB%E5%8A%A0%E6%A0%87%E9%A2%98%E5%92%8C%E5%86%85%E5%AE%B9%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%91%E7%8E%B0%E5%94%89%2F</url>
      <content type="text"><![CDATA[a标签的href属性值可以是mailto协议的地址，这个比较常见，但是能加参数设置邮件内容我还是第一次见呢。 示例： mailto:xxx@xxx.com?Subject=标题&amp;Body=正文 貌似按照get方式加上参数就行了，Subject代表标题，Body代表正文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[总结下hexo搭建的过程]]></title>
      <url>%2F2015%2F10%2F16%2F%E6%80%BB%E7%BB%93%E4%B8%8Bhexo%E6%90%AD%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[2016-11-16 UPDATE: 距离写下这篇博客已经过了一年了，hexo在这一年里发展的挺快。现在hexo的文档已经齐全，整个工作流程也相当顺畅了。 安装过程中如果 node-gyp 报 error，可以尝试升级xcode，并安装xcode-select 升级 CLT。 下面附上几篇比较好的文章，建站过程中遇到问题可以查阅一下。 Hexo常见问题解决方案收集了很多使用hexo过程中的常见问题 hexo你的博客文章的内容很全，不止写了如何使用hexo，如何使用github，如何找图床等问题也都有描述，如果是使用github pages搭建博客的话，看这篇就够用了 如何搭建一个独立博客——简明Github Pages与Hexo教程和上一篇文章一样，这篇文章的内容也很全面，除了博客的搭建过程，如何在购买域名和服务器也有描述，只不过图片貌似都已经失效了……有些遗憾呢…… 翻译自GitHub Pages的Help页面（仍在更新中）github pages的help页面的翻译，对于英语苦手的人来说，应该会很有帮助吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[总结一下升级OS X El Capitan后brew遇到的问题]]></title>
      <url>%2F2015%2F10%2F15%2F%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%8D%87%E7%BA%A7OS-X-El-Capitan%E5%90%8Ebrew%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[升级了osx之后，先是brew update的时候报错，后来用brew安装jenv的时候又提示说需要root权限 Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo.Error: Failure while executing: /usr/bin/otool -L /usr/bin/install_name_tool 但是sudo brew install又报错 Error: Cowardly refusing to sudo brew installYou can use brew with sudo, but only if the brew executable is owned by root.However, this is both not recommended and completely unsupported so do so at your own risk. 搜了下貌似是新版osx的问题，需要进行权限设置，用chown命令设置一下就好了 以下是一些参考资料 How To Fix Cowardly Refusing to Sudo error in Brew – Mac OS X Failed brew update on El Capitan (OS X 10.11) Beta Mac OS X El Capitan にアップデートした後に brew update が動かない場合の対処方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[啊，我的第一次]]></title>
      <url>%2F2015%2F10%2F14%2Ffirst-love%2F</url>
      <content type="text"><![CDATA[人生第一篇blog，总觉得有点儿小激动呢……⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄ 话说再过生日就30岁了呢，做程序员也是第8个年头，愈发觉得将自己的平时的一些想法、遇到的一些问题记录下来很重要，其实以前也很想，奈何我懒…… 总之，之后会努力多写一些，也算是对自己的一种提升吧，嗯，希望我能一直坚持下去~ &lt;(￣▽￣)&gt; 哈哈哈……]]></content>
    </entry>

    
  
  
</search>
